/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const NULL: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 1;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 0;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const STEAMCLIENT_INTERFACE_VERSION: &[u8; 15] = b"SteamClient021\0";
pub const STEAMUSER_INTERFACE_VERSION: &[u8; 13] = b"SteamUser023\0";
pub const STEAMFRIENDS_INTERFACE_VERSION: &[u8; 16] = b"SteamFriends017\0";
pub const STEAMUTILS_INTERFACE_VERSION: &[u8; 14] = b"SteamUtils010\0";
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX: &[u8; 1] = b"\0";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING: u32 = 32;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const BUFSIZ: u32 = 512;
pub const _NSTREAM_: u32 = 512;
pub const _IOB_ENTRIES: u32 = 3;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 64;
pub const _IONBF: u32 = 4;
pub const L_tmpnam: u32 = 260;
pub const L_tmpnam_s: u32 = 260;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const FILENAME_MAX: u32 = 260;
pub const FOPEN_MAX: u32 = 20;
pub const _SYS_OPEN: u32 = 20;
pub const TMP_MAX: u32 = 2147483647;
pub const TMP_MAX_S: u32 = 2147483647;
pub const _TMP_MAX_S: u32 = 2147483647;
pub const SYS_OPEN: u32 = 20;
pub const k_nMaxLobbyKeyLength: u32 = 255;
pub const STEAMMATCHMAKING_INTERFACE_VERSION: &[u8; 20] = b"SteamMatchMaking009\0";
pub const STEAMMATCHMAKINGSERVERS_INTERFACE_VERSION: &[u8; 27] = b"SteamMatchMakingServers002\0";
pub const STEAMGAMESEARCH_INTERFACE_VERSION: &[u8; 24] = b"SteamMatchGameSearch001\0";
pub const STEAMPARTIES_INTERFACE_VERSION: &[u8; 16] = b"SteamParties002\0";
pub const STEAMREMOTESTORAGE_INTERFACE_VERSION: &[u8; 40] =
    b"STEAMREMOTESTORAGE_INTERFACE_VERSION016\0";
pub const STEAMUSERSTATS_INTERFACE_VERSION: &[u8; 36] = b"STEAMUSERSTATS_INTERFACE_VERSION012\0";
pub const STEAMAPPS_INTERFACE_VERSION: &[u8; 31] = b"STEAMAPPS_INTERFACE_VERSION008\0";
pub const STEAMNETWORKING_INTERFACE_VERSION: &[u8; 19] = b"SteamNetworking006\0";
pub const INVALID_SCREENSHOT_HANDLE: u32 = 0;
pub const STEAMSCREENSHOTS_INTERFACE_VERSION: &[u8; 38] =
    b"STEAMSCREENSHOTS_INTERFACE_VERSION003\0";
pub const STEAMMUSIC_INTERFACE_VERSION: &[u8; 32] = b"STEAMMUSIC_INTERFACE_VERSION001\0";
pub const k_SteamMusicNameMaxLength: u32 = 255;
pub const k_SteamMusicPNGMaxLength: u32 = 65535;
pub const STEAMMUSICREMOTE_INTERFACE_VERSION: &[u8; 38] =
    b"STEAMMUSICREMOTE_INTERFACE_VERSION001\0";
pub const INVALID_HTTPREQUEST_HANDLE: u32 = 0;
pub const INVALID_HTTPCOOKIE_HANDLE: u32 = 0;
pub const STEAMHTTP_INTERFACE_VERSION: &[u8; 31] = b"STEAMHTTP_INTERFACE_VERSION003\0";
pub const STEAM_INPUT_MAX_COUNT: u32 = 16;
pub const STEAM_INPUT_MAX_ANALOG_ACTIONS: u32 = 24;
pub const STEAM_INPUT_MAX_DIGITAL_ACTIONS: u32 = 256;
pub const STEAM_INPUT_MAX_ORIGINS: u32 = 8;
pub const STEAM_INPUT_MAX_ACTIVE_LAYERS: u32 = 16;
pub const STEAM_INPUT_MIN_ANALOG_ACTION_DATA: f64 = -1.0;
pub const STEAM_INPUT_MAX_ANALOG_ACTION_DATA: f64 = 1.0;
pub const STEAMINPUT_INTERFACE_VERSION: &[u8; 14] = b"SteamInput006\0";
pub const STEAM_CONTROLLER_MAX_COUNT: u32 = 16;
pub const STEAM_CONTROLLER_MAX_ANALOG_ACTIONS: u32 = 24;
pub const STEAM_CONTROLLER_MAX_DIGITAL_ACTIONS: u32 = 256;
pub const STEAM_CONTROLLER_MAX_ORIGINS: u32 = 8;
pub const STEAM_CONTROLLER_MAX_ACTIVE_LAYERS: u32 = 16;
pub const STEAM_CONTROLLER_MIN_ANALOG_ACTION_DATA: f64 = -1.0;
pub const STEAM_CONTROLLER_MAX_ANALOG_ACTION_DATA: f64 = 1.0;
pub const STEAMCONTROLLER_INTERFACE_VERSION: &[u8; 19] = b"SteamController008\0";
pub const STEAMUGC_INTERFACE_VERSION: &[u8; 30] = b"STEAMUGC_INTERFACE_VERSION018\0";
pub const STEAMHTMLSURFACE_INTERFACE_VERSION: &[u8; 39] =
    b"STEAMHTMLSURFACE_INTERFACE_VERSION_005\0";
pub const STEAMINVENTORY_INTERFACE_VERSION: &[u8; 30] = b"STEAMINVENTORY_INTERFACE_V003\0";
pub const STEAMVIDEO_INTERFACE_VERSION: &[u8; 26] = b"STEAMVIDEO_INTERFACE_V002\0";
pub const STEAMPARENTALSETTINGS_INTERFACE_VERSION: &[u8; 43] =
    b"STEAMPARENTALSETTINGS_INTERFACE_VERSION001\0";
pub const STEAMREMOTEPLAY_INTERFACE_VERSION: &[u8; 37] = b"STEAMREMOTEPLAY_INTERFACE_VERSION002\0";
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const STEAMNETWORKINGMESSAGES_INTERFACE_VERSION: &[u8; 27] = b"SteamNetworkingMessages002\0";
pub const STEAMNETWORKINGSOCKETS_INTERFACE_VERSION: &[u8; 26] = b"SteamNetworkingSockets012\0";
pub const STEAMNETWORKINGUTILS_INTERFACE_VERSION: &[u8; 24] = b"SteamNetworkingUtils004\0";
pub const STEAMGAMESERVER_INTERFACE_VERSION: &[u8; 19] = b"SteamGameServer015\0";
pub const STEAMGAMESERVERSTATS_INTERFACE_VERSION: &[u8; 24] = b"SteamGameServerStats001\0";
pub type uint8 = ::std::os::raw::c_uchar;
pub type int8 = ::std::os::raw::c_schar;
pub type int16 = ::std::os::raw::c_short;
pub type uint16 = ::std::os::raw::c_ushort;
pub type int32 = ::std::os::raw::c_int;
pub type uint32 = ::std::os::raw::c_uint;
pub type int64 = ::std::os::raw::c_longlong;
pub type uint64 = ::std::os::raw::c_ulonglong;
pub type lint64 = int64;
pub type ulint64 = uint64;
pub type intp = ::std::os::raw::c_longlong;
pub type uintp = ::std::os::raw::c_ulonglong;
pub type AppId_t = uint32;
pub const k_uAppIdInvalid: AppId_t = 0;
pub type DepotId_t = uint32;
pub const k_uDepotIdInvalid: DepotId_t = 0;
pub type RTime32 = uint32;
pub type SteamAPICall_t = uint64;
pub const k_uAPICallInvalid: SteamAPICall_t = 0;
pub type AccountID_t = uint32;
pub const k_uAccountIdInvalid: AccountID_t = 0;
pub type PartyBeaconID_t = uint64;
pub const k_ulPartyBeaconIdInvalid: PartyBeaconID_t = 0;
pub const ESteamIPType_k_ESteamIPTypeIPv4: ESteamIPType = 0;
pub const ESteamIPType_k_ESteamIPTypeIPv6: ESteamIPType = 1;
pub type ESteamIPType = ::std::os::raw::c_int;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamIPAddress_t {
    pub __bindgen_anon_1: SteamIPAddress_t__bindgen_ty_1,
    pub m_eType: ESteamIPType,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union SteamIPAddress_t__bindgen_ty_1 {
    pub m_unIPv4: uint32,
    pub m_rgubIPv6: [uint8; 16usize],
    pub m_ipv6Qword: [uint64; 2usize],
}
#[test]
fn bindgen_test_layout_SteamIPAddress_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<SteamIPAddress_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamIPAddress_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(SteamIPAddress_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamIPAddress_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamIPAddress_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unIPv4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamIPAddress_t__bindgen_ty_1),
            "::",
            stringify!(m_unIPv4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgubIPv6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamIPAddress_t__bindgen_ty_1),
            "::",
            stringify!(m_rgubIPv6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ipv6Qword) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamIPAddress_t__bindgen_ty_1),
            "::",
            stringify!(m_ipv6Qword)
        )
    );
}
#[test]
fn bindgen_test_layout_SteamIPAddress_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamIPAddress_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamIPAddress_t>(),
        20usize,
        concat!("Size of: ", stringify!(SteamIPAddress_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamIPAddress_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamIPAddress_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamIPAddress_t),
            "::",
            stringify!(m_eType)
        )
    );
}
pub const EUniverse_k_EUniverseInvalid: EUniverse = 0;
pub const EUniverse_k_EUniversePublic: EUniverse = 1;
pub const EUniverse_k_EUniverseBeta: EUniverse = 2;
pub const EUniverse_k_EUniverseInternal: EUniverse = 3;
pub const EUniverse_k_EUniverseDev: EUniverse = 4;
pub const EUniverse_k_EUniverseMax: EUniverse = 5;
pub type EUniverse = ::std::os::raw::c_int;
pub const EResult_k_EResultNone: EResult = 0;
pub const EResult_k_EResultOK: EResult = 1;
pub const EResult_k_EResultFail: EResult = 2;
pub const EResult_k_EResultNoConnection: EResult = 3;
pub const EResult_k_EResultInvalidPassword: EResult = 5;
pub const EResult_k_EResultLoggedInElsewhere: EResult = 6;
pub const EResult_k_EResultInvalidProtocolVer: EResult = 7;
pub const EResult_k_EResultInvalidParam: EResult = 8;
pub const EResult_k_EResultFileNotFound: EResult = 9;
pub const EResult_k_EResultBusy: EResult = 10;
pub const EResult_k_EResultInvalidState: EResult = 11;
pub const EResult_k_EResultInvalidName: EResult = 12;
pub const EResult_k_EResultInvalidEmail: EResult = 13;
pub const EResult_k_EResultDuplicateName: EResult = 14;
pub const EResult_k_EResultAccessDenied: EResult = 15;
pub const EResult_k_EResultTimeout: EResult = 16;
pub const EResult_k_EResultBanned: EResult = 17;
pub const EResult_k_EResultAccountNotFound: EResult = 18;
pub const EResult_k_EResultInvalidSteamID: EResult = 19;
pub const EResult_k_EResultServiceUnavailable: EResult = 20;
pub const EResult_k_EResultNotLoggedOn: EResult = 21;
pub const EResult_k_EResultPending: EResult = 22;
pub const EResult_k_EResultEncryptionFailure: EResult = 23;
pub const EResult_k_EResultInsufficientPrivilege: EResult = 24;
pub const EResult_k_EResultLimitExceeded: EResult = 25;
pub const EResult_k_EResultRevoked: EResult = 26;
pub const EResult_k_EResultExpired: EResult = 27;
pub const EResult_k_EResultAlreadyRedeemed: EResult = 28;
pub const EResult_k_EResultDuplicateRequest: EResult = 29;
pub const EResult_k_EResultAlreadyOwned: EResult = 30;
pub const EResult_k_EResultIPNotFound: EResult = 31;
pub const EResult_k_EResultPersistFailed: EResult = 32;
pub const EResult_k_EResultLockingFailed: EResult = 33;
pub const EResult_k_EResultLogonSessionReplaced: EResult = 34;
pub const EResult_k_EResultConnectFailed: EResult = 35;
pub const EResult_k_EResultHandshakeFailed: EResult = 36;
pub const EResult_k_EResultIOFailure: EResult = 37;
pub const EResult_k_EResultRemoteDisconnect: EResult = 38;
pub const EResult_k_EResultShoppingCartNotFound: EResult = 39;
pub const EResult_k_EResultBlocked: EResult = 40;
pub const EResult_k_EResultIgnored: EResult = 41;
pub const EResult_k_EResultNoMatch: EResult = 42;
pub const EResult_k_EResultAccountDisabled: EResult = 43;
pub const EResult_k_EResultServiceReadOnly: EResult = 44;
pub const EResult_k_EResultAccountNotFeatured: EResult = 45;
pub const EResult_k_EResultAdministratorOK: EResult = 46;
pub const EResult_k_EResultContentVersion: EResult = 47;
pub const EResult_k_EResultTryAnotherCM: EResult = 48;
pub const EResult_k_EResultPasswordRequiredToKickSession: EResult = 49;
pub const EResult_k_EResultAlreadyLoggedInElsewhere: EResult = 50;
pub const EResult_k_EResultSuspended: EResult = 51;
pub const EResult_k_EResultCancelled: EResult = 52;
pub const EResult_k_EResultDataCorruption: EResult = 53;
pub const EResult_k_EResultDiskFull: EResult = 54;
pub const EResult_k_EResultRemoteCallFailed: EResult = 55;
pub const EResult_k_EResultPasswordUnset: EResult = 56;
pub const EResult_k_EResultExternalAccountUnlinked: EResult = 57;
pub const EResult_k_EResultPSNTicketInvalid: EResult = 58;
pub const EResult_k_EResultExternalAccountAlreadyLinked: EResult = 59;
pub const EResult_k_EResultRemoteFileConflict: EResult = 60;
pub const EResult_k_EResultIllegalPassword: EResult = 61;
pub const EResult_k_EResultSameAsPreviousValue: EResult = 62;
pub const EResult_k_EResultAccountLogonDenied: EResult = 63;
pub const EResult_k_EResultCannotUseOldPassword: EResult = 64;
pub const EResult_k_EResultInvalidLoginAuthCode: EResult = 65;
pub const EResult_k_EResultAccountLogonDeniedNoMail: EResult = 66;
pub const EResult_k_EResultHardwareNotCapableOfIPT: EResult = 67;
pub const EResult_k_EResultIPTInitError: EResult = 68;
pub const EResult_k_EResultParentalControlRestricted: EResult = 69;
pub const EResult_k_EResultFacebookQueryError: EResult = 70;
pub const EResult_k_EResultExpiredLoginAuthCode: EResult = 71;
pub const EResult_k_EResultIPLoginRestrictionFailed: EResult = 72;
pub const EResult_k_EResultAccountLockedDown: EResult = 73;
pub const EResult_k_EResultAccountLogonDeniedVerifiedEmailRequired: EResult = 74;
pub const EResult_k_EResultNoMatchingURL: EResult = 75;
pub const EResult_k_EResultBadResponse: EResult = 76;
pub const EResult_k_EResultRequirePasswordReEntry: EResult = 77;
pub const EResult_k_EResultValueOutOfRange: EResult = 78;
pub const EResult_k_EResultUnexpectedError: EResult = 79;
pub const EResult_k_EResultDisabled: EResult = 80;
pub const EResult_k_EResultInvalidCEGSubmission: EResult = 81;
pub const EResult_k_EResultRestrictedDevice: EResult = 82;
pub const EResult_k_EResultRegionLocked: EResult = 83;
pub const EResult_k_EResultRateLimitExceeded: EResult = 84;
pub const EResult_k_EResultAccountLoginDeniedNeedTwoFactor: EResult = 85;
pub const EResult_k_EResultItemDeleted: EResult = 86;
pub const EResult_k_EResultAccountLoginDeniedThrottle: EResult = 87;
pub const EResult_k_EResultTwoFactorCodeMismatch: EResult = 88;
pub const EResult_k_EResultTwoFactorActivationCodeMismatch: EResult = 89;
pub const EResult_k_EResultAccountAssociatedToMultiplePartners: EResult = 90;
pub const EResult_k_EResultNotModified: EResult = 91;
pub const EResult_k_EResultNoMobileDevice: EResult = 92;
pub const EResult_k_EResultTimeNotSynced: EResult = 93;
pub const EResult_k_EResultSmsCodeFailed: EResult = 94;
pub const EResult_k_EResultAccountLimitExceeded: EResult = 95;
pub const EResult_k_EResultAccountActivityLimitExceeded: EResult = 96;
pub const EResult_k_EResultPhoneActivityLimitExceeded: EResult = 97;
pub const EResult_k_EResultRefundToWallet: EResult = 98;
pub const EResult_k_EResultEmailSendFailure: EResult = 99;
pub const EResult_k_EResultNotSettled: EResult = 100;
pub const EResult_k_EResultNeedCaptcha: EResult = 101;
pub const EResult_k_EResultGSLTDenied: EResult = 102;
pub const EResult_k_EResultGSOwnerDenied: EResult = 103;
pub const EResult_k_EResultInvalidItemType: EResult = 104;
pub const EResult_k_EResultIPBanned: EResult = 105;
pub const EResult_k_EResultGSLTExpired: EResult = 106;
pub const EResult_k_EResultInsufficientFunds: EResult = 107;
pub const EResult_k_EResultTooManyPending: EResult = 108;
pub const EResult_k_EResultNoSiteLicensesFound: EResult = 109;
pub const EResult_k_EResultWGNetworkSendExceeded: EResult = 110;
pub const EResult_k_EResultAccountNotFriends: EResult = 111;
pub const EResult_k_EResultLimitedUserAccount: EResult = 112;
pub const EResult_k_EResultCantRemoveItem: EResult = 113;
pub const EResult_k_EResultAccountDeleted: EResult = 114;
pub const EResult_k_EResultExistingUserCancelledLicense: EResult = 115;
pub const EResult_k_EResultCommunityCooldown: EResult = 116;
pub const EResult_k_EResultNoLauncherSpecified: EResult = 117;
pub const EResult_k_EResultMustAgreeToSSA: EResult = 118;
pub const EResult_k_EResultLauncherMigrated: EResult = 119;
pub const EResult_k_EResultSteamRealmMismatch: EResult = 120;
pub const EResult_k_EResultInvalidSignature: EResult = 121;
pub const EResult_k_EResultParseFailure: EResult = 122;
pub const EResult_k_EResultNoVerifiedPhone: EResult = 123;
pub const EResult_k_EResultInsufficientBattery: EResult = 124;
pub const EResult_k_EResultChargerRequired: EResult = 125;
pub const EResult_k_EResultCachedCredentialInvalid: EResult = 126;
pub const EResult_K_EResultPhoneNumberIsVOIP: EResult = 127;
pub const EResult_k_EResultNotSupported: EResult = 128;
pub const EResult_k_EResultFamilySizeLimitExceeded: EResult = 129;
pub type EResult = ::std::os::raw::c_int;
pub const EVoiceResult_k_EVoiceResultOK: EVoiceResult = 0;
pub const EVoiceResult_k_EVoiceResultNotInitialized: EVoiceResult = 1;
pub const EVoiceResult_k_EVoiceResultNotRecording: EVoiceResult = 2;
pub const EVoiceResult_k_EVoiceResultNoData: EVoiceResult = 3;
pub const EVoiceResult_k_EVoiceResultBufferTooSmall: EVoiceResult = 4;
pub const EVoiceResult_k_EVoiceResultDataCorrupted: EVoiceResult = 5;
pub const EVoiceResult_k_EVoiceResultRestricted: EVoiceResult = 6;
pub const EVoiceResult_k_EVoiceResultUnsupportedCodec: EVoiceResult = 7;
pub const EVoiceResult_k_EVoiceResultReceiverOutOfDate: EVoiceResult = 8;
pub const EVoiceResult_k_EVoiceResultReceiverDidNotAnswer: EVoiceResult = 9;
pub type EVoiceResult = ::std::os::raw::c_int;
pub const EDenyReason_k_EDenyInvalid: EDenyReason = 0;
pub const EDenyReason_k_EDenyInvalidVersion: EDenyReason = 1;
pub const EDenyReason_k_EDenyGeneric: EDenyReason = 2;
pub const EDenyReason_k_EDenyNotLoggedOn: EDenyReason = 3;
pub const EDenyReason_k_EDenyNoLicense: EDenyReason = 4;
pub const EDenyReason_k_EDenyCheater: EDenyReason = 5;
pub const EDenyReason_k_EDenyLoggedInElseWhere: EDenyReason = 6;
pub const EDenyReason_k_EDenyUnknownText: EDenyReason = 7;
pub const EDenyReason_k_EDenyIncompatibleAnticheat: EDenyReason = 8;
pub const EDenyReason_k_EDenyMemoryCorruption: EDenyReason = 9;
pub const EDenyReason_k_EDenyIncompatibleSoftware: EDenyReason = 10;
pub const EDenyReason_k_EDenySteamConnectionLost: EDenyReason = 11;
pub const EDenyReason_k_EDenySteamConnectionError: EDenyReason = 12;
pub const EDenyReason_k_EDenySteamResponseTimedOut: EDenyReason = 13;
pub const EDenyReason_k_EDenySteamValidationStalled: EDenyReason = 14;
pub const EDenyReason_k_EDenySteamOwnerLeftGuestUser: EDenyReason = 15;
pub type EDenyReason = ::std::os::raw::c_int;
pub type HAuthTicket = uint32;
pub const k_HAuthTicketInvalid: HAuthTicket = 0;
pub const EBeginAuthSessionResult_k_EBeginAuthSessionResultOK: EBeginAuthSessionResult = 0;
pub const EBeginAuthSessionResult_k_EBeginAuthSessionResultInvalidTicket: EBeginAuthSessionResult =
    1;
pub const EBeginAuthSessionResult_k_EBeginAuthSessionResultDuplicateRequest:
    EBeginAuthSessionResult = 2;
pub const EBeginAuthSessionResult_k_EBeginAuthSessionResultInvalidVersion: EBeginAuthSessionResult =
    3;
pub const EBeginAuthSessionResult_k_EBeginAuthSessionResultGameMismatch: EBeginAuthSessionResult =
    4;
pub const EBeginAuthSessionResult_k_EBeginAuthSessionResultExpiredTicket: EBeginAuthSessionResult =
    5;
pub type EBeginAuthSessionResult = ::std::os::raw::c_int;
pub const EAuthSessionResponse_k_EAuthSessionResponseOK: EAuthSessionResponse = 0;
pub const EAuthSessionResponse_k_EAuthSessionResponseUserNotConnectedToSteam: EAuthSessionResponse =
    1;
pub const EAuthSessionResponse_k_EAuthSessionResponseNoLicenseOrExpired: EAuthSessionResponse = 2;
pub const EAuthSessionResponse_k_EAuthSessionResponseVACBanned: EAuthSessionResponse = 3;
pub const EAuthSessionResponse_k_EAuthSessionResponseLoggedInElseWhere: EAuthSessionResponse = 4;
pub const EAuthSessionResponse_k_EAuthSessionResponseVACCheckTimedOut: EAuthSessionResponse = 5;
pub const EAuthSessionResponse_k_EAuthSessionResponseAuthTicketCanceled: EAuthSessionResponse = 6;
pub const EAuthSessionResponse_k_EAuthSessionResponseAuthTicketInvalidAlreadyUsed:
    EAuthSessionResponse = 7;
pub const EAuthSessionResponse_k_EAuthSessionResponseAuthTicketInvalid: EAuthSessionResponse = 8;
pub const EAuthSessionResponse_k_EAuthSessionResponsePublisherIssuedBan: EAuthSessionResponse = 9;
pub const EAuthSessionResponse_k_EAuthSessionResponseAuthTicketNetworkIdentityFailure:
    EAuthSessionResponse = 10;
pub type EAuthSessionResponse = ::std::os::raw::c_int;
pub const EUserHasLicenseForAppResult_k_EUserHasLicenseResultHasLicense:
    EUserHasLicenseForAppResult = 0;
pub const EUserHasLicenseForAppResult_k_EUserHasLicenseResultDoesNotHaveLicense:
    EUserHasLicenseForAppResult = 1;
pub const EUserHasLicenseForAppResult_k_EUserHasLicenseResultNoAuth: EUserHasLicenseForAppResult =
    2;
pub type EUserHasLicenseForAppResult = ::std::os::raw::c_int;
pub const EAccountType_k_EAccountTypeInvalid: EAccountType = 0;
pub const EAccountType_k_EAccountTypeIndividual: EAccountType = 1;
pub const EAccountType_k_EAccountTypeMultiseat: EAccountType = 2;
pub const EAccountType_k_EAccountTypeGameServer: EAccountType = 3;
pub const EAccountType_k_EAccountTypeAnonGameServer: EAccountType = 4;
pub const EAccountType_k_EAccountTypePending: EAccountType = 5;
pub const EAccountType_k_EAccountTypeContentServer: EAccountType = 6;
pub const EAccountType_k_EAccountTypeClan: EAccountType = 7;
pub const EAccountType_k_EAccountTypeChat: EAccountType = 8;
pub const EAccountType_k_EAccountTypeConsoleUser: EAccountType = 9;
pub const EAccountType_k_EAccountTypeAnonUser: EAccountType = 10;
pub const EAccountType_k_EAccountTypeMax: EAccountType = 11;
pub type EAccountType = ::std::os::raw::c_int;
pub const EChatEntryType_k_EChatEntryTypeInvalid: EChatEntryType = 0;
pub const EChatEntryType_k_EChatEntryTypeChatMsg: EChatEntryType = 1;
pub const EChatEntryType_k_EChatEntryTypeTyping: EChatEntryType = 2;
pub const EChatEntryType_k_EChatEntryTypeInviteGame: EChatEntryType = 3;
pub const EChatEntryType_k_EChatEntryTypeEmote: EChatEntryType = 4;
pub const EChatEntryType_k_EChatEntryTypeLeftConversation: EChatEntryType = 6;
pub const EChatEntryType_k_EChatEntryTypeEntered: EChatEntryType = 7;
pub const EChatEntryType_k_EChatEntryTypeWasKicked: EChatEntryType = 8;
pub const EChatEntryType_k_EChatEntryTypeWasBanned: EChatEntryType = 9;
pub const EChatEntryType_k_EChatEntryTypeDisconnected: EChatEntryType = 10;
pub const EChatEntryType_k_EChatEntryTypeHistoricalChat: EChatEntryType = 11;
pub const EChatEntryType_k_EChatEntryTypeLinkBlocked: EChatEntryType = 14;
pub type EChatEntryType = ::std::os::raw::c_int;
pub const EChatRoomEnterResponse_k_EChatRoomEnterResponseSuccess: EChatRoomEnterResponse = 1;
pub const EChatRoomEnterResponse_k_EChatRoomEnterResponseDoesntExist: EChatRoomEnterResponse = 2;
pub const EChatRoomEnterResponse_k_EChatRoomEnterResponseNotAllowed: EChatRoomEnterResponse = 3;
pub const EChatRoomEnterResponse_k_EChatRoomEnterResponseFull: EChatRoomEnterResponse = 4;
pub const EChatRoomEnterResponse_k_EChatRoomEnterResponseError: EChatRoomEnterResponse = 5;
pub const EChatRoomEnterResponse_k_EChatRoomEnterResponseBanned: EChatRoomEnterResponse = 6;
pub const EChatRoomEnterResponse_k_EChatRoomEnterResponseLimited: EChatRoomEnterResponse = 7;
pub const EChatRoomEnterResponse_k_EChatRoomEnterResponseClanDisabled: EChatRoomEnterResponse = 8;
pub const EChatRoomEnterResponse_k_EChatRoomEnterResponseCommunityBan: EChatRoomEnterResponse = 9;
pub const EChatRoomEnterResponse_k_EChatRoomEnterResponseMemberBlockedYou: EChatRoomEnterResponse =
    10;
pub const EChatRoomEnterResponse_k_EChatRoomEnterResponseYouBlockedMember: EChatRoomEnterResponse =
    11;
pub const EChatRoomEnterResponse_k_EChatRoomEnterResponseRatelimitExceeded: EChatRoomEnterResponse =
    15;
pub type EChatRoomEnterResponse = ::std::os::raw::c_int;
pub const k_unSteamAccountIDMask: ::std::os::raw::c_uint = 4294967295;
pub const k_unSteamAccountInstanceMask: ::std::os::raw::c_uint = 1048575;
pub const k_unSteamUserDefaultInstance: ::std::os::raw::c_uint = 1;
pub const EChatSteamIDInstanceFlags_k_EChatAccountInstanceMask: EChatSteamIDInstanceFlags = 4095;
pub const EChatSteamIDInstanceFlags_k_EChatInstanceFlagClan: EChatSteamIDInstanceFlags = 524288;
pub const EChatSteamIDInstanceFlags_k_EChatInstanceFlagLobby: EChatSteamIDInstanceFlags = 262144;
pub const EChatSteamIDInstanceFlags_k_EChatInstanceFlagMMSLobby: EChatSteamIDInstanceFlags = 131072;
pub type EChatSteamIDInstanceFlags = ::std::os::raw::c_int;
pub const ENotificationPosition_k_EPositionInvalid: ENotificationPosition = -1;
pub const ENotificationPosition_k_EPositionTopLeft: ENotificationPosition = 0;
pub const ENotificationPosition_k_EPositionTopRight: ENotificationPosition = 1;
pub const ENotificationPosition_k_EPositionBottomLeft: ENotificationPosition = 2;
pub const ENotificationPosition_k_EPositionBottomRight: ENotificationPosition = 3;
pub type ENotificationPosition = ::std::os::raw::c_int;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultNone: EBroadcastUploadResult = 0;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultOK: EBroadcastUploadResult = 1;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultInitFailed: EBroadcastUploadResult = 2;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultFrameFailed: EBroadcastUploadResult = 3;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultTimeout: EBroadcastUploadResult = 4;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultBandwidthExceeded: EBroadcastUploadResult =
    5;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultLowFPS: EBroadcastUploadResult = 6;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultMissingKeyFrames: EBroadcastUploadResult =
    7;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultNoConnection: EBroadcastUploadResult = 8;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultRelayFailed: EBroadcastUploadResult = 9;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultSettingsChanged: EBroadcastUploadResult =
    10;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultMissingAudio: EBroadcastUploadResult = 11;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultTooFarBehind: EBroadcastUploadResult = 12;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultTranscodeBehind: EBroadcastUploadResult =
    13;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultNotAllowedToPlay: EBroadcastUploadResult =
    14;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultBusy: EBroadcastUploadResult = 15;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultBanned: EBroadcastUploadResult = 16;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultAlreadyActive: EBroadcastUploadResult = 17;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultForcedOff: EBroadcastUploadResult = 18;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultAudioBehind: EBroadcastUploadResult = 19;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultShutdown: EBroadcastUploadResult = 20;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultDisconnect: EBroadcastUploadResult = 21;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultVideoInitFailed: EBroadcastUploadResult =
    22;
pub const EBroadcastUploadResult_k_EBroadcastUploadResultAudioInitFailed: EBroadcastUploadResult =
    23;
pub type EBroadcastUploadResult = ::std::os::raw::c_int;
pub const EMarketNotAllowedReasonFlags_k_EMarketNotAllowedReason_None:
    EMarketNotAllowedReasonFlags = 0;
pub const EMarketNotAllowedReasonFlags_k_EMarketNotAllowedReason_TemporaryFailure:
    EMarketNotAllowedReasonFlags = 1;
pub const EMarketNotAllowedReasonFlags_k_EMarketNotAllowedReason_AccountDisabled:
    EMarketNotAllowedReasonFlags = 2;
pub const EMarketNotAllowedReasonFlags_k_EMarketNotAllowedReason_AccountLockedDown:
    EMarketNotAllowedReasonFlags = 4;
pub const EMarketNotAllowedReasonFlags_k_EMarketNotAllowedReason_AccountLimited:
    EMarketNotAllowedReasonFlags = 8;
pub const EMarketNotAllowedReasonFlags_k_EMarketNotAllowedReason_TradeBanned:
    EMarketNotAllowedReasonFlags = 16;
pub const EMarketNotAllowedReasonFlags_k_EMarketNotAllowedReason_AccountNotTrusted:
    EMarketNotAllowedReasonFlags = 32;
pub const EMarketNotAllowedReasonFlags_k_EMarketNotAllowedReason_SteamGuardNotEnabled:
    EMarketNotAllowedReasonFlags = 64;
pub const EMarketNotAllowedReasonFlags_k_EMarketNotAllowedReason_SteamGuardOnlyRecentlyEnabled:
    EMarketNotAllowedReasonFlags = 128;
pub const EMarketNotAllowedReasonFlags_k_EMarketNotAllowedReason_RecentPasswordReset:
    EMarketNotAllowedReasonFlags = 256;
pub const EMarketNotAllowedReasonFlags_k_EMarketNotAllowedReason_NewPaymentMethod:
    EMarketNotAllowedReasonFlags = 512;
pub const EMarketNotAllowedReasonFlags_k_EMarketNotAllowedReason_InvalidCookie:
    EMarketNotAllowedReasonFlags = 1024;
pub const EMarketNotAllowedReasonFlags_k_EMarketNotAllowedReason_UsingNewDevice:
    EMarketNotAllowedReasonFlags = 2048;
pub const EMarketNotAllowedReasonFlags_k_EMarketNotAllowedReason_RecentSelfRefund:
    EMarketNotAllowedReasonFlags = 4096;
pub const EMarketNotAllowedReasonFlags_k_EMarketNotAllowedReason_NewPaymentMethodCannotBeVerified : EMarketNotAllowedReasonFlags = 8192 ;
pub const EMarketNotAllowedReasonFlags_k_EMarketNotAllowedReason_NoRecentPurchases:
    EMarketNotAllowedReasonFlags = 16384;
pub const EMarketNotAllowedReasonFlags_k_EMarketNotAllowedReason_AcceptedWalletGift:
    EMarketNotAllowedReasonFlags = 32768;
pub type EMarketNotAllowedReasonFlags = ::std::os::raw::c_int;
pub const EDurationControlProgress_k_EDurationControlProgress_Full: EDurationControlProgress = 0;
pub const EDurationControlProgress_k_EDurationControlProgress_Half: EDurationControlProgress = 1;
pub const EDurationControlProgress_k_EDurationControlProgress_None: EDurationControlProgress = 2;
pub const EDurationControlProgress_k_EDurationControl_ExitSoon_3h: EDurationControlProgress = 3;
pub const EDurationControlProgress_k_EDurationControl_ExitSoon_5h: EDurationControlProgress = 4;
pub const EDurationControlProgress_k_EDurationControl_ExitSoon_Night: EDurationControlProgress = 5;
pub type EDurationControlProgress = ::std::os::raw::c_int;
pub const EDurationControlNotification_k_EDurationControlNotification_None:
    EDurationControlNotification = 0;
pub const EDurationControlNotification_k_EDurationControlNotification_1Hour:
    EDurationControlNotification = 1;
pub const EDurationControlNotification_k_EDurationControlNotification_3Hours:
    EDurationControlNotification = 2;
pub const EDurationControlNotification_k_EDurationControlNotification_HalfProgress:
    EDurationControlNotification = 3;
pub const EDurationControlNotification_k_EDurationControlNotification_NoProgress:
    EDurationControlNotification = 4;
pub const EDurationControlNotification_k_EDurationControlNotification_ExitSoon_3h:
    EDurationControlNotification = 5;
pub const EDurationControlNotification_k_EDurationControlNotification_ExitSoon_5h:
    EDurationControlNotification = 6;
pub const EDurationControlNotification_k_EDurationControlNotification_ExitSoon_Night:
    EDurationControlNotification = 7;
pub type EDurationControlNotification = ::std::os::raw::c_int;
pub const EDurationControlOnlineState_k_EDurationControlOnlineState_Invalid:
    EDurationControlOnlineState = 0;
pub const EDurationControlOnlineState_k_EDurationControlOnlineState_Offline:
    EDurationControlOnlineState = 1;
pub const EDurationControlOnlineState_k_EDurationControlOnlineState_Online:
    EDurationControlOnlineState = 2;
pub const EDurationControlOnlineState_k_EDurationControlOnlineState_OnlineHighPri:
    EDurationControlOnlineState = 3;
pub type EDurationControlOnlineState = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CSteamID {
    pub m_steamid: CSteamID_SteamID_t,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union CSteamID_SteamID_t {
    pub m_comp: CSteamID_SteamID_t_SteamIDComponent_t,
    pub m_unAll64Bits: uint64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CSteamID_SteamID_t_SteamIDComponent_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_CSteamID_SteamID_t_SteamIDComponent_t() {
    assert_eq!(
        ::std::mem::size_of::<CSteamID_SteamID_t_SteamIDComponent_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CSteamID_SteamID_t_SteamIDComponent_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CSteamID_SteamID_t_SteamIDComponent_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(CSteamID_SteamID_t_SteamIDComponent_t)
        )
    );
}
impl CSteamID_SteamID_t_SteamIDComponent_t {
    #[inline]
    pub fn m_unAccountID(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_m_unAccountID(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn m_unAccountInstance(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_m_unAccountInstance(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn m_EAccountType(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_m_EAccountType(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn m_EUniverse(&self) -> EUniverse {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_m_EUniverse(&mut self, val: EUniverse) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        m_unAccountID: uint32,
        m_unAccountInstance: ::std::os::raw::c_uint,
        m_EAccountType: ::std::os::raw::c_uint,
        m_EUniverse: EUniverse,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let m_unAccountID: u32 = unsafe { ::std::mem::transmute(m_unAccountID) };
            m_unAccountID as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let m_unAccountInstance: u32 = unsafe { ::std::mem::transmute(m_unAccountInstance) };
            m_unAccountInstance as u64
        });
        __bindgen_bitfield_unit.set(52usize, 4u8, {
            let m_EAccountType: u32 = unsafe { ::std::mem::transmute(m_EAccountType) };
            m_EAccountType as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let m_EUniverse: u32 = unsafe { ::std::mem::transmute(m_EUniverse) };
            m_EUniverse as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_CSteamID_SteamID_t() {
    const UNINIT: ::std::mem::MaybeUninit<CSteamID_SteamID_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CSteamID_SteamID_t>(),
        8usize,
        concat!("Size of: ", stringify!(CSteamID_SteamID_t))
    );
    assert_eq!(
        ::std::mem::align_of::<CSteamID_SteamID_t>(),
        1usize,
        concat!("Alignment of ", stringify!(CSteamID_SteamID_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_comp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamID_SteamID_t),
            "::",
            stringify!(m_comp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAll64Bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamID_SteamID_t),
            "::",
            stringify!(m_unAll64Bits)
        )
    );
}
#[test]
fn bindgen_test_layout_CSteamID() {
    const UNINIT: ::std::mem::MaybeUninit<CSteamID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CSteamID>(),
        8usize,
        concat!("Size of: ", stringify!(CSteamID))
    );
    assert_eq!(
        ::std::mem::align_of::<CSteamID>(),
        1usize,
        concat!("Alignment of ", stringify!(CSteamID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamID),
            "::",
            stringify!(m_steamid)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?Render@CSteamID@@QEBAPEBDXZ"]
    pub fn CSteamID_Render(this: *const CSteamID) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?Render@CSteamID@@SAPEBD_K@Z"]
    pub fn CSteamID_Render1(ulSteamID: uint64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?SetFromString@CSteamID@@QEAAXPEBDW4EUniverse@@@Z"]
    pub fn CSteamID_SetFromString(
        this: *mut CSteamID,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    );
}
extern "C" {
    #[link_name = "\u{1}?SetFromStringStrict@CSteamID@@QEAA_NPEBDW4EUniverse@@@Z"]
    pub fn CSteamID_SetFromStringStrict(
        this: *mut CSteamID,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?BValidExternalSteamID@CSteamID@@QEBA_NXZ"]
    pub fn CSteamID_BValidExternalSteamID(this: *const CSteamID) -> bool;
}
extern "C" {
    #[link_name = "\u{1}??0CSteamID@@QEAA@PEBDW4EUniverse@@@Z"]
    pub fn CSteamID_CSteamID(
        this: *mut CSteamID,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    );
}
impl CSteamID {
    #[inline]
    pub unsafe fn Render(&self) -> *const ::std::os::raw::c_char {
        CSteamID_Render(self)
    }
    #[inline]
    pub unsafe fn Render1(ulSteamID: uint64) -> *const ::std::os::raw::c_char {
        CSteamID_Render1(ulSteamID)
    }
    #[inline]
    pub unsafe fn SetFromString(
        &mut self,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    ) {
        CSteamID_SetFromString(self, pchSteamID, eDefaultUniverse)
    }
    #[inline]
    pub unsafe fn SetFromStringStrict(
        &mut self,
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    ) -> bool {
        CSteamID_SetFromStringStrict(self, pchSteamID, eDefaultUniverse)
    }
    #[inline]
    pub unsafe fn BValidExternalSteamID(&self) -> bool {
        CSteamID_BValidExternalSteamID(self)
    }
    #[inline]
    pub unsafe fn new(
        pchSteamID: *const ::std::os::raw::c_char,
        eDefaultUniverse: EUniverse,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        CSteamID_CSteamID(__bindgen_tmp.as_mut_ptr(), pchSteamID, eDefaultUniverse);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CGameID {
    pub __bindgen_anon_1: CGameID__bindgen_ty_1,
}
pub const CGameID_EGameIDType_k_EGameIDTypeApp: CGameID_EGameIDType = 0;
pub const CGameID_EGameIDType_k_EGameIDTypeGameMod: CGameID_EGameIDType = 1;
pub const CGameID_EGameIDType_k_EGameIDTypeShortcut: CGameID_EGameIDType = 2;
pub const CGameID_EGameIDType_k_EGameIDTypeP2P: CGameID_EGameIDType = 3;
pub type CGameID_EGameIDType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CGameID_GameID_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_CGameID_GameID_t() {
    assert_eq!(
        ::std::mem::size_of::<CGameID_GameID_t>(),
        8usize,
        concat!("Size of: ", stringify!(CGameID_GameID_t))
    );
    assert_eq!(
        ::std::mem::align_of::<CGameID_GameID_t>(),
        1usize,
        concat!("Alignment of ", stringify!(CGameID_GameID_t))
    );
}
impl CGameID_GameID_t {
    #[inline]
    pub fn m_nAppID(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_m_nAppID(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn m_nType(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_m_nType(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn m_nModID(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_m_nModID(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        m_nAppID: ::std::os::raw::c_uint,
        m_nType: ::std::os::raw::c_uint,
        m_nModID: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let m_nAppID: u32 = unsafe { ::std::mem::transmute(m_nAppID) };
            m_nAppID as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let m_nType: u32 = unsafe { ::std::mem::transmute(m_nType) };
            m_nType as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let m_nModID: u32 = unsafe { ::std::mem::transmute(m_nModID) };
            m_nModID as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union CGameID__bindgen_ty_1 {
    pub m_ulGameID: uint64,
    pub m_gameID: CGameID_GameID_t,
}
#[test]
fn bindgen_test_layout_CGameID__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CGameID__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CGameID__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(CGameID__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CGameID__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(CGameID__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulGameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CGameID__bindgen_ty_1),
            "::",
            stringify!(m_ulGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_gameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CGameID__bindgen_ty_1),
            "::",
            stringify!(m_gameID)
        )
    );
}
#[test]
fn bindgen_test_layout_CGameID() {
    assert_eq!(
        ::std::mem::size_of::<CGameID>(),
        8usize,
        concat!("Size of: ", stringify!(CGameID))
    );
    assert_eq!(
        ::std::mem::align_of::<CGameID>(),
        1usize,
        concat!("Alignment of ", stringify!(CGameID))
    );
}
extern "C" {
    #[link_name = "\u{1}?Render@CGameID@@QEBAPEBDXZ"]
    pub fn CGameID_Render(this: *const CGameID) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?Render@CGameID@@SAPEBD_K@Z"]
    pub fn CGameID_Render1(ulGameID: uint64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}??0CGameID@@QEAA@PEBD@Z"]
    pub fn CGameID_CGameID(this: *mut CGameID, pchGameID: *const ::std::os::raw::c_char);
}
impl CGameID {
    #[inline]
    pub unsafe fn Render(&self) -> *const ::std::os::raw::c_char {
        CGameID_Render(self)
    }
    #[inline]
    pub unsafe fn Render1(ulGameID: uint64) -> *const ::std::os::raw::c_char {
        CGameID_Render1(ulGameID)
    }
    #[inline]
    pub unsafe fn new(pchGameID: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        CGameID_CGameID(__bindgen_tmp.as_mut_ptr(), pchGameID);
        __bindgen_tmp.assume_init()
    }
}
pub const k_cchGameExtraInfoMax: ::std::os::raw::c_int = 64;
pub type PFNPreMinidumpCallback =
    ::std::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void)>;
pub const EGameSearchErrorCode_t_k_EGameSearchErrorCode_OK: EGameSearchErrorCode_t = 1;
pub const EGameSearchErrorCode_t_k_EGameSearchErrorCode_Failed_Search_Already_In_Progress:
    EGameSearchErrorCode_t = 2;
pub const EGameSearchErrorCode_t_k_EGameSearchErrorCode_Failed_No_Search_In_Progress:
    EGameSearchErrorCode_t = 3;
pub const EGameSearchErrorCode_t_k_EGameSearchErrorCode_Failed_Not_Lobby_Leader:
    EGameSearchErrorCode_t = 4;
pub const EGameSearchErrorCode_t_k_EGameSearchErrorCode_Failed_No_Host_Available:
    EGameSearchErrorCode_t = 5;
pub const EGameSearchErrorCode_t_k_EGameSearchErrorCode_Failed_Search_Params_Invalid:
    EGameSearchErrorCode_t = 6;
pub const EGameSearchErrorCode_t_k_EGameSearchErrorCode_Failed_Offline: EGameSearchErrorCode_t = 7;
pub const EGameSearchErrorCode_t_k_EGameSearchErrorCode_Failed_NotAuthorized:
    EGameSearchErrorCode_t = 8;
pub const EGameSearchErrorCode_t_k_EGameSearchErrorCode_Failed_Unknown_Error:
    EGameSearchErrorCode_t = 9;
pub type EGameSearchErrorCode_t = ::std::os::raw::c_int;
pub const EPlayerResult_t_k_EPlayerResultFailedToConnect: EPlayerResult_t = 1;
pub const EPlayerResult_t_k_EPlayerResultAbandoned: EPlayerResult_t = 2;
pub const EPlayerResult_t_k_EPlayerResultKicked: EPlayerResult_t = 3;
pub const EPlayerResult_t_k_EPlayerResultIncomplete: EPlayerResult_t = 4;
pub const EPlayerResult_t_k_EPlayerResultCompleted: EPlayerResult_t = 5;
pub type EPlayerResult_t = ::std::os::raw::c_int;
pub const ESteamIPv6ConnectivityProtocol_k_ESteamIPv6ConnectivityProtocol_Invalid:
    ESteamIPv6ConnectivityProtocol = 0;
pub const ESteamIPv6ConnectivityProtocol_k_ESteamIPv6ConnectivityProtocol_HTTP:
    ESteamIPv6ConnectivityProtocol = 1;
pub const ESteamIPv6ConnectivityProtocol_k_ESteamIPv6ConnectivityProtocol_UDP:
    ESteamIPv6ConnectivityProtocol = 2;
pub type ESteamIPv6ConnectivityProtocol = ::std::os::raw::c_int;
pub const ESteamIPv6ConnectivityState_k_ESteamIPv6ConnectivityState_Unknown:
    ESteamIPv6ConnectivityState = 0;
pub const ESteamIPv6ConnectivityState_k_ESteamIPv6ConnectivityState_Good:
    ESteamIPv6ConnectivityState = 1;
pub const ESteamIPv6ConnectivityState_k_ESteamIPv6ConnectivityState_Bad:
    ESteamIPv6ConnectivityState = 2;
pub type ESteamIPv6ConnectivityState = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValvePackingSentinel_t {
    pub m_u32: uint32,
    pub m_u64: uint64,
    pub m_u16: uint16,
    pub m_d: f64,
}
#[test]
fn bindgen_test_layout_ValvePackingSentinel_t() {
    const UNINIT: ::std::mem::MaybeUninit<ValvePackingSentinel_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ValvePackingSentinel_t>(),
        32usize,
        concat!("Size of: ", stringify!(ValvePackingSentinel_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ValvePackingSentinel_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ValvePackingSentinel_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_u32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ValvePackingSentinel_t),
            "::",
            stringify!(m_u32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_u64) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ValvePackingSentinel_t),
            "::",
            stringify!(m_u64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_u16) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ValvePackingSentinel_t),
            "::",
            stringify!(m_u16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_d) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ValvePackingSentinel_t),
            "::",
            stringify!(m_d)
        )
    );
}
pub type compile_time_assert_type = [::std::os::raw::c_char; 1usize];
pub type HSteamPipe = int32;
pub type HSteamUser = int32;
pub const k_cchMaxSteamErrMsg: ::std::os::raw::c_int = 1024;
pub type SteamErrMsg = [::std::os::raw::c_char; 1024usize];
pub type SteamAPIWarningMessageHook_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char),
>;
pub type SteamAPI_CheckCallbackRegistered_t =
    ::std::option::Option<unsafe extern "C" fn(iCallbackNum: ::std::os::raw::c_int) -> uint32>;
extern "C" {
    pub fn SteamAPI_RunCallbacks();
}
extern "C" {
    pub fn SteamGameServer_RunCallbacks();
}
#[repr(C)]
pub struct CCallbackBase__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCallbackBase {
    pub vtable_: *const CCallbackBase__bindgen_vtable,
    pub m_nCallbackFlags: uint8,
    pub m_iCallback: ::std::os::raw::c_int,
}
pub const CCallbackBase_k_ECallbackFlagsRegistered: CCallbackBase__bindgen_ty_1 = 1;
pub const CCallbackBase_k_ECallbackFlagsGameServer: CCallbackBase__bindgen_ty_1 = 2;
pub type CCallbackBase__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_CCallbackBase() {
    const UNINIT: ::std::mem::MaybeUninit<CCallbackBase> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CCallbackBase>(),
        16usize,
        concat!("Size of: ", stringify!(CCallbackBase))
    );
    assert_eq!(
        ::std::mem::align_of::<CCallbackBase>(),
        8usize,
        concat!("Alignment of ", stringify!(CCallbackBase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCallbackFlags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CCallbackBase),
            "::",
            stringify!(m_nCallbackFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iCallback) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CCallbackBase),
            "::",
            stringify!(m_iCallback)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct CCallResult<T, P> {
    pub _base: CCallbackBase,
    pub m_hAPICall: SteamAPICall_t,
    pub m_pObj: *mut T,
    pub m_Func: CCallResult_func_t<P>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<P>>,
}
pub type CCallResult_func_t<P> =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut P, arg2: bool)>;
pub type CCallback_func_t<P> = ::std::option::Option<unsafe extern "C" fn(arg1: *mut P)>;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_va_list_is_reference {
    pub _address: u8,
}
pub const __vcrt_va_list_is_reference___the_value: __vcrt_va_list_is_reference__bindgen_ty_1 =
    false;
pub type __vcrt_va_list_is_reference__bindgen_ty_1 = bool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_assert_va_start_is_not_reference {
    pub _address: u8,
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const u16,
        _FunctionName: *const u16,
        _FileName: *const u16,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_data_public> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_pointers> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    const UNINIT: ::std::mem::MaybeUninit<_Mbstatet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Wchar) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Byte) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._State) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn memchr(
        _Buf: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strchr(
        _Str: *const ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        _Str: *const ::std::os::raw::c_char,
        _Ch: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        _Str: *const ::std::os::raw::c_char,
        _SubStr: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wcschr(_Str: *const u16, _Ch: u16) -> *const u16;
}
extern "C" {
    pub fn wcsrchr(_Str: *const u16, _Ch: u16) -> *const u16;
}
extern "C" {
    pub fn wcsstr(_Str: *const u16, _SubStr: *const u16) -> *const u16;
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscat_s(_Destination: *mut u16, _SizeInWords: rsize_t, _Source: *const u16) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(_Destination: *mut u16, _SizeInWords: rsize_t, _Source: *const u16) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut u16,
        _SizeInWords: rsize_t,
        _Source: *const u16,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut u16,
        _SizeInWords: rsize_t,
        _Source: *const u16,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(_String: *mut u16, _Delimiter: *const u16, _Context: *mut *mut u16)
        -> *mut u16;
}
extern "C" {
    pub fn _wcsdup(_String: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcscat(_Destination: *mut u16, _Source: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcscmp(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut u16, _Source: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcscspn(_String: *const u16, _Control: *const u16) -> usize;
}
extern "C" {
    pub fn wcslen(_String: *const u16) -> usize;
}
extern "C" {
    pub fn wcsnlen(_Source: *const u16, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn wcsncat(_Destination: *mut u16, _Source: *const u16, _Count: usize) -> *mut u16;
}
extern "C" {
    pub fn wcsncmp(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(_Destination: *mut u16, _Source: *const u16, _Count: usize) -> *mut u16;
}
extern "C" {
    pub fn wcspbrk(_String: *const u16, _Control: *const u16) -> *const u16;
}
extern "C" {
    pub fn wcsspn(_String: *const u16, _Control: *const u16) -> usize;
}
extern "C" {
    pub fn wcstok(_String: *mut u16, _Delimiter: *const u16, _Context: *mut *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: ::std::os::raw::c_int) -> *mut u16;
}
extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut u16,
        _SizeInWords: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const u16) -> *mut u16;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut u16,
        _SizeInWords: usize,
        _ErrorMessage: *const u16,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const u16,
        _String2: *const u16,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut u16,
        _SizeInWords: usize,
        _Value: u16,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut u16, _Value: u16, _MaxCount: usize) -> *mut u16;
}
extern "C" {
    pub fn _wcsrev(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut u16, _SizeInWords: usize, _Value: u16) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut u16, _Value: u16) -> *mut u16;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut u16, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut u16, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut u16, _Locale: _locale_t) -> *mut u16;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut u16, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut u16, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut u16, _Locale: _locale_t) -> *mut u16;
}
extern "C" {
    pub fn wcsxfrm(_Destination: *mut u16, _Source: *const u16, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut u16,
        _Source: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wcscoll(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _String1: *const u16,
        _String2: *const u16,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const u16,
        _String2: *const u16,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsdup(_String: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcsicmp(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut u16, _Value: u16, _MaxCount: usize) -> *mut u16;
}
extern "C" {
    pub fn wcsrev(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn wcsset(_String: *mut u16, _Value: u16) -> *mut u16;
}
extern "C" {
    pub fn wcslwr(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn wcsupr(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn wcsicoll(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strcat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn _strdup(_Source: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror(_ErrorMessage: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorMessage: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror(_ErrorMessage: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _strlwr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strlwr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strlwr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __strncnt(_String: *const ::std::os::raw::c_char, _Count: usize) -> usize;
}
extern "C" {
    pub fn strncpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _strnset_s(
        _String: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strnset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strset_s(
        _Destination: *mut ::std::os::raw::c_char,
        _DestinationSize: usize,
        _Value: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn strtok(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strupr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(_String: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrev(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_GetHSteamPipe() -> HSteamPipe;
}
extern "C" {
    pub fn SteamAPI_GetHSteamUser() -> HSteamUser;
}
extern "C" {
    pub fn SteamGameServer_GetHSteamPipe() -> HSteamPipe;
}
extern "C" {
    pub fn SteamGameServer_GetHSteamUser() -> HSteamUser;
}
extern "C" {
    pub fn SteamInternal_ContextInit(
        pContextInitData: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SteamInternal_CreateInterface(
        ver: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SteamInternal_FindOrCreateUserInterface(
        hSteamUser: HSteamUser,
        pszVersion: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SteamInternal_FindOrCreateGameServerInterface(
        hSteamUser: HSteamUser,
        pszVersion: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SteamAPI_RegisterCallback(
        pCallback: *mut CCallbackBase,
        iCallback: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_UnregisterCallback(pCallback: *mut CCallbackBase);
}
extern "C" {
    pub fn SteamAPI_RegisterCallResult(pCallback: *mut CCallbackBase, hAPICall: SteamAPICall_t);
}
extern "C" {
    pub fn SteamAPI_UnregisterCallResult(pCallback: *mut CCallbackBase, hAPICall: SteamAPICall_t);
}
#[doc = " Internal structure used in manual callback dispatch"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CallbackMsg_t {
    pub m_hSteamUser: HSteamUser,
    pub m_iCallback: ::std::os::raw::c_int,
    pub m_pubParam: *mut uint8,
    pub m_cubParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CallbackMsg_t() {
    const UNINIT: ::std::mem::MaybeUninit<CallbackMsg_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CallbackMsg_t>(),
        24usize,
        concat!("Size of: ", stringify!(CallbackMsg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<CallbackMsg_t>(),
        8usize,
        concat!("Alignment of ", stringify!(CallbackMsg_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hSteamUser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CallbackMsg_t),
            "::",
            stringify!(m_hSteamUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iCallback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CallbackMsg_t),
            "::",
            stringify!(m_iCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pubParam) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CallbackMsg_t),
            "::",
            stringify!(m_pubParam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cubParam) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CallbackMsg_t),
            "::",
            stringify!(m_cubParam)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamContentServer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamPS3OverlayRender {
    _unused: [u8; 0],
}
pub const k_iSteamUserCallbacks: _bindgen_ty_1 = 100;
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
pub const k_iSteamGameServerCallbacks: _bindgen_ty_2 = 200;
pub type _bindgen_ty_2 = ::std::os::raw::c_int;
pub const k_iSteamFriendsCallbacks: _bindgen_ty_3 = 300;
pub type _bindgen_ty_3 = ::std::os::raw::c_int;
pub const k_iSteamBillingCallbacks: _bindgen_ty_4 = 400;
pub type _bindgen_ty_4 = ::std::os::raw::c_int;
pub const k_iSteamMatchmakingCallbacks: _bindgen_ty_5 = 500;
pub type _bindgen_ty_5 = ::std::os::raw::c_int;
pub const k_iSteamContentServerCallbacks: _bindgen_ty_6 = 600;
pub type _bindgen_ty_6 = ::std::os::raw::c_int;
pub const k_iSteamUtilsCallbacks: _bindgen_ty_7 = 700;
pub type _bindgen_ty_7 = ::std::os::raw::c_int;
pub const k_iSteamAppsCallbacks: _bindgen_ty_8 = 1000;
pub type _bindgen_ty_8 = ::std::os::raw::c_int;
pub const k_iSteamUserStatsCallbacks: _bindgen_ty_9 = 1100;
pub type _bindgen_ty_9 = ::std::os::raw::c_int;
pub const k_iSteamNetworkingCallbacks: _bindgen_ty_10 = 1200;
pub type _bindgen_ty_10 = ::std::os::raw::c_int;
pub const k_iSteamNetworkingSocketsCallbacks: _bindgen_ty_11 = 1220;
pub type _bindgen_ty_11 = ::std::os::raw::c_int;
pub const k_iSteamNetworkingMessagesCallbacks: _bindgen_ty_12 = 1250;
pub type _bindgen_ty_12 = ::std::os::raw::c_int;
pub const k_iSteamNetworkingUtilsCallbacks: _bindgen_ty_13 = 1280;
pub type _bindgen_ty_13 = ::std::os::raw::c_int;
pub const k_iSteamRemoteStorageCallbacks: _bindgen_ty_14 = 1300;
pub type _bindgen_ty_14 = ::std::os::raw::c_int;
pub const k_iSteamGameServerItemsCallbacks: _bindgen_ty_15 = 1500;
pub type _bindgen_ty_15 = ::std::os::raw::c_int;
pub const k_iSteamGameCoordinatorCallbacks: _bindgen_ty_16 = 1700;
pub type _bindgen_ty_16 = ::std::os::raw::c_int;
pub const k_iSteamGameServerStatsCallbacks: _bindgen_ty_17 = 1800;
pub type _bindgen_ty_17 = ::std::os::raw::c_int;
pub const k_iSteam2AsyncCallbacks: _bindgen_ty_18 = 1900;
pub type _bindgen_ty_18 = ::std::os::raw::c_int;
pub const k_iSteamGameStatsCallbacks: _bindgen_ty_19 = 2000;
pub type _bindgen_ty_19 = ::std::os::raw::c_int;
pub const k_iSteamHTTPCallbacks: _bindgen_ty_20 = 2100;
pub type _bindgen_ty_20 = ::std::os::raw::c_int;
pub const k_iSteamScreenshotsCallbacks: _bindgen_ty_21 = 2300;
pub type _bindgen_ty_21 = ::std::os::raw::c_int;
pub const k_iSteamStreamLauncherCallbacks: _bindgen_ty_22 = 2600;
pub type _bindgen_ty_22 = ::std::os::raw::c_int;
pub const k_iSteamControllerCallbacks: _bindgen_ty_23 = 2800;
pub type _bindgen_ty_23 = ::std::os::raw::c_int;
pub const k_iSteamUGCCallbacks: _bindgen_ty_24 = 3400;
pub type _bindgen_ty_24 = ::std::os::raw::c_int;
pub const k_iSteamStreamClientCallbacks: _bindgen_ty_25 = 3500;
pub type _bindgen_ty_25 = ::std::os::raw::c_int;
pub const k_iSteamMusicCallbacks: _bindgen_ty_26 = 4000;
pub type _bindgen_ty_26 = ::std::os::raw::c_int;
pub const k_iSteamMusicRemoteCallbacks: _bindgen_ty_27 = 4100;
pub type _bindgen_ty_27 = ::std::os::raw::c_int;
pub const k_iSteamGameNotificationCallbacks: _bindgen_ty_28 = 4400;
pub type _bindgen_ty_28 = ::std::os::raw::c_int;
pub const k_iSteamHTMLSurfaceCallbacks: _bindgen_ty_29 = 4500;
pub type _bindgen_ty_29 = ::std::os::raw::c_int;
pub const k_iSteamVideoCallbacks: _bindgen_ty_30 = 4600;
pub type _bindgen_ty_30 = ::std::os::raw::c_int;
pub const k_iSteamInventoryCallbacks: _bindgen_ty_31 = 4700;
pub type _bindgen_ty_31 = ::std::os::raw::c_int;
pub const k_ISteamParentalSettingsCallbacks: _bindgen_ty_32 = 5000;
pub type _bindgen_ty_32 = ::std::os::raw::c_int;
pub const k_iSteamGameSearchCallbacks: _bindgen_ty_33 = 5200;
pub type _bindgen_ty_33 = ::std::os::raw::c_int;
pub const k_iSteamPartiesCallbacks: _bindgen_ty_34 = 5300;
pub type _bindgen_ty_34 = ::std::os::raw::c_int;
pub const k_iSteamSTARCallbacks: _bindgen_ty_35 = 5500;
pub type _bindgen_ty_35 = ::std::os::raw::c_int;
pub const k_iSteamRemotePlayCallbacks: _bindgen_ty_36 = 5700;
pub type _bindgen_ty_36 = ::std::os::raw::c_int;
pub const k_iSteamChatCallbacks: _bindgen_ty_37 = 5900;
pub type _bindgen_ty_37 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CSteamAPIContext {
    pub m_pSteamClient: *mut ISteamClient,
    pub m_pSteamUser: *mut ISteamUser,
    pub m_pSteamFriends: *mut ISteamFriends,
    pub m_pSteamUtils: *mut ISteamUtils,
    pub m_pSteamMatchmaking: *mut ISteamMatchmaking,
    pub m_pSteamGameSearch: *mut ISteamGameSearch,
    pub m_pSteamUserStats: *mut ISteamUserStats,
    pub m_pSteamApps: *mut ISteamApps,
    pub m_pSteamMatchmakingServers: *mut ISteamMatchmakingServers,
    pub m_pSteamNetworking: *mut ISteamNetworking,
    pub m_pSteamRemoteStorage: *mut ISteamRemoteStorage,
    pub m_pSteamScreenshots: *mut ISteamScreenshots,
    pub m_pSteamHTTP: *mut ISteamHTTP,
    pub m_pController: *mut ISteamController,
    pub m_pSteamUGC: *mut ISteamUGC,
    pub m_pSteamMusic: *mut ISteamMusic,
    pub m_pSteamMusicRemote: *mut ISteamMusicRemote,
    pub m_pSteamHTMLSurface: *mut ISteamHTMLSurface,
    pub m_pSteamInventory: *mut ISteamInventory,
    pub m_pSteamVideo: *mut ISteamVideo,
    pub m_pSteamParentalSettings: *mut ISteamParentalSettings,
    pub m_pSteamInput: *mut ISteamInput,
}
#[test]
fn bindgen_test_layout_CSteamAPIContext() {
    const UNINIT: ::std::mem::MaybeUninit<CSteamAPIContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CSteamAPIContext>(),
        176usize,
        concat!("Size of: ", stringify!(CSteamAPIContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CSteamAPIContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CSteamAPIContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamClient) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamClient)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamUser) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamFriends) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamFriends)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamUtils) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamUtils)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamMatchmaking) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamMatchmaking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamGameSearch) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamGameSearch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamUserStats) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamUserStats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamApps) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamApps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamMatchmakingServers) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamMatchmakingServers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamNetworking) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamNetworking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamRemoteStorage) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamRemoteStorage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamScreenshots) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamScreenshots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamHTTP) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamHTTP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pController) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pController)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamUGC) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamUGC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamMusic) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamMusic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamMusicRemote) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamMusicRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamHTMLSurface) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamHTMLSurface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamInventory) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamInventory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamVideo) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamVideo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamParentalSettings) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamParentalSettings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamInput) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamAPIContext),
            "::",
            stringify!(m_pSteamInput)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CSteamGameServerAPIContext {
    pub m_pSteamClient: *mut ISteamClient,
    pub m_pSteamGameServer: *mut ISteamGameServer,
    pub m_pSteamGameServerUtils: *mut ISteamUtils,
    pub m_pSteamGameServerNetworking: *mut ISteamNetworking,
    pub m_pSteamGameServerStats: *mut ISteamGameServerStats,
    pub m_pSteamHTTP: *mut ISteamHTTP,
    pub m_pSteamInventory: *mut ISteamInventory,
    pub m_pSteamUGC: *mut ISteamUGC,
}
#[test]
fn bindgen_test_layout_CSteamGameServerAPIContext() {
    const UNINIT: ::std::mem::MaybeUninit<CSteamGameServerAPIContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CSteamGameServerAPIContext>(),
        64usize,
        concat!("Size of: ", stringify!(CSteamGameServerAPIContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CSteamGameServerAPIContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CSteamGameServerAPIContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamClient) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamGameServerAPIContext),
            "::",
            stringify!(m_pSteamClient)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamGameServer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamGameServerAPIContext),
            "::",
            stringify!(m_pSteamGameServer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamGameServerUtils) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamGameServerAPIContext),
            "::",
            stringify!(m_pSteamGameServerUtils)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_pSteamGameServerNetworking) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamGameServerAPIContext),
            "::",
            stringify!(m_pSteamGameServerNetworking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamGameServerStats) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamGameServerAPIContext),
            "::",
            stringify!(m_pSteamGameServerStats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamHTTP) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamGameServerAPIContext),
            "::",
            stringify!(m_pSteamHTTP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamInventory) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamGameServerAPIContext),
            "::",
            stringify!(m_pSteamInventory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSteamUGC) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CSteamGameServerAPIContext),
            "::",
            stringify!(m_pSteamUGC)
        )
    );
}
#[repr(C)]
pub struct ISteamClient__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamClient {
    pub vtable_: *const ISteamClient__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamClient() {
    assert_eq!(
        ::std::mem::size_of::<ISteamClient>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamClient))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamClient>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamClient))
    );
}
#[repr(C)]
pub struct ISteamUser__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamUser {
    pub vtable_: *const ISteamUser__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamUser() {
    assert_eq!(
        ::std::mem::size_of::<ISteamUser>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamUser))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamUser>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamUser))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamServersConnected_t {
    pub _address: u8,
}
pub const SteamServersConnected_t_k_iCallback: SteamServersConnected_t__bindgen_ty_1 = 101;
pub type SteamServersConnected_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamServersConnected_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamServersConnected_t>(),
        1usize,
        concat!("Size of: ", stringify!(SteamServersConnected_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamServersConnected_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamServersConnected_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamServerConnectFailure_t {
    pub m_eResult: EResult,
    pub m_bStillRetrying: bool,
}
pub const SteamServerConnectFailure_t_k_iCallback: SteamServerConnectFailure_t__bindgen_ty_1 = 102;
pub type SteamServerConnectFailure_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamServerConnectFailure_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamServerConnectFailure_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamServerConnectFailure_t>(),
        8usize,
        concat!("Size of: ", stringify!(SteamServerConnectFailure_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamServerConnectFailure_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamServerConnectFailure_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamServerConnectFailure_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bStillRetrying) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamServerConnectFailure_t),
            "::",
            stringify!(m_bStillRetrying)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamServersDisconnected_t {
    pub m_eResult: EResult,
}
pub const SteamServersDisconnected_t_k_iCallback: SteamServersDisconnected_t__bindgen_ty_1 = 103;
pub type SteamServersDisconnected_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamServersDisconnected_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamServersDisconnected_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamServersDisconnected_t>(),
        4usize,
        concat!("Size of: ", stringify!(SteamServersDisconnected_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamServersDisconnected_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamServersDisconnected_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamServersDisconnected_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClientGameServerDeny_t {
    pub m_uAppID: uint32,
    pub m_unGameServerIP: uint32,
    pub m_usGameServerPort: uint16,
    pub m_bSecure: uint16,
    pub m_uReason: uint32,
}
pub const ClientGameServerDeny_t_k_iCallback: ClientGameServerDeny_t__bindgen_ty_1 = 113;
pub type ClientGameServerDeny_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_ClientGameServerDeny_t() {
    const UNINIT: ::std::mem::MaybeUninit<ClientGameServerDeny_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClientGameServerDeny_t>(),
        16usize,
        concat!("Size of: ", stringify!(ClientGameServerDeny_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ClientGameServerDeny_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ClientGameServerDeny_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClientGameServerDeny_t),
            "::",
            stringify!(m_uAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unGameServerIP) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ClientGameServerDeny_t),
            "::",
            stringify!(m_unGameServerIP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usGameServerPort) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClientGameServerDeny_t),
            "::",
            stringify!(m_usGameServerPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSecure) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ClientGameServerDeny_t),
            "::",
            stringify!(m_bSecure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uReason) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ClientGameServerDeny_t),
            "::",
            stringify!(m_uReason)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPCFailure_t {
    pub m_eFailureType: uint8,
}
pub const IPCFailure_t_k_iCallback: IPCFailure_t__bindgen_ty_1 = 117;
pub type IPCFailure_t__bindgen_ty_1 = ::std::os::raw::c_int;
pub const IPCFailure_t_EFailureType_k_EFailureFlushedCallbackQueue: IPCFailure_t_EFailureType = 0;
pub const IPCFailure_t_EFailureType_k_EFailurePipeFail: IPCFailure_t_EFailureType = 1;
pub type IPCFailure_t_EFailureType = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_IPCFailure_t() {
    const UNINIT: ::std::mem::MaybeUninit<IPCFailure_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IPCFailure_t>(),
        1usize,
        concat!("Size of: ", stringify!(IPCFailure_t))
    );
    assert_eq!(
        ::std::mem::align_of::<IPCFailure_t>(),
        1usize,
        concat!("Alignment of ", stringify!(IPCFailure_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eFailureType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPCFailure_t),
            "::",
            stringify!(m_eFailureType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LicensesUpdated_t {
    pub _address: u8,
}
pub const LicensesUpdated_t_k_iCallback: LicensesUpdated_t__bindgen_ty_1 = 125;
pub type LicensesUpdated_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_LicensesUpdated_t() {
    assert_eq!(
        ::std::mem::size_of::<LicensesUpdated_t>(),
        1usize,
        concat!("Size of: ", stringify!(LicensesUpdated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LicensesUpdated_t>(),
        1usize,
        concat!("Alignment of ", stringify!(LicensesUpdated_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ValidateAuthTicketResponse_t {
    pub m_SteamID: CSteamID,
    pub m_eAuthSessionResponse: EAuthSessionResponse,
    pub m_OwnerSteamID: CSteamID,
}
pub const ValidateAuthTicketResponse_t_k_iCallback: ValidateAuthTicketResponse_t__bindgen_ty_1 =
    143;
pub type ValidateAuthTicketResponse_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_ValidateAuthTicketResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<ValidateAuthTicketResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ValidateAuthTicketResponse_t>(),
        20usize,
        concat!("Size of: ", stringify!(ValidateAuthTicketResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ValidateAuthTicketResponse_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ValidateAuthTicketResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ValidateAuthTicketResponse_t),
            "::",
            stringify!(m_SteamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAuthSessionResponse) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ValidateAuthTicketResponse_t),
            "::",
            stringify!(m_eAuthSessionResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_OwnerSteamID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ValidateAuthTicketResponse_t),
            "::",
            stringify!(m_OwnerSteamID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MicroTxnAuthorizationResponse_t {
    pub m_unAppID: uint32,
    pub m_ulOrderID: uint64,
    pub m_bAuthorized: uint8,
}
pub const MicroTxnAuthorizationResponse_t_k_iCallback:
    MicroTxnAuthorizationResponse_t__bindgen_ty_1 = 152;
pub type MicroTxnAuthorizationResponse_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_MicroTxnAuthorizationResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<MicroTxnAuthorizationResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MicroTxnAuthorizationResponse_t>(),
        24usize,
        concat!("Size of: ", stringify!(MicroTxnAuthorizationResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MicroTxnAuthorizationResponse_t>(),
        8usize,
        concat!("Alignment of ", stringify!(MicroTxnAuthorizationResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MicroTxnAuthorizationResponse_t),
            "::",
            stringify!(m_unAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulOrderID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MicroTxnAuthorizationResponse_t),
            "::",
            stringify!(m_ulOrderID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAuthorized) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MicroTxnAuthorizationResponse_t),
            "::",
            stringify!(m_bAuthorized)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EncryptedAppTicketResponse_t {
    pub m_eResult: EResult,
}
pub const EncryptedAppTicketResponse_t_k_iCallback: EncryptedAppTicketResponse_t__bindgen_ty_1 =
    154;
pub type EncryptedAppTicketResponse_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_EncryptedAppTicketResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<EncryptedAppTicketResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EncryptedAppTicketResponse_t>(),
        4usize,
        concat!("Size of: ", stringify!(EncryptedAppTicketResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<EncryptedAppTicketResponse_t>(),
        4usize,
        concat!("Alignment of ", stringify!(EncryptedAppTicketResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EncryptedAppTicketResponse_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GetAuthSessionTicketResponse_t {
    pub m_hAuthTicket: HAuthTicket,
    pub m_eResult: EResult,
}
pub const GetAuthSessionTicketResponse_t_k_iCallback: GetAuthSessionTicketResponse_t__bindgen_ty_1 =
    163;
pub type GetAuthSessionTicketResponse_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GetAuthSessionTicketResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<GetAuthSessionTicketResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GetAuthSessionTicketResponse_t>(),
        8usize,
        concat!("Size of: ", stringify!(GetAuthSessionTicketResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GetAuthSessionTicketResponse_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GetAuthSessionTicketResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hAuthTicket) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GetAuthSessionTicketResponse_t),
            "::",
            stringify!(m_hAuthTicket)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GetAuthSessionTicketResponse_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GameWebCallback_t {
    pub m_szURL: [::std::os::raw::c_char; 256usize],
}
pub const GameWebCallback_t_k_iCallback: GameWebCallback_t__bindgen_ty_1 = 164;
pub type GameWebCallback_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GameWebCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameWebCallback_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameWebCallback_t>(),
        256usize,
        concat!("Size of: ", stringify!(GameWebCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameWebCallback_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GameWebCallback_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szURL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameWebCallback_t),
            "::",
            stringify!(m_szURL)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StoreAuthURLResponse_t {
    pub m_szURL: [::std::os::raw::c_char; 512usize],
}
pub const StoreAuthURLResponse_t_k_iCallback: StoreAuthURLResponse_t__bindgen_ty_1 = 165;
pub type StoreAuthURLResponse_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_StoreAuthURLResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<StoreAuthURLResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<StoreAuthURLResponse_t>(),
        512usize,
        concat!("Size of: ", stringify!(StoreAuthURLResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<StoreAuthURLResponse_t>(),
        1usize,
        concat!("Alignment of ", stringify!(StoreAuthURLResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szURL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StoreAuthURLResponse_t),
            "::",
            stringify!(m_szURL)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MarketEligibilityResponse_t {
    pub m_bAllowed: bool,
    pub m_eNotAllowedReason: EMarketNotAllowedReasonFlags,
    pub m_rtAllowedAtTime: RTime32,
    pub m_cdaySteamGuardRequiredDays: ::std::os::raw::c_int,
    pub m_cdayNewDeviceCooldown: ::std::os::raw::c_int,
}
pub const MarketEligibilityResponse_t_k_iCallback: MarketEligibilityResponse_t__bindgen_ty_1 = 166;
pub type MarketEligibilityResponse_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_MarketEligibilityResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<MarketEligibilityResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MarketEligibilityResponse_t>(),
        20usize,
        concat!("Size of: ", stringify!(MarketEligibilityResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MarketEligibilityResponse_t>(),
        4usize,
        concat!("Alignment of ", stringify!(MarketEligibilityResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAllowed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MarketEligibilityResponse_t),
            "::",
            stringify!(m_bAllowed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eNotAllowedReason) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MarketEligibilityResponse_t),
            "::",
            stringify!(m_eNotAllowedReason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rtAllowedAtTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MarketEligibilityResponse_t),
            "::",
            stringify!(m_rtAllowedAtTime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_cdaySteamGuardRequiredDays) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MarketEligibilityResponse_t),
            "::",
            stringify!(m_cdaySteamGuardRequiredDays)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cdayNewDeviceCooldown) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MarketEligibilityResponse_t),
            "::",
            stringify!(m_cdayNewDeviceCooldown)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DurationControl_t {
    pub m_eResult: EResult,
    pub m_appid: AppId_t,
    pub m_bApplicable: bool,
    pub m_csecsLast5h: int32,
    pub m_progress: EDurationControlProgress,
    pub m_notification: EDurationControlNotification,
    pub m_csecsToday: int32,
    pub m_csecsRemaining: int32,
}
pub const DurationControl_t_k_iCallback: DurationControl_t__bindgen_ty_1 = 167;
pub type DurationControl_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_DurationControl_t() {
    const UNINIT: ::std::mem::MaybeUninit<DurationControl_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DurationControl_t>(),
        32usize,
        concat!("Size of: ", stringify!(DurationControl_t))
    );
    assert_eq!(
        ::std::mem::align_of::<DurationControl_t>(),
        4usize,
        concat!("Alignment of ", stringify!(DurationControl_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DurationControl_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_appid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DurationControl_t),
            "::",
            stringify!(m_appid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bApplicable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DurationControl_t),
            "::",
            stringify!(m_bApplicable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_csecsLast5h) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DurationControl_t),
            "::",
            stringify!(m_csecsLast5h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_progress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DurationControl_t),
            "::",
            stringify!(m_progress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_notification) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DurationControl_t),
            "::",
            stringify!(m_notification)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_csecsToday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DurationControl_t),
            "::",
            stringify!(m_csecsToday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_csecsRemaining) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(DurationControl_t),
            "::",
            stringify!(m_csecsRemaining)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GetTicketForWebApiResponse_t {
    pub m_hAuthTicket: HAuthTicket,
    pub m_eResult: EResult,
    pub m_cubTicket: ::std::os::raw::c_int,
    pub m_rgubTicket: [uint8; 2560usize],
}
pub const GetTicketForWebApiResponse_t_k_iCallback: GetTicketForWebApiResponse_t__bindgen_ty_1 =
    168;
pub type GetTicketForWebApiResponse_t__bindgen_ty_1 = ::std::os::raw::c_int;
pub const GetTicketForWebApiResponse_t_k_nCubTicketMaxLength: ::std::os::raw::c_int = 2560;
#[test]
fn bindgen_test_layout_GetTicketForWebApiResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<GetTicketForWebApiResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GetTicketForWebApiResponse_t>(),
        2572usize,
        concat!("Size of: ", stringify!(GetTicketForWebApiResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GetTicketForWebApiResponse_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GetTicketForWebApiResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hAuthTicket) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GetTicketForWebApiResponse_t),
            "::",
            stringify!(m_hAuthTicket)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GetTicketForWebApiResponse_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cubTicket) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GetTicketForWebApiResponse_t),
            "::",
            stringify!(m_cubTicket)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgubTicket) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GetTicketForWebApiResponse_t),
            "::",
            stringify!(m_rgubTicket)
        )
    );
}
pub const EFriendRelationship_k_EFriendRelationshipNone: EFriendRelationship = 0;
pub const EFriendRelationship_k_EFriendRelationshipBlocked: EFriendRelationship = 1;
pub const EFriendRelationship_k_EFriendRelationshipRequestRecipient: EFriendRelationship = 2;
pub const EFriendRelationship_k_EFriendRelationshipFriend: EFriendRelationship = 3;
pub const EFriendRelationship_k_EFriendRelationshipRequestInitiator: EFriendRelationship = 4;
pub const EFriendRelationship_k_EFriendRelationshipIgnored: EFriendRelationship = 5;
pub const EFriendRelationship_k_EFriendRelationshipIgnoredFriend: EFriendRelationship = 6;
pub const EFriendRelationship_k_EFriendRelationshipSuggested_DEPRECATED: EFriendRelationship = 7;
pub const EFriendRelationship_k_EFriendRelationshipMax: EFriendRelationship = 8;
pub type EFriendRelationship = ::std::os::raw::c_int;
pub const k_cchMaxFriendsGroupName: ::std::os::raw::c_int = 64;
pub const k_cFriendsGroupLimit: ::std::os::raw::c_int = 100;
pub type FriendsGroupID_t = int16;
pub const k_FriendsGroupID_Invalid: FriendsGroupID_t = -1;
pub const k_cEnumerateFollowersMax: ::std::os::raw::c_int = 50;
pub const EPersonaState_k_EPersonaStateOffline: EPersonaState = 0;
pub const EPersonaState_k_EPersonaStateOnline: EPersonaState = 1;
pub const EPersonaState_k_EPersonaStateBusy: EPersonaState = 2;
pub const EPersonaState_k_EPersonaStateAway: EPersonaState = 3;
pub const EPersonaState_k_EPersonaStateSnooze: EPersonaState = 4;
pub const EPersonaState_k_EPersonaStateLookingToTrade: EPersonaState = 5;
pub const EPersonaState_k_EPersonaStateLookingToPlay: EPersonaState = 6;
pub const EPersonaState_k_EPersonaStateInvisible: EPersonaState = 7;
pub const EPersonaState_k_EPersonaStateMax: EPersonaState = 8;
pub type EPersonaState = ::std::os::raw::c_int;
pub const EFriendFlags_k_EFriendFlagNone: EFriendFlags = 0;
pub const EFriendFlags_k_EFriendFlagBlocked: EFriendFlags = 1;
pub const EFriendFlags_k_EFriendFlagFriendshipRequested: EFriendFlags = 2;
pub const EFriendFlags_k_EFriendFlagImmediate: EFriendFlags = 4;
pub const EFriendFlags_k_EFriendFlagClanMember: EFriendFlags = 8;
pub const EFriendFlags_k_EFriendFlagOnGameServer: EFriendFlags = 16;
pub const EFriendFlags_k_EFriendFlagRequestingFriendship: EFriendFlags = 128;
pub const EFriendFlags_k_EFriendFlagRequestingInfo: EFriendFlags = 256;
pub const EFriendFlags_k_EFriendFlagIgnored: EFriendFlags = 512;
pub const EFriendFlags_k_EFriendFlagIgnoredFriend: EFriendFlags = 1024;
pub const EFriendFlags_k_EFriendFlagChatMember: EFriendFlags = 4096;
pub const EFriendFlags_k_EFriendFlagAll: EFriendFlags = 65535;
pub type EFriendFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FriendGameInfo_t {
    pub m_gameID: CGameID,
    pub m_unGameIP: uint32,
    pub m_usGamePort: uint16,
    pub m_usQueryPort: uint16,
    pub m_steamIDLobby: CSteamID,
}
#[test]
fn bindgen_test_layout_FriendGameInfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<FriendGameInfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FriendGameInfo_t>(),
        24usize,
        concat!("Size of: ", stringify!(FriendGameInfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FriendGameInfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FriendGameInfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_gameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendGameInfo_t),
            "::",
            stringify!(m_gameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unGameIP) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendGameInfo_t),
            "::",
            stringify!(m_unGameIP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usGamePort) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendGameInfo_t),
            "::",
            stringify!(m_usGamePort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usQueryPort) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendGameInfo_t),
            "::",
            stringify!(m_usQueryPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDLobby) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendGameInfo_t),
            "::",
            stringify!(m_steamIDLobby)
        )
    );
}
pub const k_usFriendGameInfoQueryPort_NotInitialized: uint16 = 65535;
pub const k_usFriendGameInfoQueryPort_Error: uint16 = 65534;
pub const k_cchPersonaNameMax: _bindgen_ty_38 = 128;
pub const k_cwchPersonaNameMax: _bindgen_ty_38 = 32;
pub type _bindgen_ty_38 = ::std::os::raw::c_int;
pub const EUserRestriction_k_nUserRestrictionNone: EUserRestriction = 0;
pub const EUserRestriction_k_nUserRestrictionUnknown: EUserRestriction = 1;
pub const EUserRestriction_k_nUserRestrictionAnyChat: EUserRestriction = 2;
pub const EUserRestriction_k_nUserRestrictionVoiceChat: EUserRestriction = 4;
pub const EUserRestriction_k_nUserRestrictionGroupChat: EUserRestriction = 8;
pub const EUserRestriction_k_nUserRestrictionRating: EUserRestriction = 16;
pub const EUserRestriction_k_nUserRestrictionGameInvites: EUserRestriction = 32;
pub const EUserRestriction_k_nUserRestrictionTrading: EUserRestriction = 64;
pub type EUserRestriction = ::std::os::raw::c_int;
pub const k_cubChatMetadataMax: uint32 = 8192;
pub const k_cchMaxRichPresenceKeys: _bindgen_ty_39 = 30;
pub type _bindgen_ty_39 = ::std::os::raw::c_int;
pub const k_cchMaxRichPresenceKeyLength: _bindgen_ty_40 = 64;
pub type _bindgen_ty_40 = ::std::os::raw::c_int;
pub const k_cchMaxRichPresenceValueLength: _bindgen_ty_41 = 256;
pub type _bindgen_ty_41 = ::std::os::raw::c_int;
pub const EOverlayToStoreFlag_k_EOverlayToStoreFlag_None: EOverlayToStoreFlag = 0;
pub const EOverlayToStoreFlag_k_EOverlayToStoreFlag_AddToCart: EOverlayToStoreFlag = 1;
pub const EOverlayToStoreFlag_k_EOverlayToStoreFlag_AddToCartAndShow: EOverlayToStoreFlag = 2;
pub type EOverlayToStoreFlag = ::std::os::raw::c_int;
pub const EActivateGameOverlayToWebPageMode_k_EActivateGameOverlayToWebPageMode_Default:
    EActivateGameOverlayToWebPageMode = 0;
pub const EActivateGameOverlayToWebPageMode_k_EActivateGameOverlayToWebPageMode_Modal:
    EActivateGameOverlayToWebPageMode = 1;
pub type EActivateGameOverlayToWebPageMode = ::std::os::raw::c_int;
pub const ECommunityProfileItemType_k_ECommunityProfileItemType_AnimatedAvatar:
    ECommunityProfileItemType = 0;
pub const ECommunityProfileItemType_k_ECommunityProfileItemType_AvatarFrame:
    ECommunityProfileItemType = 1;
pub const ECommunityProfileItemType_k_ECommunityProfileItemType_ProfileModifier:
    ECommunityProfileItemType = 2;
pub const ECommunityProfileItemType_k_ECommunityProfileItemType_ProfileBackground:
    ECommunityProfileItemType = 3;
pub const ECommunityProfileItemType_k_ECommunityProfileItemType_MiniProfileBackground:
    ECommunityProfileItemType = 4;
pub type ECommunityProfileItemType = ::std::os::raw::c_int;
pub const ECommunityProfileItemProperty_k_ECommunityProfileItemProperty_ImageSmall:
    ECommunityProfileItemProperty = 0;
pub const ECommunityProfileItemProperty_k_ECommunityProfileItemProperty_ImageLarge:
    ECommunityProfileItemProperty = 1;
pub const ECommunityProfileItemProperty_k_ECommunityProfileItemProperty_InternalName:
    ECommunityProfileItemProperty = 2;
pub const ECommunityProfileItemProperty_k_ECommunityProfileItemProperty_Title:
    ECommunityProfileItemProperty = 3;
pub const ECommunityProfileItemProperty_k_ECommunityProfileItemProperty_Description:
    ECommunityProfileItemProperty = 4;
pub const ECommunityProfileItemProperty_k_ECommunityProfileItemProperty_AppID:
    ECommunityProfileItemProperty = 5;
pub const ECommunityProfileItemProperty_k_ECommunityProfileItemProperty_TypeID:
    ECommunityProfileItemProperty = 6;
pub const ECommunityProfileItemProperty_k_ECommunityProfileItemProperty_Class:
    ECommunityProfileItemProperty = 7;
pub const ECommunityProfileItemProperty_k_ECommunityProfileItemProperty_MovieWebM:
    ECommunityProfileItemProperty = 8;
pub const ECommunityProfileItemProperty_k_ECommunityProfileItemProperty_MovieMP4:
    ECommunityProfileItemProperty = 9;
pub const ECommunityProfileItemProperty_k_ECommunityProfileItemProperty_MovieWebMSmall:
    ECommunityProfileItemProperty = 10;
pub const ECommunityProfileItemProperty_k_ECommunityProfileItemProperty_MovieMP4Small:
    ECommunityProfileItemProperty = 11;
pub type ECommunityProfileItemProperty = ::std::os::raw::c_int;
#[repr(C)]
pub struct ISteamFriends__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamFriends {
    pub vtable_: *const ISteamFriends__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamFriends() {
    assert_eq!(
        ::std::mem::size_of::<ISteamFriends>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamFriends))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamFriends>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamFriends))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PersonaStateChange_t {
    pub m_ulSteamID: uint64,
    pub m_nChangeFlags: ::std::os::raw::c_int,
}
pub const PersonaStateChange_t_k_iCallback: PersonaStateChange_t__bindgen_ty_1 = 304;
pub type PersonaStateChange_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_PersonaStateChange_t() {
    const UNINIT: ::std::mem::MaybeUninit<PersonaStateChange_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PersonaStateChange_t>(),
        16usize,
        concat!("Size of: ", stringify!(PersonaStateChange_t))
    );
    assert_eq!(
        ::std::mem::align_of::<PersonaStateChange_t>(),
        8usize,
        concat!("Alignment of ", stringify!(PersonaStateChange_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PersonaStateChange_t),
            "::",
            stringify!(m_ulSteamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nChangeFlags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PersonaStateChange_t),
            "::",
            stringify!(m_nChangeFlags)
        )
    );
}
pub const EPersonaChange_k_EPersonaChangeName: EPersonaChange = 1;
pub const EPersonaChange_k_EPersonaChangeStatus: EPersonaChange = 2;
pub const EPersonaChange_k_EPersonaChangeComeOnline: EPersonaChange = 4;
pub const EPersonaChange_k_EPersonaChangeGoneOffline: EPersonaChange = 8;
pub const EPersonaChange_k_EPersonaChangeGamePlayed: EPersonaChange = 16;
pub const EPersonaChange_k_EPersonaChangeGameServer: EPersonaChange = 32;
pub const EPersonaChange_k_EPersonaChangeAvatar: EPersonaChange = 64;
pub const EPersonaChange_k_EPersonaChangeJoinedSource: EPersonaChange = 128;
pub const EPersonaChange_k_EPersonaChangeLeftSource: EPersonaChange = 256;
pub const EPersonaChange_k_EPersonaChangeRelationshipChanged: EPersonaChange = 512;
pub const EPersonaChange_k_EPersonaChangeNameFirstSet: EPersonaChange = 1024;
pub const EPersonaChange_k_EPersonaChangeBroadcast: EPersonaChange = 2048;
pub const EPersonaChange_k_EPersonaChangeNickname: EPersonaChange = 4096;
pub const EPersonaChange_k_EPersonaChangeSteamLevel: EPersonaChange = 8192;
pub const EPersonaChange_k_EPersonaChangeRichPresence: EPersonaChange = 16384;
pub type EPersonaChange = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GameOverlayActivated_t {
    pub m_bActive: uint8,
    pub m_bUserInitiated: bool,
    pub m_nAppID: AppId_t,
    pub m_dwOverlayPID: uint32,
}
pub const GameOverlayActivated_t_k_iCallback: GameOverlayActivated_t__bindgen_ty_1 = 331;
pub type GameOverlayActivated_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GameOverlayActivated_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameOverlayActivated_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameOverlayActivated_t>(),
        12usize,
        concat!("Size of: ", stringify!(GameOverlayActivated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameOverlayActivated_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GameOverlayActivated_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bActive) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameOverlayActivated_t),
            "::",
            stringify!(m_bActive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUserInitiated) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(GameOverlayActivated_t),
            "::",
            stringify!(m_bUserInitiated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GameOverlayActivated_t),
            "::",
            stringify!(m_nAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dwOverlayPID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameOverlayActivated_t),
            "::",
            stringify!(m_dwOverlayPID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GameServerChangeRequested_t {
    pub m_rgchServer: [::std::os::raw::c_char; 64usize],
    pub m_rgchPassword: [::std::os::raw::c_char; 64usize],
}
pub const GameServerChangeRequested_t_k_iCallback: GameServerChangeRequested_t__bindgen_ty_1 = 332;
pub type GameServerChangeRequested_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GameServerChangeRequested_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameServerChangeRequested_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameServerChangeRequested_t>(),
        128usize,
        concat!("Size of: ", stringify!(GameServerChangeRequested_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameServerChangeRequested_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GameServerChangeRequested_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchServer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameServerChangeRequested_t),
            "::",
            stringify!(m_rgchServer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchPassword) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GameServerChangeRequested_t),
            "::",
            stringify!(m_rgchPassword)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GameLobbyJoinRequested_t {
    pub m_steamIDLobby: CSteamID,
    pub m_steamIDFriend: CSteamID,
}
pub const GameLobbyJoinRequested_t_k_iCallback: GameLobbyJoinRequested_t__bindgen_ty_1 = 333;
pub type GameLobbyJoinRequested_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GameLobbyJoinRequested_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameLobbyJoinRequested_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameLobbyJoinRequested_t>(),
        16usize,
        concat!("Size of: ", stringify!(GameLobbyJoinRequested_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameLobbyJoinRequested_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GameLobbyJoinRequested_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDLobby) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameLobbyJoinRequested_t),
            "::",
            stringify!(m_steamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDFriend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameLobbyJoinRequested_t),
            "::",
            stringify!(m_steamIDFriend)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AvatarImageLoaded_t {
    pub m_steamID: CSteamID,
    pub m_iImage: ::std::os::raw::c_int,
    pub m_iWide: ::std::os::raw::c_int,
    pub m_iTall: ::std::os::raw::c_int,
}
pub const AvatarImageLoaded_t_k_iCallback: AvatarImageLoaded_t__bindgen_ty_1 = 334;
pub type AvatarImageLoaded_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_AvatarImageLoaded_t() {
    const UNINIT: ::std::mem::MaybeUninit<AvatarImageLoaded_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AvatarImageLoaded_t>(),
        20usize,
        concat!("Size of: ", stringify!(AvatarImageLoaded_t))
    );
    assert_eq!(
        ::std::mem::align_of::<AvatarImageLoaded_t>(),
        4usize,
        concat!("Alignment of ", stringify!(AvatarImageLoaded_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AvatarImageLoaded_t),
            "::",
            stringify!(m_steamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iImage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AvatarImageLoaded_t),
            "::",
            stringify!(m_iImage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iWide) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AvatarImageLoaded_t),
            "::",
            stringify!(m_iWide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iTall) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AvatarImageLoaded_t),
            "::",
            stringify!(m_iTall)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ClanOfficerListResponse_t {
    pub m_steamIDClan: CSteamID,
    pub m_cOfficers: ::std::os::raw::c_int,
    pub m_bSuccess: uint8,
}
pub const ClanOfficerListResponse_t_k_iCallback: ClanOfficerListResponse_t__bindgen_ty_1 = 335;
pub type ClanOfficerListResponse_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_ClanOfficerListResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<ClanOfficerListResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClanOfficerListResponse_t>(),
        16usize,
        concat!("Size of: ", stringify!(ClanOfficerListResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ClanOfficerListResponse_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ClanOfficerListResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDClan) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClanOfficerListResponse_t),
            "::",
            stringify!(m_steamIDClan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cOfficers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClanOfficerListResponse_t),
            "::",
            stringify!(m_cOfficers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSuccess) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ClanOfficerListResponse_t),
            "::",
            stringify!(m_bSuccess)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FriendRichPresenceUpdate_t {
    pub m_steamIDFriend: CSteamID,
    pub m_nAppID: AppId_t,
}
pub const FriendRichPresenceUpdate_t_k_iCallback: FriendRichPresenceUpdate_t__bindgen_ty_1 = 336;
pub type FriendRichPresenceUpdate_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_FriendRichPresenceUpdate_t() {
    const UNINIT: ::std::mem::MaybeUninit<FriendRichPresenceUpdate_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FriendRichPresenceUpdate_t>(),
        12usize,
        concat!("Size of: ", stringify!(FriendRichPresenceUpdate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FriendRichPresenceUpdate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FriendRichPresenceUpdate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDFriend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendRichPresenceUpdate_t),
            "::",
            stringify!(m_steamIDFriend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendRichPresenceUpdate_t),
            "::",
            stringify!(m_nAppID)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GameRichPresenceJoinRequested_t {
    pub m_steamIDFriend: CSteamID,
    pub m_rgchConnect: [::std::os::raw::c_char; 256usize],
}
pub const GameRichPresenceJoinRequested_t_k_iCallback:
    GameRichPresenceJoinRequested_t__bindgen_ty_1 = 337;
pub type GameRichPresenceJoinRequested_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GameRichPresenceJoinRequested_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameRichPresenceJoinRequested_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameRichPresenceJoinRequested_t>(),
        264usize,
        concat!("Size of: ", stringify!(GameRichPresenceJoinRequested_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameRichPresenceJoinRequested_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GameRichPresenceJoinRequested_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDFriend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameRichPresenceJoinRequested_t),
            "::",
            stringify!(m_steamIDFriend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchConnect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameRichPresenceJoinRequested_t),
            "::",
            stringify!(m_rgchConnect)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GameConnectedClanChatMsg_t {
    pub m_steamIDClanChat: CSteamID,
    pub m_steamIDUser: CSteamID,
    pub m_iMessageID: ::std::os::raw::c_int,
}
pub const GameConnectedClanChatMsg_t_k_iCallback: GameConnectedClanChatMsg_t__bindgen_ty_1 = 338;
pub type GameConnectedClanChatMsg_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GameConnectedClanChatMsg_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameConnectedClanChatMsg_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameConnectedClanChatMsg_t>(),
        20usize,
        concat!("Size of: ", stringify!(GameConnectedClanChatMsg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameConnectedClanChatMsg_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GameConnectedClanChatMsg_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDClanChat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedClanChatMsg_t),
            "::",
            stringify!(m_steamIDClanChat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedClanChatMsg_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iMessageID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedClanChatMsg_t),
            "::",
            stringify!(m_iMessageID)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GameConnectedChatJoin_t {
    pub m_steamIDClanChat: CSteamID,
    pub m_steamIDUser: CSteamID,
}
pub const GameConnectedChatJoin_t_k_iCallback: GameConnectedChatJoin_t__bindgen_ty_1 = 339;
pub type GameConnectedChatJoin_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GameConnectedChatJoin_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameConnectedChatJoin_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameConnectedChatJoin_t>(),
        16usize,
        concat!("Size of: ", stringify!(GameConnectedChatJoin_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameConnectedChatJoin_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GameConnectedChatJoin_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDClanChat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedChatJoin_t),
            "::",
            stringify!(m_steamIDClanChat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedChatJoin_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GameConnectedChatLeave_t {
    pub m_steamIDClanChat: CSteamID,
    pub m_steamIDUser: CSteamID,
    pub m_bKicked: bool,
    pub m_bDropped: bool,
}
pub const GameConnectedChatLeave_t_k_iCallback: GameConnectedChatLeave_t__bindgen_ty_1 = 340;
pub type GameConnectedChatLeave_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GameConnectedChatLeave_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameConnectedChatLeave_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameConnectedChatLeave_t>(),
        18usize,
        concat!("Size of: ", stringify!(GameConnectedChatLeave_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameConnectedChatLeave_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GameConnectedChatLeave_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDClanChat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedChatLeave_t),
            "::",
            stringify!(m_steamIDClanChat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedChatLeave_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bKicked) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedChatLeave_t),
            "::",
            stringify!(m_bKicked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bDropped) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedChatLeave_t),
            "::",
            stringify!(m_bDropped)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DownloadClanActivityCountsResult_t {
    pub m_bSuccess: bool,
}
pub const DownloadClanActivityCountsResult_t_k_iCallback:
    DownloadClanActivityCountsResult_t__bindgen_ty_1 = 341;
pub type DownloadClanActivityCountsResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_DownloadClanActivityCountsResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<DownloadClanActivityCountsResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DownloadClanActivityCountsResult_t>(),
        1usize,
        concat!("Size of: ", stringify!(DownloadClanActivityCountsResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<DownloadClanActivityCountsResult_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DownloadClanActivityCountsResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSuccess) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DownloadClanActivityCountsResult_t),
            "::",
            stringify!(m_bSuccess)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JoinClanChatRoomCompletionResult_t {
    pub m_steamIDClanChat: CSteamID,
    pub m_eChatRoomEnterResponse: EChatRoomEnterResponse,
}
pub const JoinClanChatRoomCompletionResult_t_k_iCallback:
    JoinClanChatRoomCompletionResult_t__bindgen_ty_1 = 342;
pub type JoinClanChatRoomCompletionResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_JoinClanChatRoomCompletionResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<JoinClanChatRoomCompletionResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JoinClanChatRoomCompletionResult_t>(),
        12usize,
        concat!("Size of: ", stringify!(JoinClanChatRoomCompletionResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<JoinClanChatRoomCompletionResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(JoinClanChatRoomCompletionResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDClanChat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinClanChatRoomCompletionResult_t),
            "::",
            stringify!(m_steamIDClanChat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eChatRoomEnterResponse) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinClanChatRoomCompletionResult_t),
            "::",
            stringify!(m_eChatRoomEnterResponse)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GameConnectedFriendChatMsg_t {
    pub m_steamIDUser: CSteamID,
    pub m_iMessageID: ::std::os::raw::c_int,
}
pub const GameConnectedFriendChatMsg_t_k_iCallback: GameConnectedFriendChatMsg_t__bindgen_ty_1 =
    343;
pub type GameConnectedFriendChatMsg_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GameConnectedFriendChatMsg_t() {
    const UNINIT: ::std::mem::MaybeUninit<GameConnectedFriendChatMsg_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GameConnectedFriendChatMsg_t>(),
        12usize,
        concat!("Size of: ", stringify!(GameConnectedFriendChatMsg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GameConnectedFriendChatMsg_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GameConnectedFriendChatMsg_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedFriendChatMsg_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iMessageID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GameConnectedFriendChatMsg_t),
            "::",
            stringify!(m_iMessageID)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FriendsGetFollowerCount_t {
    pub m_eResult: EResult,
    pub m_steamID: CSteamID,
    pub m_nCount: ::std::os::raw::c_int,
}
pub const FriendsGetFollowerCount_t_k_iCallback: FriendsGetFollowerCount_t__bindgen_ty_1 = 344;
pub type FriendsGetFollowerCount_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_FriendsGetFollowerCount_t() {
    const UNINIT: ::std::mem::MaybeUninit<FriendsGetFollowerCount_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FriendsGetFollowerCount_t>(),
        16usize,
        concat!("Size of: ", stringify!(FriendsGetFollowerCount_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FriendsGetFollowerCount_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FriendsGetFollowerCount_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsGetFollowerCount_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsGetFollowerCount_t),
            "::",
            stringify!(m_steamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsGetFollowerCount_t),
            "::",
            stringify!(m_nCount)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FriendsIsFollowing_t {
    pub m_eResult: EResult,
    pub m_steamID: CSteamID,
    pub m_bIsFollowing: bool,
}
pub const FriendsIsFollowing_t_k_iCallback: FriendsIsFollowing_t__bindgen_ty_1 = 345;
pub type FriendsIsFollowing_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_FriendsIsFollowing_t() {
    const UNINIT: ::std::mem::MaybeUninit<FriendsIsFollowing_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FriendsIsFollowing_t>(),
        16usize,
        concat!("Size of: ", stringify!(FriendsIsFollowing_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FriendsIsFollowing_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FriendsIsFollowing_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsIsFollowing_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsIsFollowing_t),
            "::",
            stringify!(m_steamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsFollowing) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsIsFollowing_t),
            "::",
            stringify!(m_bIsFollowing)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FriendsEnumerateFollowingList_t {
    pub m_eResult: EResult,
    pub m_rgSteamID: [CSteamID; 50usize],
    pub m_nResultsReturned: int32,
    pub m_nTotalResultCount: int32,
}
pub const FriendsEnumerateFollowingList_t_k_iCallback:
    FriendsEnumerateFollowingList_t__bindgen_ty_1 = 346;
pub type FriendsEnumerateFollowingList_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_FriendsEnumerateFollowingList_t() {
    const UNINIT: ::std::mem::MaybeUninit<FriendsEnumerateFollowingList_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FriendsEnumerateFollowingList_t>(),
        412usize,
        concat!("Size of: ", stringify!(FriendsEnumerateFollowingList_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FriendsEnumerateFollowingList_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FriendsEnumerateFollowingList_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsEnumerateFollowingList_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgSteamID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsEnumerateFollowingList_t),
            "::",
            stringify!(m_rgSteamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nResultsReturned) as usize - ptr as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsEnumerateFollowingList_t),
            "::",
            stringify!(m_nResultsReturned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalResultCount) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(FriendsEnumerateFollowingList_t),
            "::",
            stringify!(m_nTotalResultCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetPersonaNameResponse_t {
    pub m_bSuccess: bool,
    pub m_bLocalSuccess: bool,
    pub m_result: EResult,
}
pub const SetPersonaNameResponse_t_k_iCallback: SetPersonaNameResponse_t__bindgen_ty_1 = 347;
pub type SetPersonaNameResponse_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SetPersonaNameResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<SetPersonaNameResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SetPersonaNameResponse_t>(),
        8usize,
        concat!("Size of: ", stringify!(SetPersonaNameResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SetPersonaNameResponse_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SetPersonaNameResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSuccess) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SetPersonaNameResponse_t),
            "::",
            stringify!(m_bSuccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bLocalSuccess) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SetPersonaNameResponse_t),
            "::",
            stringify!(m_bLocalSuccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_result) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SetPersonaNameResponse_t),
            "::",
            stringify!(m_result)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnreadChatMessagesChanged_t {
    pub _address: u8,
}
pub const UnreadChatMessagesChanged_t_k_iCallback: UnreadChatMessagesChanged_t__bindgen_ty_1 = 348;
pub type UnreadChatMessagesChanged_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_UnreadChatMessagesChanged_t() {
    assert_eq!(
        ::std::mem::size_of::<UnreadChatMessagesChanged_t>(),
        1usize,
        concat!("Size of: ", stringify!(UnreadChatMessagesChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<UnreadChatMessagesChanged_t>(),
        1usize,
        concat!("Alignment of ", stringify!(UnreadChatMessagesChanged_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OverlayBrowserProtocolNavigation_t {
    pub rgchURI: [::std::os::raw::c_char; 1024usize],
}
pub const OverlayBrowserProtocolNavigation_t_k_iCallback:
    OverlayBrowserProtocolNavigation_t__bindgen_ty_1 = 349;
pub type OverlayBrowserProtocolNavigation_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_OverlayBrowserProtocolNavigation_t() {
    const UNINIT: ::std::mem::MaybeUninit<OverlayBrowserProtocolNavigation_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OverlayBrowserProtocolNavigation_t>(),
        1024usize,
        concat!("Size of: ", stringify!(OverlayBrowserProtocolNavigation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<OverlayBrowserProtocolNavigation_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(OverlayBrowserProtocolNavigation_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgchURI) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OverlayBrowserProtocolNavigation_t),
            "::",
            stringify!(rgchURI)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EquippedProfileItemsChanged_t {
    pub m_steamID: CSteamID,
}
pub const EquippedProfileItemsChanged_t_k_iCallback: EquippedProfileItemsChanged_t__bindgen_ty_1 =
    350;
pub type EquippedProfileItemsChanged_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_EquippedProfileItemsChanged_t() {
    const UNINIT: ::std::mem::MaybeUninit<EquippedProfileItemsChanged_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EquippedProfileItemsChanged_t>(),
        8usize,
        concat!("Size of: ", stringify!(EquippedProfileItemsChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<EquippedProfileItemsChanged_t>(),
        1usize,
        concat!("Alignment of ", stringify!(EquippedProfileItemsChanged_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EquippedProfileItemsChanged_t),
            "::",
            stringify!(m_steamID)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EquippedProfileItems_t {
    pub m_eResult: EResult,
    pub m_steamID: CSteamID,
    pub m_bHasAnimatedAvatar: bool,
    pub m_bHasAvatarFrame: bool,
    pub m_bHasProfileModifier: bool,
    pub m_bHasProfileBackground: bool,
    pub m_bHasMiniProfileBackground: bool,
}
pub const EquippedProfileItems_t_k_iCallback: EquippedProfileItems_t__bindgen_ty_1 = 351;
pub type EquippedProfileItems_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_EquippedProfileItems_t() {
    const UNINIT: ::std::mem::MaybeUninit<EquippedProfileItems_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EquippedProfileItems_t>(),
        20usize,
        concat!("Size of: ", stringify!(EquippedProfileItems_t))
    );
    assert_eq!(
        ::std::mem::align_of::<EquippedProfileItems_t>(),
        4usize,
        concat!("Alignment of ", stringify!(EquippedProfileItems_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EquippedProfileItems_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EquippedProfileItems_t),
            "::",
            stringify!(m_steamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHasAnimatedAvatar) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(EquippedProfileItems_t),
            "::",
            stringify!(m_bHasAnimatedAvatar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHasAvatarFrame) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(EquippedProfileItems_t),
            "::",
            stringify!(m_bHasAvatarFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHasProfileModifier) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(EquippedProfileItems_t),
            "::",
            stringify!(m_bHasProfileModifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHasProfileBackground) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(EquippedProfileItems_t),
            "::",
            stringify!(m_bHasProfileBackground)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHasMiniProfileBackground) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EquippedProfileItems_t),
            "::",
            stringify!(m_bHasMiniProfileBackground)
        )
    );
}
pub const ESteamAPICallFailure_k_ESteamAPICallFailureNone: ESteamAPICallFailure = -1;
pub const ESteamAPICallFailure_k_ESteamAPICallFailureSteamGone: ESteamAPICallFailure = 0;
pub const ESteamAPICallFailure_k_ESteamAPICallFailureNetworkFailure: ESteamAPICallFailure = 1;
pub const ESteamAPICallFailure_k_ESteamAPICallFailureInvalidHandle: ESteamAPICallFailure = 2;
pub const ESteamAPICallFailure_k_ESteamAPICallFailureMismatchedCallback: ESteamAPICallFailure = 3;
pub type ESteamAPICallFailure = ::std::os::raw::c_int;
pub const EGamepadTextInputMode_k_EGamepadTextInputModeNormal: EGamepadTextInputMode = 0;
pub const EGamepadTextInputMode_k_EGamepadTextInputModePassword: EGamepadTextInputMode = 1;
pub type EGamepadTextInputMode = ::std::os::raw::c_int;
pub const EGamepadTextInputLineMode_k_EGamepadTextInputLineModeSingleLine:
    EGamepadTextInputLineMode = 0;
pub const EGamepadTextInputLineMode_k_EGamepadTextInputLineModeMultipleLines:
    EGamepadTextInputLineMode = 1;
pub type EGamepadTextInputLineMode = ::std::os::raw::c_int;
pub const EFloatingGamepadTextInputMode_k_EFloatingGamepadTextInputModeModeSingleLine:
    EFloatingGamepadTextInputMode = 0;
pub const EFloatingGamepadTextInputMode_k_EFloatingGamepadTextInputModeModeMultipleLines:
    EFloatingGamepadTextInputMode = 1;
pub const EFloatingGamepadTextInputMode_k_EFloatingGamepadTextInputModeModeEmail:
    EFloatingGamepadTextInputMode = 2;
pub const EFloatingGamepadTextInputMode_k_EFloatingGamepadTextInputModeModeNumeric:
    EFloatingGamepadTextInputMode = 3;
pub type EFloatingGamepadTextInputMode = ::std::os::raw::c_int;
pub const ETextFilteringContext_k_ETextFilteringContextUnknown: ETextFilteringContext = 0;
pub const ETextFilteringContext_k_ETextFilteringContextGameContent: ETextFilteringContext = 1;
pub const ETextFilteringContext_k_ETextFilteringContextChat: ETextFilteringContext = 2;
pub const ETextFilteringContext_k_ETextFilteringContextName: ETextFilteringContext = 3;
pub type ETextFilteringContext = ::std::os::raw::c_int;
#[repr(C)]
pub struct ISteamUtils__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamUtils {
    pub vtable_: *const ISteamUtils__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamUtils() {
    assert_eq!(
        ::std::mem::size_of::<ISteamUtils>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamUtils))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamUtils>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamUtils))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPCountry_t {
    pub _address: u8,
}
pub const IPCountry_t_k_iCallback: IPCountry_t__bindgen_ty_1 = 701;
pub type IPCountry_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_IPCountry_t() {
    assert_eq!(
        ::std::mem::size_of::<IPCountry_t>(),
        1usize,
        concat!("Size of: ", stringify!(IPCountry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<IPCountry_t>(),
        1usize,
        concat!("Alignment of ", stringify!(IPCountry_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LowBatteryPower_t {
    pub m_nMinutesBatteryLeft: uint8,
}
pub const LowBatteryPower_t_k_iCallback: LowBatteryPower_t__bindgen_ty_1 = 702;
pub type LowBatteryPower_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_LowBatteryPower_t() {
    const UNINIT: ::std::mem::MaybeUninit<LowBatteryPower_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LowBatteryPower_t>(),
        1usize,
        concat!("Size of: ", stringify!(LowBatteryPower_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LowBatteryPower_t>(),
        1usize,
        concat!("Alignment of ", stringify!(LowBatteryPower_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nMinutesBatteryLeft) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LowBatteryPower_t),
            "::",
            stringify!(m_nMinutesBatteryLeft)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamAPICallCompleted_t {
    pub m_hAsyncCall: SteamAPICall_t,
    pub m_iCallback: ::std::os::raw::c_int,
    pub m_cubParam: uint32,
}
pub const SteamAPICallCompleted_t_k_iCallback: SteamAPICallCompleted_t__bindgen_ty_1 = 703;
pub type SteamAPICallCompleted_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamAPICallCompleted_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamAPICallCompleted_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamAPICallCompleted_t>(),
        16usize,
        concat!("Size of: ", stringify!(SteamAPICallCompleted_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamAPICallCompleted_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamAPICallCompleted_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hAsyncCall) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamAPICallCompleted_t),
            "::",
            stringify!(m_hAsyncCall)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iCallback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamAPICallCompleted_t),
            "::",
            stringify!(m_iCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cubParam) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamAPICallCompleted_t),
            "::",
            stringify!(m_cubParam)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamShutdown_t {
    pub _address: u8,
}
pub const SteamShutdown_t_k_iCallback: SteamShutdown_t__bindgen_ty_1 = 704;
pub type SteamShutdown_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamShutdown_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamShutdown_t>(),
        1usize,
        concat!("Size of: ", stringify!(SteamShutdown_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamShutdown_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamShutdown_t))
    );
}
pub const ECheckFileSignature_k_ECheckFileSignatureInvalidSignature: ECheckFileSignature = 0;
pub const ECheckFileSignature_k_ECheckFileSignatureValidSignature: ECheckFileSignature = 1;
pub const ECheckFileSignature_k_ECheckFileSignatureFileNotFound: ECheckFileSignature = 2;
pub const ECheckFileSignature_k_ECheckFileSignatureNoSignaturesFoundForThisApp:
    ECheckFileSignature = 3;
pub const ECheckFileSignature_k_ECheckFileSignatureNoSignaturesFoundForThisFile:
    ECheckFileSignature = 4;
pub type ECheckFileSignature = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CheckFileSignature_t {
    pub m_eCheckFileSignature: ECheckFileSignature,
}
pub const CheckFileSignature_t_k_iCallback: CheckFileSignature_t__bindgen_ty_1 = 705;
pub type CheckFileSignature_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_CheckFileSignature_t() {
    const UNINIT: ::std::mem::MaybeUninit<CheckFileSignature_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CheckFileSignature_t>(),
        4usize,
        concat!("Size of: ", stringify!(CheckFileSignature_t))
    );
    assert_eq!(
        ::std::mem::align_of::<CheckFileSignature_t>(),
        4usize,
        concat!("Alignment of ", stringify!(CheckFileSignature_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eCheckFileSignature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CheckFileSignature_t),
            "::",
            stringify!(m_eCheckFileSignature)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GamepadTextInputDismissed_t {
    pub m_bSubmitted: bool,
    pub m_unSubmittedText: uint32,
    pub m_unAppID: AppId_t,
}
pub const GamepadTextInputDismissed_t_k_iCallback: GamepadTextInputDismissed_t__bindgen_ty_1 = 714;
pub type GamepadTextInputDismissed_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GamepadTextInputDismissed_t() {
    const UNINIT: ::std::mem::MaybeUninit<GamepadTextInputDismissed_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GamepadTextInputDismissed_t>(),
        12usize,
        concat!("Size of: ", stringify!(GamepadTextInputDismissed_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GamepadTextInputDismissed_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GamepadTextInputDismissed_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSubmitted) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GamepadTextInputDismissed_t),
            "::",
            stringify!(m_bSubmitted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unSubmittedText) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GamepadTextInputDismissed_t),
            "::",
            stringify!(m_unSubmittedText)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAppID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GamepadTextInputDismissed_t),
            "::",
            stringify!(m_unAppID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppResumingFromSuspend_t {
    pub _address: u8,
}
pub const AppResumingFromSuspend_t_k_iCallback: AppResumingFromSuspend_t__bindgen_ty_1 = 736;
pub type AppResumingFromSuspend_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_AppResumingFromSuspend_t() {
    assert_eq!(
        ::std::mem::size_of::<AppResumingFromSuspend_t>(),
        1usize,
        concat!("Size of: ", stringify!(AppResumingFromSuspend_t))
    );
    assert_eq!(
        ::std::mem::align_of::<AppResumingFromSuspend_t>(),
        1usize,
        concat!("Alignment of ", stringify!(AppResumingFromSuspend_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FloatingGamepadTextInputDismissed_t {
    pub _address: u8,
}
pub const FloatingGamepadTextInputDismissed_t_k_iCallback:
    FloatingGamepadTextInputDismissed_t__bindgen_ty_1 = 738;
pub type FloatingGamepadTextInputDismissed_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_FloatingGamepadTextInputDismissed_t() {
    assert_eq!(
        ::std::mem::size_of::<FloatingGamepadTextInputDismissed_t>(),
        1usize,
        concat!("Size of: ", stringify!(FloatingGamepadTextInputDismissed_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FloatingGamepadTextInputDismissed_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(FloatingGamepadTextInputDismissed_t)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FilterTextDictionaryChanged_t {
    pub m_eLanguage: ::std::os::raw::c_int,
}
pub const FilterTextDictionaryChanged_t_k_iCallback: FilterTextDictionaryChanged_t__bindgen_ty_1 =
    739;
pub type FilterTextDictionaryChanged_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_FilterTextDictionaryChanged_t() {
    const UNINIT: ::std::mem::MaybeUninit<FilterTextDictionaryChanged_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FilterTextDictionaryChanged_t>(),
        4usize,
        concat!("Size of: ", stringify!(FilterTextDictionaryChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FilterTextDictionaryChanged_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FilterTextDictionaryChanged_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eLanguage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FilterTextDictionaryChanged_t),
            "::",
            stringify!(m_eLanguage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__iobuf() {
    const UNINIT: ::std::mem::MaybeUninit<_iobuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_iobuf>(),
        8usize,
        concat!("Size of: ", stringify!(_iobuf))
    );
    assert_eq!(
        ::std::mem::align_of::<_iobuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_iobuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Placeholder) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_iobuf),
            "::",
            stringify!(_Placeholder)
        )
    );
}
pub type FILE = _iobuf;
extern "C" {
    pub fn __acrt_iob_func(_Ix: ::std::os::raw::c_uint) -> *mut FILE;
}
extern "C" {
    pub fn fgetwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fgetwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(_Character: u16, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwchar(_Character: u16) -> wint_t;
}
extern "C" {
    pub fn getwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fgetws(
        _Buffer: *mut u16,
        _BufferCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut u16;
}
extern "C" {
    pub fn fputws(_Buffer: *const u16, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getws_s(_Buffer: *mut u16, _BufferCount: usize) -> *mut u16;
}
extern "C" {
    pub fn putwc(_Character: u16, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(_Character: u16) -> wint_t;
}
extern "C" {
    pub fn _putws(_Buffer: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _wfdopen(_FileHandle: ::std::os::raw::c_int, _Mode: *const u16) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen(_FileName: *const u16, _Mode: *const u16) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen_s(_Stream: *mut *mut FILE, _FileName: *const u16, _Mode: *const u16) -> errno_t;
}
extern "C" {
    pub fn _wfreopen(_FileName: *const u16, _Mode: *const u16, _OldStream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn _wfreopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const u16,
        _Mode: *const u16,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfsopen(
        _FileName: *const u16,
        _Mode: *const u16,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const u16);
}
extern "C" {
    pub fn _wpopen(_Command: *const u16, _Mode: *const u16) -> *mut FILE;
}
extern "C" {
    pub fn _wremove(_FileName: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtempnam(_Directory: *const u16, _FilePrefix: *const u16) -> *mut u16;
}
extern "C" {
    pub fn _wtmpnam_s(_Buffer: *mut u16, _BufferCount: usize) -> errno_t;
}
extern "C" {
    pub fn _wtmpnam(_Buffer: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _fgetwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwc_nolock(_Character: u16, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _getwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _putwc_nolock(_Character: u16, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _ungetwc_nolock(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn __stdio_common_vfwprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = ::std::os::raw::c_longlong;
extern "C" {
    pub fn _get_stream_buffer_pointers(
        _Stream: *mut FILE,
        _Base: *mut *mut *mut ::std::os::raw::c_char,
        _Pointer: *mut *mut *mut ::std::os::raw::c_char,
        _Count: *mut *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn clearerr_s(_Stream: *mut FILE) -> errno_t;
}
extern "C" {
    pub fn fopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn fread_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn gets_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _Size: rsize_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile_s(_Stream: *mut *mut FILE) -> errno_t;
}
extern "C" {
    pub fn tmpnam_s(_Buffer: *mut ::std::os::raw::c_char, _Size: rsize_t) -> errno_t;
}
extern "C" {
    pub fn clearerr(_Stream: *mut FILE);
}
extern "C" {
    pub fn fclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn feof(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(_Stream: *mut FILE, _Position: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fputc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(
        _Buffer: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fsopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fsetpos(_Stream: *mut FILE, _Position: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fwrite(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn getc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getmaxstdio() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrorMessage: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _pclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _popen(
        _Command: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn putc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(_Buffer: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putw(_Word: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        _OldFileName: *const ::std::os::raw::c_char,
        _NewFileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(_Stream: *mut FILE);
}
extern "C" {
    pub fn _rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(_Stream: *mut FILE, _Buffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _setmaxstdio(_Maximum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setvbuf(
        _Stream: *mut FILE,
        _Buffer: *mut ::std::os::raw::c_char,
        _Mode: ::std::os::raw::c_int,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tempnam(
        _DirectoryName: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _unlock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _fclose_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fflush_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fread_nolock(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_nolock_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fseek_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftell_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _fwrite_nolock(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ungetc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p__commode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_printf_count_output(_Value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_printf_count_output() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _Arglist: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        _Directory: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Format: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(_Ch: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmtmp() -> ::std::os::raw::c_int;
}
pub const k_cbMaxGameServerGameDir: ::std::os::raw::c_int = 32;
pub const k_cbMaxGameServerMapName: ::std::os::raw::c_int = 32;
pub const k_cbMaxGameServerGameDescription: ::std::os::raw::c_int = 64;
pub const k_cbMaxGameServerName: ::std::os::raw::c_int = 64;
pub const k_cbMaxGameServerTags: ::std::os::raw::c_int = 128;
pub const k_cbMaxGameServerGameData: ::std::os::raw::c_int = 2048;
#[doc = " Store key/value pair used in matchmaking queries.\n\n Actually, the name Key/Value is a bit misleading.  The \"key\" is better\n understood as \"filter operation code\" and the \"value\" is the operand to this\n filter operation.  The meaning of the operand depends upon the filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MatchMakingKeyValuePair_t {
    pub m_szKey: [::std::os::raw::c_char; 256usize],
    pub m_szValue: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_MatchMakingKeyValuePair_t() {
    const UNINIT: ::std::mem::MaybeUninit<MatchMakingKeyValuePair_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MatchMakingKeyValuePair_t>(),
        512usize,
        concat!("Size of: ", stringify!(MatchMakingKeyValuePair_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MatchMakingKeyValuePair_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MatchMakingKeyValuePair_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MatchMakingKeyValuePair_t),
            "::",
            stringify!(m_szKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szValue) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(MatchMakingKeyValuePair_t),
            "::",
            stringify!(m_szValue)
        )
    );
}
pub const EMatchMakingServerResponse_eServerResponded: EMatchMakingServerResponse = 0;
pub const EMatchMakingServerResponse_eServerFailedToRespond: EMatchMakingServerResponse = 1;
pub const EMatchMakingServerResponse_eNoServersListedOnMasterServer: EMatchMakingServerResponse = 2;
pub type EMatchMakingServerResponse = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servernetadr_t {
    pub m_usConnectionPort: uint16,
    pub m_usQueryPort: uint16,
    pub m_unIP: uint32,
}
#[test]
fn bindgen_test_layout_servernetadr_t() {
    const UNINIT: ::std::mem::MaybeUninit<servernetadr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<servernetadr_t>(),
        8usize,
        concat!("Size of: ", stringify!(servernetadr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<servernetadr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(servernetadr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usConnectionPort) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(servernetadr_t),
            "::",
            stringify!(m_usConnectionPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usQueryPort) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(servernetadr_t),
            "::",
            stringify!(m_usQueryPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unIP) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(servernetadr_t),
            "::",
            stringify!(m_unIP)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gameserveritem_t {
    #[doc = "< IP/Query Port/Connection Port for this server"]
    pub m_NetAdr: servernetadr_t,
    #[doc = "< current ping time in milliseconds"]
    pub m_nPing: ::std::os::raw::c_int,
    #[doc = "< server has responded successfully in the past"]
    pub m_bHadSuccessfulResponse: bool,
    #[doc = "< server is marked as not responding and should no longer be refreshed"]
    pub m_bDoNotRefresh: bool,
    #[doc = "< current game directory"]
    pub m_szGameDir: [::std::os::raw::c_char; 32usize],
    #[doc = "< current map"]
    pub m_szMap: [::std::os::raw::c_char; 32usize],
    #[doc = "< game description"]
    pub m_szGameDescription: [::std::os::raw::c_char; 64usize],
    #[doc = "< Steam App ID of this server"]
    pub m_nAppID: uint32,
    #[doc = "< total number of players currently on the server.  INCLUDES BOTS!!"]
    pub m_nPlayers: ::std::os::raw::c_int,
    #[doc = "< Maximum players that can join this server"]
    pub m_nMaxPlayers: ::std::os::raw::c_int,
    #[doc = "< Number of bots (i.e simulated players) on this server"]
    pub m_nBotPlayers: ::std::os::raw::c_int,
    #[doc = "< true if this server needs a password to join"]
    pub m_bPassword: bool,
    #[doc = "< Is this server protected by VAC"]
    pub m_bSecure: bool,
    #[doc = "< time (in unix time) when this server was last played on (for favorite/history servers)"]
    pub m_ulTimeLastPlayed: uint32,
    #[doc = "< server version as reported to Steam"]
    pub m_nServerVersion: ::std::os::raw::c_int,
    #[doc = " Game server name"]
    pub m_szServerName: [::std::os::raw::c_char; 64usize],
    #[doc = " the tags this server exposes"]
    pub m_szGameTags: [::std::os::raw::c_char; 128usize],
    #[doc = " steamID of the game server - invalid if it's doesn't have one (old server, or not connected to Steam)"]
    pub m_steamID: CSteamID,
}
#[test]
fn bindgen_test_layout_gameserveritem_t() {
    const UNINIT: ::std::mem::MaybeUninit<gameserveritem_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gameserveritem_t>(),
        372usize,
        concat!("Size of: ", stringify!(gameserveritem_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gameserveritem_t>(),
        4usize,
        concat!("Alignment of ", stringify!(gameserveritem_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_NetAdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_NetAdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPing) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nPing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHadSuccessfulResponse) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_bHadSuccessfulResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bDoNotRefresh) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_bDoNotRefresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szGameDir) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_szGameDir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szMap) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_szMap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szGameDescription) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_szGameDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPlayers) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nPlayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nMaxPlayers) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nMaxPlayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nBotPlayers) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nBotPlayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bPassword) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_bPassword)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSecure) as usize - ptr as usize },
        161usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_bSecure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulTimeLastPlayed) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_ulTimeLastPlayed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nServerVersion) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_nServerVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szServerName) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_szServerName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szGameTags) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_szGameTags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID) as usize - ptr as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(gameserveritem_t),
            "::",
            stringify!(m_steamID)
        )
    );
}
pub const ELobbyType_k_ELobbyTypePrivate: ELobbyType = 0;
pub const ELobbyType_k_ELobbyTypeFriendsOnly: ELobbyType = 1;
pub const ELobbyType_k_ELobbyTypePublic: ELobbyType = 2;
pub const ELobbyType_k_ELobbyTypeInvisible: ELobbyType = 3;
pub const ELobbyType_k_ELobbyTypePrivateUnique: ELobbyType = 4;
pub type ELobbyType = ::std::os::raw::c_int;
pub const ELobbyComparison_k_ELobbyComparisonEqualToOrLessThan: ELobbyComparison = -2;
pub const ELobbyComparison_k_ELobbyComparisonLessThan: ELobbyComparison = -1;
pub const ELobbyComparison_k_ELobbyComparisonEqual: ELobbyComparison = 0;
pub const ELobbyComparison_k_ELobbyComparisonGreaterThan: ELobbyComparison = 1;
pub const ELobbyComparison_k_ELobbyComparisonEqualToOrGreaterThan: ELobbyComparison = 2;
pub const ELobbyComparison_k_ELobbyComparisonNotEqual: ELobbyComparison = 3;
pub type ELobbyComparison = ::std::os::raw::c_int;
pub const ELobbyDistanceFilter_k_ELobbyDistanceFilterClose: ELobbyDistanceFilter = 0;
pub const ELobbyDistanceFilter_k_ELobbyDistanceFilterDefault: ELobbyDistanceFilter = 1;
pub const ELobbyDistanceFilter_k_ELobbyDistanceFilterFar: ELobbyDistanceFilter = 2;
pub const ELobbyDistanceFilter_k_ELobbyDistanceFilterWorldwide: ELobbyDistanceFilter = 3;
pub type ELobbyDistanceFilter = ::std::os::raw::c_int;
#[repr(C)]
pub struct ISteamMatchmaking__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmaking {
    pub vtable_: *const ISteamMatchmaking__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmaking() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmaking>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmaking))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmaking>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMatchmaking))
    );
}
pub type HServerListRequest = *mut ::std::os::raw::c_void;
#[repr(C)]
pub struct ISteamMatchmakingServerListResponse__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmakingServerListResponse {
    pub vtable_: *const ISteamMatchmakingServerListResponse__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmakingServerListResponse() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmakingServerListResponse>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmakingServerListResponse))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmakingServerListResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ISteamMatchmakingServerListResponse)
        )
    );
}
#[repr(C)]
pub struct ISteamMatchmakingPingResponse__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmakingPingResponse {
    pub vtable_: *const ISteamMatchmakingPingResponse__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmakingPingResponse() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmakingPingResponse>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmakingPingResponse))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmakingPingResponse>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMatchmakingPingResponse))
    );
}
#[repr(C)]
pub struct ISteamMatchmakingPlayersResponse__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmakingPlayersResponse {
    pub vtable_: *const ISteamMatchmakingPlayersResponse__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmakingPlayersResponse() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmakingPlayersResponse>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmakingPlayersResponse))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmakingPlayersResponse>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ISteamMatchmakingPlayersResponse)
        )
    );
}
#[repr(C)]
pub struct ISteamMatchmakingRulesResponse__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmakingRulesResponse {
    pub vtable_: *const ISteamMatchmakingRulesResponse__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmakingRulesResponse() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmakingRulesResponse>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmakingRulesResponse))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmakingRulesResponse>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMatchmakingRulesResponse))
    );
}
pub type HServerQuery = ::std::os::raw::c_int;
pub const HSERVERQUERY_INVALID: ::std::os::raw::c_int = -1;
#[repr(C)]
pub struct ISteamMatchmakingServers__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMatchmakingServers {
    pub vtable_: *const ISteamMatchmakingServers__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMatchmakingServers() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMatchmakingServers>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMatchmakingServers))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMatchmakingServers>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMatchmakingServers))
    );
}
pub const k_unFavoriteFlagNone: uint32 = 0;
pub const k_unFavoriteFlagFavorite: uint32 = 1;
pub const k_unFavoriteFlagHistory: uint32 = 2;
pub const EChatMemberStateChange_k_EChatMemberStateChangeEntered: EChatMemberStateChange = 1;
pub const EChatMemberStateChange_k_EChatMemberStateChangeLeft: EChatMemberStateChange = 2;
pub const EChatMemberStateChange_k_EChatMemberStateChangeDisconnected: EChatMemberStateChange = 4;
pub const EChatMemberStateChange_k_EChatMemberStateChangeKicked: EChatMemberStateChange = 8;
pub const EChatMemberStateChange_k_EChatMemberStateChangeBanned: EChatMemberStateChange = 16;
pub type EChatMemberStateChange = ::std::os::raw::c_int;
#[repr(C)]
pub struct ISteamGameSearch__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamGameSearch {
    pub vtable_: *const ISteamGameSearch__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamGameSearch() {
    assert_eq!(
        ::std::mem::size_of::<ISteamGameSearch>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamGameSearch))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamGameSearch>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamGameSearch))
    );
}
pub const ESteamPartyBeaconLocationType_k_ESteamPartyBeaconLocationType_Invalid:
    ESteamPartyBeaconLocationType = 0;
pub const ESteamPartyBeaconLocationType_k_ESteamPartyBeaconLocationType_ChatGroup:
    ESteamPartyBeaconLocationType = 1;
pub const ESteamPartyBeaconLocationType_k_ESteamPartyBeaconLocationType_Max:
    ESteamPartyBeaconLocationType = 2;
pub type ESteamPartyBeaconLocationType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamPartyBeaconLocation_t {
    pub m_eType: ESteamPartyBeaconLocationType,
    pub m_ulLocationID: uint64,
}
#[test]
fn bindgen_test_layout_SteamPartyBeaconLocation_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamPartyBeaconLocation_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamPartyBeaconLocation_t>(),
        16usize,
        concat!("Size of: ", stringify!(SteamPartyBeaconLocation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamPartyBeaconLocation_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamPartyBeaconLocation_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamPartyBeaconLocation_t),
            "::",
            stringify!(m_eType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulLocationID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamPartyBeaconLocation_t),
            "::",
            stringify!(m_ulLocationID)
        )
    );
}
pub const ESteamPartyBeaconLocationData_k_ESteamPartyBeaconLocationDataInvalid:
    ESteamPartyBeaconLocationData = 0;
pub const ESteamPartyBeaconLocationData_k_ESteamPartyBeaconLocationDataName:
    ESteamPartyBeaconLocationData = 1;
pub const ESteamPartyBeaconLocationData_k_ESteamPartyBeaconLocationDataIconURLSmall:
    ESteamPartyBeaconLocationData = 2;
pub const ESteamPartyBeaconLocationData_k_ESteamPartyBeaconLocationDataIconURLMedium:
    ESteamPartyBeaconLocationData = 3;
pub const ESteamPartyBeaconLocationData_k_ESteamPartyBeaconLocationDataIconURLLarge:
    ESteamPartyBeaconLocationData = 4;
pub type ESteamPartyBeaconLocationData = ::std::os::raw::c_int;
#[repr(C)]
pub struct ISteamParties__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamParties {
    pub vtable_: *const ISteamParties__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamParties() {
    assert_eq!(
        ::std::mem::size_of::<ISteamParties>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamParties))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamParties>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamParties))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FavoritesListChanged_t {
    pub m_nIP: uint32,
    pub m_nQueryPort: uint32,
    pub m_nConnPort: uint32,
    pub m_nAppID: uint32,
    pub m_nFlags: uint32,
    pub m_bAdd: bool,
    pub m_unAccountId: AccountID_t,
}
pub const FavoritesListChanged_t_k_iCallback: FavoritesListChanged_t__bindgen_ty_1 = 502;
pub type FavoritesListChanged_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_FavoritesListChanged_t() {
    const UNINIT: ::std::mem::MaybeUninit<FavoritesListChanged_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FavoritesListChanged_t>(),
        28usize,
        concat!("Size of: ", stringify!(FavoritesListChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FavoritesListChanged_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FavoritesListChanged_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nIP) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FavoritesListChanged_t),
            "::",
            stringify!(m_nIP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nQueryPort) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FavoritesListChanged_t),
            "::",
            stringify!(m_nQueryPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nConnPort) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FavoritesListChanged_t),
            "::",
            stringify!(m_nConnPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FavoritesListChanged_t),
            "::",
            stringify!(m_nAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nFlags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FavoritesListChanged_t),
            "::",
            stringify!(m_nFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAdd) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FavoritesListChanged_t),
            "::",
            stringify!(m_bAdd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAccountId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FavoritesListChanged_t),
            "::",
            stringify!(m_unAccountId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LobbyInvite_t {
    pub m_ulSteamIDUser: uint64,
    pub m_ulSteamIDLobby: uint64,
    pub m_ulGameID: uint64,
}
pub const LobbyInvite_t_k_iCallback: LobbyInvite_t__bindgen_ty_1 = 503;
pub type LobbyInvite_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_LobbyInvite_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyInvite_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyInvite_t>(),
        24usize,
        concat!("Size of: ", stringify!(LobbyInvite_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyInvite_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LobbyInvite_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDUser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyInvite_t),
            "::",
            stringify!(m_ulSteamIDUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDLobby) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyInvite_t),
            "::",
            stringify!(m_ulSteamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulGameID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyInvite_t),
            "::",
            stringify!(m_ulGameID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LobbyEnter_t {
    pub m_ulSteamIDLobby: uint64,
    pub m_rgfChatPermissions: uint32,
    pub m_bLocked: bool,
    pub m_EChatRoomEnterResponse: uint32,
}
pub const LobbyEnter_t_k_iCallback: LobbyEnter_t__bindgen_ty_1 = 504;
pub type LobbyEnter_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_LobbyEnter_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyEnter_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyEnter_t>(),
        24usize,
        concat!("Size of: ", stringify!(LobbyEnter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyEnter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LobbyEnter_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDLobby) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyEnter_t),
            "::",
            stringify!(m_ulSteamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgfChatPermissions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyEnter_t),
            "::",
            stringify!(m_rgfChatPermissions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bLocked) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyEnter_t),
            "::",
            stringify!(m_bLocked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_EChatRoomEnterResponse) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyEnter_t),
            "::",
            stringify!(m_EChatRoomEnterResponse)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LobbyDataUpdate_t {
    pub m_ulSteamIDLobby: uint64,
    pub m_ulSteamIDMember: uint64,
    pub m_bSuccess: uint8,
}
pub const LobbyDataUpdate_t_k_iCallback: LobbyDataUpdate_t__bindgen_ty_1 = 505;
pub type LobbyDataUpdate_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_LobbyDataUpdate_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyDataUpdate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyDataUpdate_t>(),
        24usize,
        concat!("Size of: ", stringify!(LobbyDataUpdate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyDataUpdate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LobbyDataUpdate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDLobby) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyDataUpdate_t),
            "::",
            stringify!(m_ulSteamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDMember) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyDataUpdate_t),
            "::",
            stringify!(m_ulSteamIDMember)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSuccess) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyDataUpdate_t),
            "::",
            stringify!(m_bSuccess)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LobbyChatUpdate_t {
    pub m_ulSteamIDLobby: uint64,
    pub m_ulSteamIDUserChanged: uint64,
    pub m_ulSteamIDMakingChange: uint64,
    pub m_rgfChatMemberStateChange: uint32,
}
pub const LobbyChatUpdate_t_k_iCallback: LobbyChatUpdate_t__bindgen_ty_1 = 506;
pub type LobbyChatUpdate_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_LobbyChatUpdate_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyChatUpdate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyChatUpdate_t>(),
        32usize,
        concat!("Size of: ", stringify!(LobbyChatUpdate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyChatUpdate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LobbyChatUpdate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDLobby) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyChatUpdate_t),
            "::",
            stringify!(m_ulSteamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDUserChanged) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyChatUpdate_t),
            "::",
            stringify!(m_ulSteamIDUserChanged)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDMakingChange) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyChatUpdate_t),
            "::",
            stringify!(m_ulSteamIDMakingChange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgfChatMemberStateChange) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyChatUpdate_t),
            "::",
            stringify!(m_rgfChatMemberStateChange)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LobbyChatMsg_t {
    pub m_ulSteamIDLobby: uint64,
    pub m_ulSteamIDUser: uint64,
    pub m_eChatEntryType: uint8,
    pub m_iChatID: uint32,
}
pub const LobbyChatMsg_t_k_iCallback: LobbyChatMsg_t__bindgen_ty_1 = 507;
pub type LobbyChatMsg_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_LobbyChatMsg_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyChatMsg_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyChatMsg_t>(),
        24usize,
        concat!("Size of: ", stringify!(LobbyChatMsg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyChatMsg_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LobbyChatMsg_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDLobby) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyChatMsg_t),
            "::",
            stringify!(m_ulSteamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDUser) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyChatMsg_t),
            "::",
            stringify!(m_ulSteamIDUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eChatEntryType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyChatMsg_t),
            "::",
            stringify!(m_eChatEntryType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iChatID) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyChatMsg_t),
            "::",
            stringify!(m_iChatID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LobbyGameCreated_t {
    pub m_ulSteamIDLobby: uint64,
    pub m_ulSteamIDGameServer: uint64,
    pub m_unIP: uint32,
    pub m_usPort: uint16,
}
pub const LobbyGameCreated_t_k_iCallback: LobbyGameCreated_t__bindgen_ty_1 = 509;
pub type LobbyGameCreated_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_LobbyGameCreated_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyGameCreated_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyGameCreated_t>(),
        24usize,
        concat!("Size of: ", stringify!(LobbyGameCreated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyGameCreated_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LobbyGameCreated_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDLobby) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyGameCreated_t),
            "::",
            stringify!(m_ulSteamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDGameServer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyGameCreated_t),
            "::",
            stringify!(m_ulSteamIDGameServer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unIP) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyGameCreated_t),
            "::",
            stringify!(m_unIP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usPort) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyGameCreated_t),
            "::",
            stringify!(m_usPort)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LobbyMatchList_t {
    pub m_nLobbiesMatching: uint32,
}
pub const LobbyMatchList_t_k_iCallback: LobbyMatchList_t__bindgen_ty_1 = 510;
pub type LobbyMatchList_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_LobbyMatchList_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyMatchList_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyMatchList_t>(),
        4usize,
        concat!("Size of: ", stringify!(LobbyMatchList_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyMatchList_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LobbyMatchList_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nLobbiesMatching) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyMatchList_t),
            "::",
            stringify!(m_nLobbiesMatching)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LobbyKicked_t {
    pub m_ulSteamIDLobby: uint64,
    pub m_ulSteamIDAdmin: uint64,
    pub m_bKickedDueToDisconnect: uint8,
}
pub const LobbyKicked_t_k_iCallback: LobbyKicked_t__bindgen_ty_1 = 512;
pub type LobbyKicked_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_LobbyKicked_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyKicked_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyKicked_t>(),
        24usize,
        concat!("Size of: ", stringify!(LobbyKicked_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyKicked_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LobbyKicked_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDLobby) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyKicked_t),
            "::",
            stringify!(m_ulSteamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDAdmin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyKicked_t),
            "::",
            stringify!(m_ulSteamIDAdmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bKickedDueToDisconnect) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyKicked_t),
            "::",
            stringify!(m_bKickedDueToDisconnect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LobbyCreated_t {
    pub m_eResult: EResult,
    pub m_ulSteamIDLobby: uint64,
}
pub const LobbyCreated_t_k_iCallback: LobbyCreated_t__bindgen_ty_1 = 513;
pub type LobbyCreated_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_LobbyCreated_t() {
    const UNINIT: ::std::mem::MaybeUninit<LobbyCreated_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LobbyCreated_t>(),
        16usize,
        concat!("Size of: ", stringify!(LobbyCreated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LobbyCreated_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LobbyCreated_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyCreated_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDLobby) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LobbyCreated_t),
            "::",
            stringify!(m_ulSteamIDLobby)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PSNGameBootInviteResult_t {
    pub m_bGameBootInviteExists: bool,
    pub m_steamIDLobby: CSteamID,
}
pub const PSNGameBootInviteResult_t_k_iCallback: PSNGameBootInviteResult_t__bindgen_ty_1 = 515;
pub type PSNGameBootInviteResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_PSNGameBootInviteResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<PSNGameBootInviteResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PSNGameBootInviteResult_t>(),
        9usize,
        concat!("Size of: ", stringify!(PSNGameBootInviteResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<PSNGameBootInviteResult_t>(),
        1usize,
        concat!("Alignment of ", stringify!(PSNGameBootInviteResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bGameBootInviteExists) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PSNGameBootInviteResult_t),
            "::",
            stringify!(m_bGameBootInviteExists)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDLobby) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(PSNGameBootInviteResult_t),
            "::",
            stringify!(m_steamIDLobby)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FavoritesListAccountsUpdated_t {
    pub m_eResult: EResult,
}
pub const FavoritesListAccountsUpdated_t_k_iCallback: FavoritesListAccountsUpdated_t__bindgen_ty_1 =
    516;
pub type FavoritesListAccountsUpdated_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_FavoritesListAccountsUpdated_t() {
    const UNINIT: ::std::mem::MaybeUninit<FavoritesListAccountsUpdated_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FavoritesListAccountsUpdated_t>(),
        4usize,
        concat!("Size of: ", stringify!(FavoritesListAccountsUpdated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FavoritesListAccountsUpdated_t>(),
        4usize,
        concat!("Alignment of ", stringify!(FavoritesListAccountsUpdated_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FavoritesListAccountsUpdated_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SearchForGameProgressCallback_t {
    pub m_ullSearchID: uint64,
    pub m_eResult: EResult,
    pub m_lobbyID: CSteamID,
    pub m_steamIDEndedSearch: CSteamID,
    pub m_nSecondsRemainingEstimate: int32,
    pub m_cPlayersSearching: int32,
}
pub const SearchForGameProgressCallback_t_k_iCallback:
    SearchForGameProgressCallback_t__bindgen_ty_1 = 5201;
pub type SearchForGameProgressCallback_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SearchForGameProgressCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<SearchForGameProgressCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SearchForGameProgressCallback_t>(),
        40usize,
        concat!("Size of: ", stringify!(SearchForGameProgressCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SearchForGameProgressCallback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SearchForGameProgressCallback_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ullSearchID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameProgressCallback_t),
            "::",
            stringify!(m_ullSearchID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameProgressCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_lobbyID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameProgressCallback_t),
            "::",
            stringify!(m_lobbyID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDEndedSearch) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameProgressCallback_t),
            "::",
            stringify!(m_steamIDEndedSearch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nSecondsRemainingEstimate) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameProgressCallback_t),
            "::",
            stringify!(m_nSecondsRemainingEstimate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cPlayersSearching) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameProgressCallback_t),
            "::",
            stringify!(m_cPlayersSearching)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SearchForGameResultCallback_t {
    pub m_ullSearchID: uint64,
    pub m_eResult: EResult,
    pub m_nCountPlayersInGame: int32,
    pub m_nCountAcceptedGame: int32,
    pub m_steamIDHost: CSteamID,
    pub m_bFinalCallback: bool,
}
pub const SearchForGameResultCallback_t_k_iCallback: SearchForGameResultCallback_t__bindgen_ty_1 =
    5202;
pub type SearchForGameResultCallback_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SearchForGameResultCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<SearchForGameResultCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SearchForGameResultCallback_t>(),
        32usize,
        concat!("Size of: ", stringify!(SearchForGameResultCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SearchForGameResultCallback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SearchForGameResultCallback_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ullSearchID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameResultCallback_t),
            "::",
            stringify!(m_ullSearchID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameResultCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCountPlayersInGame) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameResultCallback_t),
            "::",
            stringify!(m_nCountPlayersInGame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCountAcceptedGame) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameResultCallback_t),
            "::",
            stringify!(m_nCountAcceptedGame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDHost) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameResultCallback_t),
            "::",
            stringify!(m_steamIDHost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bFinalCallback) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SearchForGameResultCallback_t),
            "::",
            stringify!(m_bFinalCallback)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RequestPlayersForGameProgressCallback_t {
    pub m_eResult: EResult,
    pub m_ullSearchID: uint64,
}
pub const RequestPlayersForGameProgressCallback_t_k_iCallback:
    RequestPlayersForGameProgressCallback_t__bindgen_ty_1 = 5211;
pub type RequestPlayersForGameProgressCallback_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RequestPlayersForGameProgressCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<RequestPlayersForGameProgressCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RequestPlayersForGameProgressCallback_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(RequestPlayersForGameProgressCallback_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RequestPlayersForGameProgressCallback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RequestPlayersForGameProgressCallback_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameProgressCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ullSearchID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameProgressCallback_t),
            "::",
            stringify!(m_ullSearchID)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RequestPlayersForGameResultCallback_t {
    pub m_eResult: EResult,
    pub m_ullSearchID: uint64,
    pub m_SteamIDPlayerFound: CSteamID,
    pub m_SteamIDLobby: CSteamID,
    pub m_ePlayerAcceptState: RequestPlayersForGameResultCallback_t_PlayerAcceptState_t,
    pub m_nPlayerIndex: int32,
    pub m_nTotalPlayersFound: int32,
    pub m_nTotalPlayersAcceptedGame: int32,
    pub m_nSuggestedTeamIndex: int32,
    pub m_ullUniqueGameID: uint64,
}
pub const RequestPlayersForGameResultCallback_t_k_iCallback:
    RequestPlayersForGameResultCallback_t__bindgen_ty_1 = 5212;
pub type RequestPlayersForGameResultCallback_t__bindgen_ty_1 = ::std::os::raw::c_int;
pub const RequestPlayersForGameResultCallback_t_PlayerAcceptState_t_k_EStateUnknown:
    RequestPlayersForGameResultCallback_t_PlayerAcceptState_t = 0;
pub const RequestPlayersForGameResultCallback_t_PlayerAcceptState_t_k_EStatePlayerAccepted:
    RequestPlayersForGameResultCallback_t_PlayerAcceptState_t = 1;
pub const RequestPlayersForGameResultCallback_t_PlayerAcceptState_t_k_EStatePlayerDeclined:
    RequestPlayersForGameResultCallback_t_PlayerAcceptState_t = 2;
pub type RequestPlayersForGameResultCallback_t_PlayerAcceptState_t = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RequestPlayersForGameResultCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<RequestPlayersForGameResultCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RequestPlayersForGameResultCallback_t>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(RequestPlayersForGameResultCallback_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RequestPlayersForGameResultCallback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RequestPlayersForGameResultCallback_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ullSearchID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_ullSearchID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamIDPlayerFound) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_SteamIDPlayerFound)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamIDLobby) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_SteamIDLobby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ePlayerAcceptState) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_ePlayerAcceptState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPlayerIndex) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_nPlayerIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalPlayersFound) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_nTotalPlayersFound)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalPlayersAcceptedGame) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_nTotalPlayersAcceptedGame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nSuggestedTeamIndex) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_nSuggestedTeamIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ullUniqueGameID) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameResultCallback_t),
            "::",
            stringify!(m_ullUniqueGameID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RequestPlayersForGameFinalResultCallback_t {
    pub m_eResult: EResult,
    pub m_ullSearchID: uint64,
    pub m_ullUniqueGameID: uint64,
}
pub const RequestPlayersForGameFinalResultCallback_t_k_iCallback:
    RequestPlayersForGameFinalResultCallback_t__bindgen_ty_1 = 5213;
pub type RequestPlayersForGameFinalResultCallback_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RequestPlayersForGameFinalResultCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<RequestPlayersForGameFinalResultCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RequestPlayersForGameFinalResultCallback_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(RequestPlayersForGameFinalResultCallback_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RequestPlayersForGameFinalResultCallback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RequestPlayersForGameFinalResultCallback_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameFinalResultCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ullSearchID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameFinalResultCallback_t),
            "::",
            stringify!(m_ullSearchID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ullUniqueGameID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RequestPlayersForGameFinalResultCallback_t),
            "::",
            stringify!(m_ullUniqueGameID)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SubmitPlayerResultResultCallback_t {
    pub m_eResult: EResult,
    pub ullUniqueGameID: uint64,
    pub steamIDPlayer: CSteamID,
}
pub const SubmitPlayerResultResultCallback_t_k_iCallback:
    SubmitPlayerResultResultCallback_t__bindgen_ty_1 = 5214;
pub type SubmitPlayerResultResultCallback_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SubmitPlayerResultResultCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<SubmitPlayerResultResultCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SubmitPlayerResultResultCallback_t>(),
        24usize,
        concat!("Size of: ", stringify!(SubmitPlayerResultResultCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SubmitPlayerResultResultCallback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SubmitPlayerResultResultCallback_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubmitPlayerResultResultCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ullUniqueGameID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubmitPlayerResultResultCallback_t),
            "::",
            stringify!(ullUniqueGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).steamIDPlayer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubmitPlayerResultResultCallback_t),
            "::",
            stringify!(steamIDPlayer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EndGameResultCallback_t {
    pub m_eResult: EResult,
    pub ullUniqueGameID: uint64,
}
pub const EndGameResultCallback_t_k_iCallback: EndGameResultCallback_t__bindgen_ty_1 = 5215;
pub type EndGameResultCallback_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_EndGameResultCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<EndGameResultCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EndGameResultCallback_t>(),
        16usize,
        concat!("Size of: ", stringify!(EndGameResultCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<EndGameResultCallback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(EndGameResultCallback_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EndGameResultCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ullUniqueGameID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EndGameResultCallback_t),
            "::",
            stringify!(ullUniqueGameID)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JoinPartyCallback_t {
    pub m_eResult: EResult,
    pub m_ulBeaconID: PartyBeaconID_t,
    pub m_SteamIDBeaconOwner: CSteamID,
    pub m_rgchConnectString: [::std::os::raw::c_char; 256usize],
}
pub const JoinPartyCallback_t_k_iCallback: JoinPartyCallback_t__bindgen_ty_1 = 5301;
pub type JoinPartyCallback_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_JoinPartyCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<JoinPartyCallback_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JoinPartyCallback_t>(),
        280usize,
        concat!("Size of: ", stringify!(JoinPartyCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<JoinPartyCallback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(JoinPartyCallback_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinPartyCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulBeaconID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinPartyCallback_t),
            "::",
            stringify!(m_ulBeaconID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamIDBeaconOwner) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinPartyCallback_t),
            "::",
            stringify!(m_SteamIDBeaconOwner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchConnectString) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinPartyCallback_t),
            "::",
            stringify!(m_rgchConnectString)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateBeaconCallback_t {
    pub m_eResult: EResult,
    pub m_ulBeaconID: PartyBeaconID_t,
}
pub const CreateBeaconCallback_t_k_iCallback: CreateBeaconCallback_t__bindgen_ty_1 = 5302;
pub type CreateBeaconCallback_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_CreateBeaconCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<CreateBeaconCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CreateBeaconCallback_t>(),
        16usize,
        concat!("Size of: ", stringify!(CreateBeaconCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateBeaconCallback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateBeaconCallback_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateBeaconCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulBeaconID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateBeaconCallback_t),
            "::",
            stringify!(m_ulBeaconID)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ReservationNotificationCallback_t {
    pub m_ulBeaconID: PartyBeaconID_t,
    pub m_steamIDJoiner: CSteamID,
}
pub const ReservationNotificationCallback_t_k_iCallback:
    ReservationNotificationCallback_t__bindgen_ty_1 = 5303;
pub type ReservationNotificationCallback_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_ReservationNotificationCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<ReservationNotificationCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ReservationNotificationCallback_t>(),
        16usize,
        concat!("Size of: ", stringify!(ReservationNotificationCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ReservationNotificationCallback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ReservationNotificationCallback_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulBeaconID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ReservationNotificationCallback_t),
            "::",
            stringify!(m_ulBeaconID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDJoiner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ReservationNotificationCallback_t),
            "::",
            stringify!(m_steamIDJoiner)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChangeNumOpenSlotsCallback_t {
    pub m_eResult: EResult,
}
pub const ChangeNumOpenSlotsCallback_t_k_iCallback: ChangeNumOpenSlotsCallback_t__bindgen_ty_1 =
    5304;
pub type ChangeNumOpenSlotsCallback_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_ChangeNumOpenSlotsCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<ChangeNumOpenSlotsCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ChangeNumOpenSlotsCallback_t>(),
        4usize,
        concat!("Size of: ", stringify!(ChangeNumOpenSlotsCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ChangeNumOpenSlotsCallback_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ChangeNumOpenSlotsCallback_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChangeNumOpenSlotsCallback_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AvailableBeaconLocationsUpdated_t {
    pub _address: u8,
}
pub const AvailableBeaconLocationsUpdated_t_k_iCallback:
    AvailableBeaconLocationsUpdated_t__bindgen_ty_1 = 5305;
pub type AvailableBeaconLocationsUpdated_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_AvailableBeaconLocationsUpdated_t() {
    assert_eq!(
        ::std::mem::size_of::<AvailableBeaconLocationsUpdated_t>(),
        1usize,
        concat!("Size of: ", stringify!(AvailableBeaconLocationsUpdated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<AvailableBeaconLocationsUpdated_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(AvailableBeaconLocationsUpdated_t)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ActiveBeaconsUpdated_t {
    pub _address: u8,
}
pub const ActiveBeaconsUpdated_t_k_iCallback: ActiveBeaconsUpdated_t__bindgen_ty_1 = 5306;
pub type ActiveBeaconsUpdated_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_ActiveBeaconsUpdated_t() {
    assert_eq!(
        ::std::mem::size_of::<ActiveBeaconsUpdated_t>(),
        1usize,
        concat!("Size of: ", stringify!(ActiveBeaconsUpdated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ActiveBeaconsUpdated_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ActiveBeaconsUpdated_t))
    );
}
pub const k_unMaxCloudFileChunkSize: uint32 = 104857600;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamParamStringArray_t {
    pub m_ppStrings: *mut *const ::std::os::raw::c_char,
    pub m_nNumStrings: int32,
}
#[test]
fn bindgen_test_layout_SteamParamStringArray_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamParamStringArray_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamParamStringArray_t>(),
        16usize,
        concat!("Size of: ", stringify!(SteamParamStringArray_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamParamStringArray_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamParamStringArray_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ppStrings) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamParamStringArray_t),
            "::",
            stringify!(m_ppStrings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nNumStrings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamParamStringArray_t),
            "::",
            stringify!(m_nNumStrings)
        )
    );
}
pub type UGCHandle_t = uint64;
pub type PublishedFileUpdateHandle_t = uint64;
pub type PublishedFileId_t = uint64;
pub const k_PublishedFileIdInvalid: PublishedFileId_t = 0;
pub const k_UGCHandleInvalid: UGCHandle_t = 18446744073709551615;
pub const k_PublishedFileUpdateHandleInvalid: PublishedFileUpdateHandle_t = 18446744073709551615;
pub type UGCFileWriteStreamHandle_t = uint64;
pub const k_UGCFileStreamHandleInvalid: UGCFileWriteStreamHandle_t = 18446744073709551615;
pub const k_cchPublishedDocumentTitleMax: uint32 = 129;
pub const k_cchPublishedDocumentDescriptionMax: uint32 = 8000;
pub const k_cchPublishedDocumentChangeDescriptionMax: uint32 = 8000;
pub const k_unEnumeratePublishedFilesMaxResults: uint32 = 50;
pub const k_cchTagListMax: uint32 = 1025;
pub const k_cchFilenameMax: uint32 = 260;
pub const k_cchPublishedFileURLMax: uint32 = 256;
pub const ERemoteStoragePlatform_k_ERemoteStoragePlatformNone: ERemoteStoragePlatform = 0;
pub const ERemoteStoragePlatform_k_ERemoteStoragePlatformWindows: ERemoteStoragePlatform = 1;
pub const ERemoteStoragePlatform_k_ERemoteStoragePlatformOSX: ERemoteStoragePlatform = 2;
pub const ERemoteStoragePlatform_k_ERemoteStoragePlatformPS3: ERemoteStoragePlatform = 4;
pub const ERemoteStoragePlatform_k_ERemoteStoragePlatformLinux: ERemoteStoragePlatform = 8;
pub const ERemoteStoragePlatform_k_ERemoteStoragePlatformSwitch: ERemoteStoragePlatform = 16;
pub const ERemoteStoragePlatform_k_ERemoteStoragePlatformAndroid: ERemoteStoragePlatform = 32;
pub const ERemoteStoragePlatform_k_ERemoteStoragePlatformIOS: ERemoteStoragePlatform = 64;
pub const ERemoteStoragePlatform_k_ERemoteStoragePlatformAll: ERemoteStoragePlatform = -1;
pub type ERemoteStoragePlatform = ::std::os::raw::c_int;
pub const ERemoteStoragePublishedFileVisibility_k_ERemoteStoragePublishedFileVisibilityPublic:
    ERemoteStoragePublishedFileVisibility = 0;
pub const ERemoteStoragePublishedFileVisibility_k_ERemoteStoragePublishedFileVisibilityFriendsOnly : ERemoteStoragePublishedFileVisibility = 1 ;
pub const ERemoteStoragePublishedFileVisibility_k_ERemoteStoragePublishedFileVisibilityPrivate:
    ERemoteStoragePublishedFileVisibility = 2;
pub const ERemoteStoragePublishedFileVisibility_k_ERemoteStoragePublishedFileVisibilityUnlisted:
    ERemoteStoragePublishedFileVisibility = 3;
pub type ERemoteStoragePublishedFileVisibility = ::std::os::raw::c_int;
pub const EWorkshopFileType_k_EWorkshopFileTypeFirst: EWorkshopFileType = 0;
pub const EWorkshopFileType_k_EWorkshopFileTypeCommunity: EWorkshopFileType = 0;
pub const EWorkshopFileType_k_EWorkshopFileTypeMicrotransaction: EWorkshopFileType = 1;
pub const EWorkshopFileType_k_EWorkshopFileTypeCollection: EWorkshopFileType = 2;
pub const EWorkshopFileType_k_EWorkshopFileTypeArt: EWorkshopFileType = 3;
pub const EWorkshopFileType_k_EWorkshopFileTypeVideo: EWorkshopFileType = 4;
pub const EWorkshopFileType_k_EWorkshopFileTypeScreenshot: EWorkshopFileType = 5;
pub const EWorkshopFileType_k_EWorkshopFileTypeGame: EWorkshopFileType = 6;
pub const EWorkshopFileType_k_EWorkshopFileTypeSoftware: EWorkshopFileType = 7;
pub const EWorkshopFileType_k_EWorkshopFileTypeConcept: EWorkshopFileType = 8;
pub const EWorkshopFileType_k_EWorkshopFileTypeWebGuide: EWorkshopFileType = 9;
pub const EWorkshopFileType_k_EWorkshopFileTypeIntegratedGuide: EWorkshopFileType = 10;
pub const EWorkshopFileType_k_EWorkshopFileTypeMerch: EWorkshopFileType = 11;
pub const EWorkshopFileType_k_EWorkshopFileTypeControllerBinding: EWorkshopFileType = 12;
pub const EWorkshopFileType_k_EWorkshopFileTypeSteamworksAccessInvite: EWorkshopFileType = 13;
pub const EWorkshopFileType_k_EWorkshopFileTypeSteamVideo: EWorkshopFileType = 14;
pub const EWorkshopFileType_k_EWorkshopFileTypeGameManagedItem: EWorkshopFileType = 15;
pub const EWorkshopFileType_k_EWorkshopFileTypeClip: EWorkshopFileType = 16;
pub const EWorkshopFileType_k_EWorkshopFileTypeMax: EWorkshopFileType = 17;
pub type EWorkshopFileType = ::std::os::raw::c_int;
pub const EWorkshopVote_k_EWorkshopVoteUnvoted: EWorkshopVote = 0;
pub const EWorkshopVote_k_EWorkshopVoteFor: EWorkshopVote = 1;
pub const EWorkshopVote_k_EWorkshopVoteAgainst: EWorkshopVote = 2;
pub const EWorkshopVote_k_EWorkshopVoteLater: EWorkshopVote = 3;
pub type EWorkshopVote = ::std::os::raw::c_int;
pub const EWorkshopFileAction_k_EWorkshopFileActionPlayed: EWorkshopFileAction = 0;
pub const EWorkshopFileAction_k_EWorkshopFileActionCompleted: EWorkshopFileAction = 1;
pub type EWorkshopFileAction = ::std::os::raw::c_int;
pub const EWorkshopEnumerationType_k_EWorkshopEnumerationTypeRankedByVote:
    EWorkshopEnumerationType = 0;
pub const EWorkshopEnumerationType_k_EWorkshopEnumerationTypeRecent: EWorkshopEnumerationType = 1;
pub const EWorkshopEnumerationType_k_EWorkshopEnumerationTypeTrending: EWorkshopEnumerationType = 2;
pub const EWorkshopEnumerationType_k_EWorkshopEnumerationTypeFavoritesOfFriends:
    EWorkshopEnumerationType = 3;
pub const EWorkshopEnumerationType_k_EWorkshopEnumerationTypeVotedByFriends:
    EWorkshopEnumerationType = 4;
pub const EWorkshopEnumerationType_k_EWorkshopEnumerationTypeContentByFriends:
    EWorkshopEnumerationType = 5;
pub const EWorkshopEnumerationType_k_EWorkshopEnumerationTypeRecentFromFollowedUsers:
    EWorkshopEnumerationType = 6;
pub type EWorkshopEnumerationType = ::std::os::raw::c_int;
pub const EWorkshopVideoProvider_k_EWorkshopVideoProviderNone: EWorkshopVideoProvider = 0;
pub const EWorkshopVideoProvider_k_EWorkshopVideoProviderYoutube: EWorkshopVideoProvider = 1;
pub type EWorkshopVideoProvider = ::std::os::raw::c_int;
pub const EUGCReadAction_k_EUGCRead_ContinueReadingUntilFinished: EUGCReadAction = 0;
pub const EUGCReadAction_k_EUGCRead_ContinueReading: EUGCReadAction = 1;
pub const EUGCReadAction_k_EUGCRead_Close: EUGCReadAction = 2;
pub type EUGCReadAction = ::std::os::raw::c_int;
pub const ERemoteStorageLocalFileChange_k_ERemoteStorageLocalFileChange_Invalid:
    ERemoteStorageLocalFileChange = 0;
pub const ERemoteStorageLocalFileChange_k_ERemoteStorageLocalFileChange_FileUpdated:
    ERemoteStorageLocalFileChange = 1;
pub const ERemoteStorageLocalFileChange_k_ERemoteStorageLocalFileChange_FileDeleted:
    ERemoteStorageLocalFileChange = 2;
pub type ERemoteStorageLocalFileChange = ::std::os::raw::c_int;
pub const ERemoteStorageFilePathType_k_ERemoteStorageFilePathType_Invalid:
    ERemoteStorageFilePathType = 0;
pub const ERemoteStorageFilePathType_k_ERemoteStorageFilePathType_Absolute:
    ERemoteStorageFilePathType = 1;
pub const ERemoteStorageFilePathType_k_ERemoteStorageFilePathType_APIFilename:
    ERemoteStorageFilePathType = 2;
pub type ERemoteStorageFilePathType = ::std::os::raw::c_int;
#[repr(C)]
pub struct ISteamRemoteStorage__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamRemoteStorage {
    pub vtable_: *const ISteamRemoteStorage__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamRemoteStorage() {
    assert_eq!(
        ::std::mem::size_of::<ISteamRemoteStorage>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamRemoteStorage))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamRemoteStorage>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamRemoteStorage))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageFileShareResult_t {
    pub m_eResult: EResult,
    pub m_hFile: UGCHandle_t,
    pub m_rgchFilename: [::std::os::raw::c_char; 260usize],
}
pub const RemoteStorageFileShareResult_t_k_iCallback: RemoteStorageFileShareResult_t__bindgen_ty_1 =
    1307;
pub type RemoteStorageFileShareResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageFileShareResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageFileShareResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageFileShareResult_t>(),
        280usize,
        concat!("Size of: ", stringify!(RemoteStorageFileShareResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageFileShareResult_t>(),
        8usize,
        concat!("Alignment of ", stringify!(RemoteStorageFileShareResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageFileShareResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hFile) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageFileShareResult_t),
            "::",
            stringify!(m_hFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchFilename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageFileShareResult_t),
            "::",
            stringify!(m_rgchFilename)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStoragePublishFileResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_bUserNeedsToAcceptWorkshopLegalAgreement: bool,
}
pub const RemoteStoragePublishFileResult_t_k_iCallback:
    RemoteStoragePublishFileResult_t__bindgen_ty_1 = 1309;
pub type RemoteStoragePublishFileResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStoragePublishFileResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStoragePublishFileResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStoragePublishFileResult_t>(),
        24usize,
        concat!("Size of: ", stringify!(RemoteStoragePublishFileResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStoragePublishFileResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStoragePublishFileResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishFileResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishFileResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_bUserNeedsToAcceptWorkshopLegalAgreement) as usize
                - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishFileResult_t),
            "::",
            stringify!(m_bUserNeedsToAcceptWorkshopLegalAgreement)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageDeletePublishedFileResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
}
pub const RemoteStorageDeletePublishedFileResult_t_k_iCallback:
    RemoteStorageDeletePublishedFileResult_t__bindgen_ty_1 = 1311;
pub type RemoteStorageDeletePublishedFileResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageDeletePublishedFileResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageDeletePublishedFileResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageDeletePublishedFileResult_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageDeletePublishedFileResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageDeletePublishedFileResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageDeletePublishedFileResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageDeletePublishedFileResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageDeletePublishedFileResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageEnumerateUserPublishedFilesResult_t {
    pub m_eResult: EResult,
    pub m_nResultsReturned: int32,
    pub m_nTotalResultCount: int32,
    pub m_rgPublishedFileId: [PublishedFileId_t; 50usize],
}
pub const RemoteStorageEnumerateUserPublishedFilesResult_t_k_iCallback:
    RemoteStorageEnumerateUserPublishedFilesResult_t__bindgen_ty_1 = 1312;
pub type RemoteStorageEnumerateUserPublishedFilesResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageEnumerateUserPublishedFilesResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageEnumerateUserPublishedFilesResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageEnumerateUserPublishedFilesResult_t>(),
        416usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageEnumerateUserPublishedFilesResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageEnumerateUserPublishedFilesResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageEnumerateUserPublishedFilesResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserPublishedFilesResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nResultsReturned) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserPublishedFilesResult_t),
            "::",
            stringify!(m_nResultsReturned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalResultCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserPublishedFilesResult_t),
            "::",
            stringify!(m_nTotalResultCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgPublishedFileId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserPublishedFilesResult_t),
            "::",
            stringify!(m_rgPublishedFileId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageSubscribePublishedFileResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
}
pub const RemoteStorageSubscribePublishedFileResult_t_k_iCallback:
    RemoteStorageSubscribePublishedFileResult_t__bindgen_ty_1 = 1313;
pub type RemoteStorageSubscribePublishedFileResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageSubscribePublishedFileResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageSubscribePublishedFileResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageSubscribePublishedFileResult_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageSubscribePublishedFileResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageSubscribePublishedFileResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageSubscribePublishedFileResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageSubscribePublishedFileResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageSubscribePublishedFileResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageEnumerateUserSubscribedFilesResult_t {
    pub m_eResult: EResult,
    pub m_nResultsReturned: int32,
    pub m_nTotalResultCount: int32,
    pub m_rgPublishedFileId: [PublishedFileId_t; 50usize],
    pub m_rgRTimeSubscribed: [uint32; 50usize],
}
pub const RemoteStorageEnumerateUserSubscribedFilesResult_t_k_iCallback:
    RemoteStorageEnumerateUserSubscribedFilesResult_t__bindgen_ty_1 = 1314;
pub type RemoteStorageEnumerateUserSubscribedFilesResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageEnumerateUserSubscribedFilesResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageEnumerateUserSubscribedFilesResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageEnumerateUserSubscribedFilesResult_t>(),
        616usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageEnumerateUserSubscribedFilesResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageEnumerateUserSubscribedFilesResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageEnumerateUserSubscribedFilesResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSubscribedFilesResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nResultsReturned) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSubscribedFilesResult_t),
            "::",
            stringify!(m_nResultsReturned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalResultCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSubscribedFilesResult_t),
            "::",
            stringify!(m_nTotalResultCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgPublishedFileId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSubscribedFilesResult_t),
            "::",
            stringify!(m_rgPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgRTimeSubscribed) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSubscribedFilesResult_t),
            "::",
            stringify!(m_rgRTimeSubscribed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageUnsubscribePublishedFileResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
}
pub const RemoteStorageUnsubscribePublishedFileResult_t_k_iCallback:
    RemoteStorageUnsubscribePublishedFileResult_t__bindgen_ty_1 = 1315;
pub type RemoteStorageUnsubscribePublishedFileResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageUnsubscribePublishedFileResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageUnsubscribePublishedFileResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageUnsubscribePublishedFileResult_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageUnsubscribePublishedFileResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageUnsubscribePublishedFileResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageUnsubscribePublishedFileResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUnsubscribePublishedFileResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUnsubscribePublishedFileResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageUpdatePublishedFileResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_bUserNeedsToAcceptWorkshopLegalAgreement: bool,
}
pub const RemoteStorageUpdatePublishedFileResult_t_k_iCallback:
    RemoteStorageUpdatePublishedFileResult_t__bindgen_ty_1 = 1316;
pub type RemoteStorageUpdatePublishedFileResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageUpdatePublishedFileResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageUpdatePublishedFileResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageUpdatePublishedFileResult_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageUpdatePublishedFileResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageUpdatePublishedFileResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageUpdatePublishedFileResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUpdatePublishedFileResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUpdatePublishedFileResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_bUserNeedsToAcceptWorkshopLegalAgreement) as usize
                - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUpdatePublishedFileResult_t),
            "::",
            stringify!(m_bUserNeedsToAcceptWorkshopLegalAgreement)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageDownloadUGCResult_t {
    pub m_eResult: EResult,
    pub m_hFile: UGCHandle_t,
    pub m_nAppID: AppId_t,
    pub m_nSizeInBytes: int32,
    pub m_pchFileName: [::std::os::raw::c_char; 260usize],
    pub m_ulSteamIDOwner: uint64,
}
pub const RemoteStorageDownloadUGCResult_t_k_iCallback:
    RemoteStorageDownloadUGCResult_t__bindgen_ty_1 = 1317;
pub type RemoteStorageDownloadUGCResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageDownloadUGCResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageDownloadUGCResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageDownloadUGCResult_t>(),
        296usize,
        concat!("Size of: ", stringify!(RemoteStorageDownloadUGCResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageDownloadUGCResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageDownloadUGCResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageDownloadUGCResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hFile) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageDownloadUGCResult_t),
            "::",
            stringify!(m_hFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageDownloadUGCResult_t),
            "::",
            stringify!(m_nAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nSizeInBytes) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageDownloadUGCResult_t),
            "::",
            stringify!(m_nSizeInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pchFileName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageDownloadUGCResult_t),
            "::",
            stringify!(m_pchFileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDOwner) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageDownloadUGCResult_t),
            "::",
            stringify!(m_ulSteamIDOwner)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageGetPublishedFileDetailsResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nCreatorAppID: AppId_t,
    pub m_nConsumerAppID: AppId_t,
    pub m_rgchTitle: [::std::os::raw::c_char; 129usize],
    pub m_rgchDescription: [::std::os::raw::c_char; 8000usize],
    pub m_hFile: UGCHandle_t,
    pub m_hPreviewFile: UGCHandle_t,
    pub m_ulSteamIDOwner: uint64,
    pub m_rtimeCreated: uint32,
    pub m_rtimeUpdated: uint32,
    pub m_eVisibility: ERemoteStoragePublishedFileVisibility,
    pub m_bBanned: bool,
    pub m_rgchTags: [::std::os::raw::c_char; 1025usize],
    pub m_bTagsTruncated: bool,
    pub m_pchFileName: [::std::os::raw::c_char; 260usize],
    pub m_nFileSize: int32,
    pub m_nPreviewFileSize: int32,
    pub m_rgchURL: [::std::os::raw::c_char; 256usize],
    pub m_eFileType: EWorkshopFileType,
    pub m_bAcceptedForUse: bool,
}
pub const RemoteStorageGetPublishedFileDetailsResult_t_k_iCallback:
    RemoteStorageGetPublishedFileDetailsResult_t__bindgen_ty_1 = 1318;
pub type RemoteStorageGetPublishedFileDetailsResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageGetPublishedFileDetailsResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageGetPublishedFileDetailsResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageGetPublishedFileDetailsResult_t>(),
        9760usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageGetPublishedFileDetailsResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCreatorAppID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_nCreatorAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nConsumerAppID) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_nConsumerAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchTitle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_rgchTitle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchDescription) as usize - ptr as usize },
        153usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_rgchDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hFile) as usize - ptr as usize },
        8160usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_hFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hPreviewFile) as usize - ptr as usize },
        8168usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_hPreviewFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDOwner) as usize - ptr as usize },
        8176usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_ulSteamIDOwner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rtimeCreated) as usize - ptr as usize },
        8184usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_rtimeCreated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rtimeUpdated) as usize - ptr as usize },
        8188usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_rtimeUpdated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eVisibility) as usize - ptr as usize },
        8192usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_eVisibility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bBanned) as usize - ptr as usize },
        8196usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_bBanned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchTags) as usize - ptr as usize },
        8197usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_rgchTags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bTagsTruncated) as usize - ptr as usize },
        9222usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_bTagsTruncated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pchFileName) as usize - ptr as usize },
        9223usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_pchFileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nFileSize) as usize - ptr as usize },
        9484usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_nFileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPreviewFileSize) as usize - ptr as usize },
        9488usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_nPreviewFileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchURL) as usize - ptr as usize },
        9492usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_rgchURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eFileType) as usize - ptr as usize },
        9748usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_eFileType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAcceptedForUse) as usize - ptr as usize },
        9752usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedFileDetailsResult_t),
            "::",
            stringify!(m_bAcceptedForUse)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageEnumerateWorkshopFilesResult_t {
    pub m_eResult: EResult,
    pub m_nResultsReturned: int32,
    pub m_nTotalResultCount: int32,
    pub m_rgPublishedFileId: [PublishedFileId_t; 50usize],
    pub m_rgScore: [f32; 50usize],
    pub m_nAppId: AppId_t,
    pub m_unStartIndex: uint32,
}
pub const RemoteStorageEnumerateWorkshopFilesResult_t_k_iCallback:
    RemoteStorageEnumerateWorkshopFilesResult_t__bindgen_ty_1 = 1319;
pub type RemoteStorageEnumerateWorkshopFilesResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageEnumerateWorkshopFilesResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageEnumerateWorkshopFilesResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageEnumerateWorkshopFilesResult_t>(),
        624usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageEnumerateWorkshopFilesResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nResultsReturned) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t),
            "::",
            stringify!(m_nResultsReturned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalResultCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t),
            "::",
            stringify!(m_nTotalResultCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgPublishedFileId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t),
            "::",
            stringify!(m_rgPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgScore) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t),
            "::",
            stringify!(m_rgScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppId) as usize - ptr as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t),
            "::",
            stringify!(m_nAppId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unStartIndex) as usize - ptr as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateWorkshopFilesResult_t),
            "::",
            stringify!(m_unStartIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageGetPublishedItemVoteDetailsResult_t {
    pub m_eResult: EResult,
    pub m_unPublishedFileId: PublishedFileId_t,
    pub m_nVotesFor: int32,
    pub m_nVotesAgainst: int32,
    pub m_nReports: int32,
    pub m_fScore: f32,
}
pub const RemoteStorageGetPublishedItemVoteDetailsResult_t_k_iCallback:
    RemoteStorageGetPublishedItemVoteDetailsResult_t__bindgen_ty_1 = 1320;
pub type RemoteStorageGetPublishedItemVoteDetailsResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageGetPublishedItemVoteDetailsResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageGetPublishedItemVoteDetailsResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageGetPublishedItemVoteDetailsResult_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageGetPublishedItemVoteDetailsResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageGetPublishedItemVoteDetailsResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageGetPublishedItemVoteDetailsResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedItemVoteDetailsResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedItemVoteDetailsResult_t),
            "::",
            stringify!(m_unPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nVotesFor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedItemVoteDetailsResult_t),
            "::",
            stringify!(m_nVotesFor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nVotesAgainst) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedItemVoteDetailsResult_t),
            "::",
            stringify!(m_nVotesAgainst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nReports) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedItemVoteDetailsResult_t),
            "::",
            stringify!(m_nReports)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fScore) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageGetPublishedItemVoteDetailsResult_t),
            "::",
            stringify!(m_fScore)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStoragePublishedFileSubscribed_t {
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nAppID: AppId_t,
}
pub const RemoteStoragePublishedFileSubscribed_t_k_iCallback:
    RemoteStoragePublishedFileSubscribed_t__bindgen_ty_1 = 1321;
pub type RemoteStoragePublishedFileSubscribed_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStoragePublishedFileSubscribed_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStoragePublishedFileSubscribed_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStoragePublishedFileSubscribed_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStoragePublishedFileSubscribed_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStoragePublishedFileSubscribed_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStoragePublishedFileSubscribed_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileSubscribed_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileSubscribed_t),
            "::",
            stringify!(m_nAppID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStoragePublishedFileUnsubscribed_t {
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nAppID: AppId_t,
}
pub const RemoteStoragePublishedFileUnsubscribed_t_k_iCallback:
    RemoteStoragePublishedFileUnsubscribed_t__bindgen_ty_1 = 1322;
pub type RemoteStoragePublishedFileUnsubscribed_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStoragePublishedFileUnsubscribed_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStoragePublishedFileUnsubscribed_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStoragePublishedFileUnsubscribed_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStoragePublishedFileUnsubscribed_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStoragePublishedFileUnsubscribed_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStoragePublishedFileUnsubscribed_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileUnsubscribed_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileUnsubscribed_t),
            "::",
            stringify!(m_nAppID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStoragePublishedFileDeleted_t {
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nAppID: AppId_t,
}
pub const RemoteStoragePublishedFileDeleted_t_k_iCallback:
    RemoteStoragePublishedFileDeleted_t__bindgen_ty_1 = 1323;
pub type RemoteStoragePublishedFileDeleted_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStoragePublishedFileDeleted_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStoragePublishedFileDeleted_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStoragePublishedFileDeleted_t>(),
        16usize,
        concat!("Size of: ", stringify!(RemoteStoragePublishedFileDeleted_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStoragePublishedFileDeleted_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStoragePublishedFileDeleted_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileDeleted_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileDeleted_t),
            "::",
            stringify!(m_nAppID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageUpdateUserPublishedItemVoteResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
}
pub const RemoteStorageUpdateUserPublishedItemVoteResult_t_k_iCallback:
    RemoteStorageUpdateUserPublishedItemVoteResult_t__bindgen_ty_1 = 1324;
pub type RemoteStorageUpdateUserPublishedItemVoteResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageUpdateUserPublishedItemVoteResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageUpdateUserPublishedItemVoteResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageUpdateUserPublishedItemVoteResult_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageUpdateUserPublishedItemVoteResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageUpdateUserPublishedItemVoteResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageUpdateUserPublishedItemVoteResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUpdateUserPublishedItemVoteResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUpdateUserPublishedItemVoteResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageUserVoteDetails_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_eVote: EWorkshopVote,
}
pub const RemoteStorageUserVoteDetails_t_k_iCallback: RemoteStorageUserVoteDetails_t__bindgen_ty_1 =
    1325;
pub type RemoteStorageUserVoteDetails_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageUserVoteDetails_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageUserVoteDetails_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageUserVoteDetails_t>(),
        24usize,
        concat!("Size of: ", stringify!(RemoteStorageUserVoteDetails_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageUserVoteDetails_t>(),
        8usize,
        concat!("Alignment of ", stringify!(RemoteStorageUserVoteDetails_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUserVoteDetails_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUserVoteDetails_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eVote) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageUserVoteDetails_t),
            "::",
            stringify!(m_eVote)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageEnumerateUserSharedWorkshopFilesResult_t {
    pub m_eResult: EResult,
    pub m_nResultsReturned: int32,
    pub m_nTotalResultCount: int32,
    pub m_rgPublishedFileId: [PublishedFileId_t; 50usize],
}
pub const RemoteStorageEnumerateUserSharedWorkshopFilesResult_t_k_iCallback:
    RemoteStorageEnumerateUserSharedWorkshopFilesResult_t__bindgen_ty_1 = 1326;
pub type RemoteStorageEnumerateUserSharedWorkshopFilesResult_t__bindgen_ty_1 =
    ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageEnumerateUserSharedWorkshopFilesResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageEnumerateUserSharedWorkshopFilesResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageEnumerateUserSharedWorkshopFilesResult_t>(),
        416usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageEnumerateUserSharedWorkshopFilesResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageEnumerateUserSharedWorkshopFilesResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageEnumerateUserSharedWorkshopFilesResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSharedWorkshopFilesResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nResultsReturned) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSharedWorkshopFilesResult_t),
            "::",
            stringify!(m_nResultsReturned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalResultCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSharedWorkshopFilesResult_t),
            "::",
            stringify!(m_nTotalResultCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgPublishedFileId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumerateUserSharedWorkshopFilesResult_t),
            "::",
            stringify!(m_rgPublishedFileId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageSetUserPublishedFileActionResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_eAction: EWorkshopFileAction,
}
pub const RemoteStorageSetUserPublishedFileActionResult_t_k_iCallback:
    RemoteStorageSetUserPublishedFileActionResult_t__bindgen_ty_1 = 1327;
pub type RemoteStorageSetUserPublishedFileActionResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageSetUserPublishedFileActionResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageSetUserPublishedFileActionResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageSetUserPublishedFileActionResult_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageSetUserPublishedFileActionResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageSetUserPublishedFileActionResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageSetUserPublishedFileActionResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageSetUserPublishedFileActionResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageSetUserPublishedFileActionResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAction) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageSetUserPublishedFileActionResult_t),
            "::",
            stringify!(m_eAction)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageEnumeratePublishedFilesByUserActionResult_t {
    pub m_eResult: EResult,
    pub m_eAction: EWorkshopFileAction,
    pub m_nResultsReturned: int32,
    pub m_nTotalResultCount: int32,
    pub m_rgPublishedFileId: [PublishedFileId_t; 50usize],
    pub m_rgRTimeUpdated: [uint32; 50usize],
}
pub const RemoteStorageEnumeratePublishedFilesByUserActionResult_t_k_iCallback:
    RemoteStorageEnumeratePublishedFilesByUserActionResult_t__bindgen_ty_1 = 1328;
pub type RemoteStorageEnumeratePublishedFilesByUserActionResult_t__bindgen_ty_1 =
    ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageEnumeratePublishedFilesByUserActionResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<
        RemoteStorageEnumeratePublishedFilesByUserActionResult_t,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageEnumeratePublishedFilesByUserActionResult_t>(),
        616usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageEnumeratePublishedFilesByUserActionResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageEnumeratePublishedFilesByUserActionResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageEnumeratePublishedFilesByUserActionResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumeratePublishedFilesByUserActionResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumeratePublishedFilesByUserActionResult_t),
            "::",
            stringify!(m_eAction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nResultsReturned) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumeratePublishedFilesByUserActionResult_t),
            "::",
            stringify!(m_nResultsReturned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalResultCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumeratePublishedFilesByUserActionResult_t),
            "::",
            stringify!(m_nTotalResultCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgPublishedFileId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumeratePublishedFilesByUserActionResult_t),
            "::",
            stringify!(m_rgPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgRTimeUpdated) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageEnumeratePublishedFilesByUserActionResult_t),
            "::",
            stringify!(m_rgRTimeUpdated)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStoragePublishFileProgress_t {
    pub m_dPercentFile: f64,
    pub m_bPreview: bool,
}
pub const RemoteStoragePublishFileProgress_t_k_iCallback:
    RemoteStoragePublishFileProgress_t__bindgen_ty_1 = 1329;
pub type RemoteStoragePublishFileProgress_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStoragePublishFileProgress_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStoragePublishFileProgress_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStoragePublishFileProgress_t>(),
        16usize,
        concat!("Size of: ", stringify!(RemoteStoragePublishFileProgress_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStoragePublishFileProgress_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStoragePublishFileProgress_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dPercentFile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishFileProgress_t),
            "::",
            stringify!(m_dPercentFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bPreview) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishFileProgress_t),
            "::",
            stringify!(m_bPreview)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStoragePublishedFileUpdated_t {
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nAppID: AppId_t,
    pub m_ulUnused: uint64,
}
pub const RemoteStoragePublishedFileUpdated_t_k_iCallback:
    RemoteStoragePublishedFileUpdated_t__bindgen_ty_1 = 1330;
pub type RemoteStoragePublishedFileUpdated_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStoragePublishedFileUpdated_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStoragePublishedFileUpdated_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStoragePublishedFileUpdated_t>(),
        24usize,
        concat!("Size of: ", stringify!(RemoteStoragePublishedFileUpdated_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStoragePublishedFileUpdated_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStoragePublishedFileUpdated_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileUpdated_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileUpdated_t),
            "::",
            stringify!(m_nAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulUnused) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStoragePublishedFileUpdated_t),
            "::",
            stringify!(m_ulUnused)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageFileWriteAsyncComplete_t {
    pub m_eResult: EResult,
}
pub const RemoteStorageFileWriteAsyncComplete_t_k_iCallback:
    RemoteStorageFileWriteAsyncComplete_t__bindgen_ty_1 = 1331;
pub type RemoteStorageFileWriteAsyncComplete_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageFileWriteAsyncComplete_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageFileWriteAsyncComplete_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageFileWriteAsyncComplete_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageFileWriteAsyncComplete_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageFileWriteAsyncComplete_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageFileWriteAsyncComplete_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageFileWriteAsyncComplete_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageFileReadAsyncComplete_t {
    pub m_hFileReadAsync: SteamAPICall_t,
    pub m_eResult: EResult,
    pub m_nOffset: uint32,
    pub m_cubRead: uint32,
}
pub const RemoteStorageFileReadAsyncComplete_t_k_iCallback:
    RemoteStorageFileReadAsyncComplete_t__bindgen_ty_1 = 1332;
pub type RemoteStorageFileReadAsyncComplete_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageFileReadAsyncComplete_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoteStorageFileReadAsyncComplete_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageFileReadAsyncComplete_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(RemoteStorageFileReadAsyncComplete_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageFileReadAsyncComplete_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RemoteStorageFileReadAsyncComplete_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hFileReadAsync) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageFileReadAsyncComplete_t),
            "::",
            stringify!(m_hFileReadAsync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageFileReadAsyncComplete_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nOffset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageFileReadAsyncComplete_t),
            "::",
            stringify!(m_nOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cubRead) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoteStorageFileReadAsyncComplete_t),
            "::",
            stringify!(m_cubRead)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoteStorageLocalFileChange_t {
    pub _address: u8,
}
pub const RemoteStorageLocalFileChange_t_k_iCallback: RemoteStorageLocalFileChange_t__bindgen_ty_1 =
    1333;
pub type RemoteStorageLocalFileChange_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoteStorageLocalFileChange_t() {
    assert_eq!(
        ::std::mem::size_of::<RemoteStorageLocalFileChange_t>(),
        1usize,
        concat!("Size of: ", stringify!(RemoteStorageLocalFileChange_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoteStorageLocalFileChange_t>(),
        1usize,
        concat!("Alignment of ", stringify!(RemoteStorageLocalFileChange_t))
    );
}
pub const k_cchStatNameMax: _bindgen_ty_42 = 128;
pub type _bindgen_ty_42 = ::std::os::raw::c_int;
pub const k_cchLeaderboardNameMax: _bindgen_ty_43 = 128;
pub type _bindgen_ty_43 = ::std::os::raw::c_int;
pub const k_cLeaderboardDetailsMax: _bindgen_ty_44 = 64;
pub type _bindgen_ty_44 = ::std::os::raw::c_int;
pub type SteamLeaderboard_t = uint64;
pub type SteamLeaderboardEntries_t = uint64;
pub const ELeaderboardDataRequest_k_ELeaderboardDataRequestGlobal: ELeaderboardDataRequest = 0;
pub const ELeaderboardDataRequest_k_ELeaderboardDataRequestGlobalAroundUser:
    ELeaderboardDataRequest = 1;
pub const ELeaderboardDataRequest_k_ELeaderboardDataRequestFriends: ELeaderboardDataRequest = 2;
pub const ELeaderboardDataRequest_k_ELeaderboardDataRequestUsers: ELeaderboardDataRequest = 3;
pub type ELeaderboardDataRequest = ::std::os::raw::c_int;
pub const ELeaderboardSortMethod_k_ELeaderboardSortMethodNone: ELeaderboardSortMethod = 0;
pub const ELeaderboardSortMethod_k_ELeaderboardSortMethodAscending: ELeaderboardSortMethod = 1;
pub const ELeaderboardSortMethod_k_ELeaderboardSortMethodDescending: ELeaderboardSortMethod = 2;
pub type ELeaderboardSortMethod = ::std::os::raw::c_int;
pub const ELeaderboardDisplayType_k_ELeaderboardDisplayTypeNone: ELeaderboardDisplayType = 0;
pub const ELeaderboardDisplayType_k_ELeaderboardDisplayTypeNumeric: ELeaderboardDisplayType = 1;
pub const ELeaderboardDisplayType_k_ELeaderboardDisplayTypeTimeSeconds: ELeaderboardDisplayType = 2;
pub const ELeaderboardDisplayType_k_ELeaderboardDisplayTypeTimeMilliSeconds:
    ELeaderboardDisplayType = 3;
pub type ELeaderboardDisplayType = ::std::os::raw::c_int;
pub const ELeaderboardUploadScoreMethod_k_ELeaderboardUploadScoreMethodNone:
    ELeaderboardUploadScoreMethod = 0;
pub const ELeaderboardUploadScoreMethod_k_ELeaderboardUploadScoreMethodKeepBest:
    ELeaderboardUploadScoreMethod = 1;
pub const ELeaderboardUploadScoreMethod_k_ELeaderboardUploadScoreMethodForceUpdate:
    ELeaderboardUploadScoreMethod = 2;
pub type ELeaderboardUploadScoreMethod = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LeaderboardEntry_t {
    pub m_steamIDUser: CSteamID,
    pub m_nGlobalRank: int32,
    pub m_nScore: int32,
    pub m_cDetails: int32,
    pub m_hUGC: UGCHandle_t,
}
#[test]
fn bindgen_test_layout_LeaderboardEntry_t() {
    const UNINIT: ::std::mem::MaybeUninit<LeaderboardEntry_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LeaderboardEntry_t>(),
        32usize,
        concat!("Size of: ", stringify!(LeaderboardEntry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LeaderboardEntry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LeaderboardEntry_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardEntry_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGlobalRank) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardEntry_t),
            "::",
            stringify!(m_nGlobalRank)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nScore) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardEntry_t),
            "::",
            stringify!(m_nScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cDetails) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardEntry_t),
            "::",
            stringify!(m_cDetails)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hUGC) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardEntry_t),
            "::",
            stringify!(m_hUGC)
        )
    );
}
#[repr(C)]
pub struct ISteamUserStats__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamUserStats {
    pub vtable_: *const ISteamUserStats__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamUserStats() {
    assert_eq!(
        ::std::mem::size_of::<ISteamUserStats>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamUserStats))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamUserStats>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamUserStats))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UserStatsReceived_t {
    pub m_nGameID: uint64,
    pub m_eResult: EResult,
    pub m_steamIDUser: CSteamID,
}
pub const UserStatsReceived_t_k_iCallback: UserStatsReceived_t__bindgen_ty_1 = 1101;
pub type UserStatsReceived_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_UserStatsReceived_t() {
    const UNINIT: ::std::mem::MaybeUninit<UserStatsReceived_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UserStatsReceived_t>(),
        24usize,
        concat!("Size of: ", stringify!(UserStatsReceived_t))
    );
    assert_eq!(
        ::std::mem::align_of::<UserStatsReceived_t>(),
        8usize,
        concat!("Alignment of ", stringify!(UserStatsReceived_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UserStatsReceived_t),
            "::",
            stringify!(m_nGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UserStatsReceived_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UserStatsReceived_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UserStatsStored_t {
    pub m_nGameID: uint64,
    pub m_eResult: EResult,
}
pub const UserStatsStored_t_k_iCallback: UserStatsStored_t__bindgen_ty_1 = 1102;
pub type UserStatsStored_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_UserStatsStored_t() {
    const UNINIT: ::std::mem::MaybeUninit<UserStatsStored_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UserStatsStored_t>(),
        16usize,
        concat!("Size of: ", stringify!(UserStatsStored_t))
    );
    assert_eq!(
        ::std::mem::align_of::<UserStatsStored_t>(),
        8usize,
        concat!("Alignment of ", stringify!(UserStatsStored_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UserStatsStored_t),
            "::",
            stringify!(m_nGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UserStatsStored_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UserAchievementStored_t {
    pub m_nGameID: uint64,
    pub m_bGroupAchievement: bool,
    pub m_rgchAchievementName: [::std::os::raw::c_char; 128usize],
    pub m_nCurProgress: uint32,
    pub m_nMaxProgress: uint32,
}
pub const UserAchievementStored_t_k_iCallback: UserAchievementStored_t__bindgen_ty_1 = 1103;
pub type UserAchievementStored_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_UserAchievementStored_t() {
    const UNINIT: ::std::mem::MaybeUninit<UserAchievementStored_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UserAchievementStored_t>(),
        152usize,
        concat!("Size of: ", stringify!(UserAchievementStored_t))
    );
    assert_eq!(
        ::std::mem::align_of::<UserAchievementStored_t>(),
        8usize,
        concat!("Alignment of ", stringify!(UserAchievementStored_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementStored_t),
            "::",
            stringify!(m_nGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bGroupAchievement) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementStored_t),
            "::",
            stringify!(m_bGroupAchievement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchAchievementName) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementStored_t),
            "::",
            stringify!(m_rgchAchievementName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCurProgress) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementStored_t),
            "::",
            stringify!(m_nCurProgress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nMaxProgress) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementStored_t),
            "::",
            stringify!(m_nMaxProgress)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LeaderboardFindResult_t {
    pub m_hSteamLeaderboard: SteamLeaderboard_t,
    pub m_bLeaderboardFound: uint8,
}
pub const LeaderboardFindResult_t_k_iCallback: LeaderboardFindResult_t__bindgen_ty_1 = 1104;
pub type LeaderboardFindResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_LeaderboardFindResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<LeaderboardFindResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LeaderboardFindResult_t>(),
        16usize,
        concat!("Size of: ", stringify!(LeaderboardFindResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LeaderboardFindResult_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LeaderboardFindResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hSteamLeaderboard) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardFindResult_t),
            "::",
            stringify!(m_hSteamLeaderboard)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bLeaderboardFound) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardFindResult_t),
            "::",
            stringify!(m_bLeaderboardFound)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LeaderboardScoresDownloaded_t {
    pub m_hSteamLeaderboard: SteamLeaderboard_t,
    pub m_hSteamLeaderboardEntries: SteamLeaderboardEntries_t,
    pub m_cEntryCount: ::std::os::raw::c_int,
}
pub const LeaderboardScoresDownloaded_t_k_iCallback: LeaderboardScoresDownloaded_t__bindgen_ty_1 =
    1105;
pub type LeaderboardScoresDownloaded_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_LeaderboardScoresDownloaded_t() {
    const UNINIT: ::std::mem::MaybeUninit<LeaderboardScoresDownloaded_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LeaderboardScoresDownloaded_t>(),
        24usize,
        concat!("Size of: ", stringify!(LeaderboardScoresDownloaded_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LeaderboardScoresDownloaded_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LeaderboardScoresDownloaded_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hSteamLeaderboard) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoresDownloaded_t),
            "::",
            stringify!(m_hSteamLeaderboard)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hSteamLeaderboardEntries) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoresDownloaded_t),
            "::",
            stringify!(m_hSteamLeaderboardEntries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cEntryCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoresDownloaded_t),
            "::",
            stringify!(m_cEntryCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LeaderboardScoreUploaded_t {
    pub m_bSuccess: uint8,
    pub m_hSteamLeaderboard: SteamLeaderboard_t,
    pub m_nScore: int32,
    pub m_bScoreChanged: uint8,
    pub m_nGlobalRankNew: ::std::os::raw::c_int,
    pub m_nGlobalRankPrevious: ::std::os::raw::c_int,
}
pub const LeaderboardScoreUploaded_t_k_iCallback: LeaderboardScoreUploaded_t__bindgen_ty_1 = 1106;
pub type LeaderboardScoreUploaded_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_LeaderboardScoreUploaded_t() {
    const UNINIT: ::std::mem::MaybeUninit<LeaderboardScoreUploaded_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LeaderboardScoreUploaded_t>(),
        32usize,
        concat!("Size of: ", stringify!(LeaderboardScoreUploaded_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LeaderboardScoreUploaded_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LeaderboardScoreUploaded_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSuccess) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoreUploaded_t),
            "::",
            stringify!(m_bSuccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hSteamLeaderboard) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoreUploaded_t),
            "::",
            stringify!(m_hSteamLeaderboard)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nScore) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoreUploaded_t),
            "::",
            stringify!(m_nScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bScoreChanged) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoreUploaded_t),
            "::",
            stringify!(m_bScoreChanged)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGlobalRankNew) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoreUploaded_t),
            "::",
            stringify!(m_nGlobalRankNew)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGlobalRankPrevious) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardScoreUploaded_t),
            "::",
            stringify!(m_nGlobalRankPrevious)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NumberOfCurrentPlayers_t {
    pub m_bSuccess: uint8,
    pub m_cPlayers: int32,
}
pub const NumberOfCurrentPlayers_t_k_iCallback: NumberOfCurrentPlayers_t__bindgen_ty_1 = 1107;
pub type NumberOfCurrentPlayers_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_NumberOfCurrentPlayers_t() {
    const UNINIT: ::std::mem::MaybeUninit<NumberOfCurrentPlayers_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NumberOfCurrentPlayers_t>(),
        8usize,
        concat!("Size of: ", stringify!(NumberOfCurrentPlayers_t))
    );
    assert_eq!(
        ::std::mem::align_of::<NumberOfCurrentPlayers_t>(),
        4usize,
        concat!("Alignment of ", stringify!(NumberOfCurrentPlayers_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSuccess) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NumberOfCurrentPlayers_t),
            "::",
            stringify!(m_bSuccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cPlayers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NumberOfCurrentPlayers_t),
            "::",
            stringify!(m_cPlayers)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UserStatsUnloaded_t {
    pub m_steamIDUser: CSteamID,
}
pub const UserStatsUnloaded_t_k_iCallback: UserStatsUnloaded_t__bindgen_ty_1 = 1108;
pub type UserStatsUnloaded_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_UserStatsUnloaded_t() {
    const UNINIT: ::std::mem::MaybeUninit<UserStatsUnloaded_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UserStatsUnloaded_t>(),
        8usize,
        concat!("Size of: ", stringify!(UserStatsUnloaded_t))
    );
    assert_eq!(
        ::std::mem::align_of::<UserStatsUnloaded_t>(),
        1usize,
        concat!("Alignment of ", stringify!(UserStatsUnloaded_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UserStatsUnloaded_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UserAchievementIconFetched_t {
    pub m_nGameID: CGameID,
    pub m_rgchAchievementName: [::std::os::raw::c_char; 128usize],
    pub m_bAchieved: bool,
    pub m_nIconHandle: ::std::os::raw::c_int,
}
pub const UserAchievementIconFetched_t_k_iCallback: UserAchievementIconFetched_t__bindgen_ty_1 =
    1109;
pub type UserAchievementIconFetched_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_UserAchievementIconFetched_t() {
    const UNINIT: ::std::mem::MaybeUninit<UserAchievementIconFetched_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UserAchievementIconFetched_t>(),
        144usize,
        concat!("Size of: ", stringify!(UserAchievementIconFetched_t))
    );
    assert_eq!(
        ::std::mem::align_of::<UserAchievementIconFetched_t>(),
        4usize,
        concat!("Alignment of ", stringify!(UserAchievementIconFetched_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementIconFetched_t),
            "::",
            stringify!(m_nGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchAchievementName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementIconFetched_t),
            "::",
            stringify!(m_rgchAchievementName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAchieved) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementIconFetched_t),
            "::",
            stringify!(m_bAchieved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nIconHandle) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(UserAchievementIconFetched_t),
            "::",
            stringify!(m_nIconHandle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GlobalAchievementPercentagesReady_t {
    pub m_nGameID: uint64,
    pub m_eResult: EResult,
}
pub const GlobalAchievementPercentagesReady_t_k_iCallback:
    GlobalAchievementPercentagesReady_t__bindgen_ty_1 = 1110;
pub type GlobalAchievementPercentagesReady_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GlobalAchievementPercentagesReady_t() {
    const UNINIT: ::std::mem::MaybeUninit<GlobalAchievementPercentagesReady_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GlobalAchievementPercentagesReady_t>(),
        16usize,
        concat!("Size of: ", stringify!(GlobalAchievementPercentagesReady_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GlobalAchievementPercentagesReady_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(GlobalAchievementPercentagesReady_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalAchievementPercentagesReady_t),
            "::",
            stringify!(m_nGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalAchievementPercentagesReady_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LeaderboardUGCSet_t {
    pub m_eResult: EResult,
    pub m_hSteamLeaderboard: SteamLeaderboard_t,
}
pub const LeaderboardUGCSet_t_k_iCallback: LeaderboardUGCSet_t__bindgen_ty_1 = 1111;
pub type LeaderboardUGCSet_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_LeaderboardUGCSet_t() {
    const UNINIT: ::std::mem::MaybeUninit<LeaderboardUGCSet_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LeaderboardUGCSet_t>(),
        16usize,
        concat!("Size of: ", stringify!(LeaderboardUGCSet_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LeaderboardUGCSet_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LeaderboardUGCSet_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardUGCSet_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hSteamLeaderboard) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LeaderboardUGCSet_t),
            "::",
            stringify!(m_hSteamLeaderboard)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PS3TrophiesInstalled_t {
    pub m_nGameID: uint64,
    pub m_eResult: EResult,
    pub m_ulRequiredDiskSpace: uint64,
}
pub const PS3TrophiesInstalled_t_k_iCallback: PS3TrophiesInstalled_t__bindgen_ty_1 = 1112;
pub type PS3TrophiesInstalled_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_PS3TrophiesInstalled_t() {
    const UNINIT: ::std::mem::MaybeUninit<PS3TrophiesInstalled_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PS3TrophiesInstalled_t>(),
        24usize,
        concat!("Size of: ", stringify!(PS3TrophiesInstalled_t))
    );
    assert_eq!(
        ::std::mem::align_of::<PS3TrophiesInstalled_t>(),
        8usize,
        concat!("Alignment of ", stringify!(PS3TrophiesInstalled_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PS3TrophiesInstalled_t),
            "::",
            stringify!(m_nGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PS3TrophiesInstalled_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulRequiredDiskSpace) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PS3TrophiesInstalled_t),
            "::",
            stringify!(m_ulRequiredDiskSpace)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GlobalStatsReceived_t {
    pub m_nGameID: uint64,
    pub m_eResult: EResult,
}
pub const GlobalStatsReceived_t_k_iCallback: GlobalStatsReceived_t__bindgen_ty_1 = 1112;
pub type GlobalStatsReceived_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GlobalStatsReceived_t() {
    const UNINIT: ::std::mem::MaybeUninit<GlobalStatsReceived_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GlobalStatsReceived_t>(),
        16usize,
        concat!("Size of: ", stringify!(GlobalStatsReceived_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GlobalStatsReceived_t>(),
        8usize,
        concat!("Alignment of ", stringify!(GlobalStatsReceived_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nGameID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalStatsReceived_t),
            "::",
            stringify!(m_nGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalStatsReceived_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
pub const k_cubAppProofOfPurchaseKeyMax: ::std::os::raw::c_int = 240;
#[repr(C)]
pub struct ISteamApps__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamApps {
    pub vtable_: *const ISteamApps__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamApps() {
    assert_eq!(
        ::std::mem::size_of::<ISteamApps>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamApps))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamApps>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamApps))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DlcInstalled_t {
    pub m_nAppID: AppId_t,
}
pub const DlcInstalled_t_k_iCallback: DlcInstalled_t__bindgen_ty_1 = 1005;
pub type DlcInstalled_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_DlcInstalled_t() {
    const UNINIT: ::std::mem::MaybeUninit<DlcInstalled_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DlcInstalled_t>(),
        4usize,
        concat!("Size of: ", stringify!(DlcInstalled_t))
    );
    assert_eq!(
        ::std::mem::align_of::<DlcInstalled_t>(),
        4usize,
        concat!("Alignment of ", stringify!(DlcInstalled_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DlcInstalled_t),
            "::",
            stringify!(m_nAppID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NewUrlLaunchParameters_t {
    pub _address: u8,
}
pub const NewUrlLaunchParameters_t_k_iCallback: NewUrlLaunchParameters_t__bindgen_ty_1 = 1014;
pub type NewUrlLaunchParameters_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_NewUrlLaunchParameters_t() {
    assert_eq!(
        ::std::mem::size_of::<NewUrlLaunchParameters_t>(),
        1usize,
        concat!("Size of: ", stringify!(NewUrlLaunchParameters_t))
    );
    assert_eq!(
        ::std::mem::align_of::<NewUrlLaunchParameters_t>(),
        1usize,
        concat!("Alignment of ", stringify!(NewUrlLaunchParameters_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppProofOfPurchaseKeyResponse_t {
    pub m_eResult: EResult,
    pub m_nAppID: uint32,
    pub m_cchKeyLength: uint32,
    pub m_rgchKey: [::std::os::raw::c_char; 240usize],
}
pub const AppProofOfPurchaseKeyResponse_t_k_iCallback:
    AppProofOfPurchaseKeyResponse_t__bindgen_ty_1 = 1021;
pub type AppProofOfPurchaseKeyResponse_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_AppProofOfPurchaseKeyResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<AppProofOfPurchaseKeyResponse_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AppProofOfPurchaseKeyResponse_t>(),
        252usize,
        concat!("Size of: ", stringify!(AppProofOfPurchaseKeyResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<AppProofOfPurchaseKeyResponse_t>(),
        4usize,
        concat!("Alignment of ", stringify!(AppProofOfPurchaseKeyResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AppProofOfPurchaseKeyResponse_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AppProofOfPurchaseKeyResponse_t),
            "::",
            stringify!(m_nAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cchKeyLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AppProofOfPurchaseKeyResponse_t),
            "::",
            stringify!(m_cchKeyLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchKey) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AppProofOfPurchaseKeyResponse_t),
            "::",
            stringify!(m_rgchKey)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileDetailsResult_t {
    pub m_eResult: EResult,
    pub m_ulFileSize: uint64,
    pub m_FileSHA: [uint8; 20usize],
    pub m_unFlags: uint32,
}
pub const FileDetailsResult_t_k_iCallback: FileDetailsResult_t__bindgen_ty_1 = 1023;
pub type FileDetailsResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_FileDetailsResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<FileDetailsResult_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FileDetailsResult_t>(),
        40usize,
        concat!("Size of: ", stringify!(FileDetailsResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<FileDetailsResult_t>(),
        8usize,
        concat!("Alignment of ", stringify!(FileDetailsResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FileDetailsResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulFileSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FileDetailsResult_t),
            "::",
            stringify!(m_ulFileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_FileSHA) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FileDetailsResult_t),
            "::",
            stringify!(m_FileSHA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unFlags) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FileDetailsResult_t),
            "::",
            stringify!(m_unFlags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TimedTrialStatus_t {
    pub m_unAppID: AppId_t,
    pub m_bIsOffline: bool,
    pub m_unSecondsAllowed: uint32,
    pub m_unSecondsPlayed: uint32,
}
pub const TimedTrialStatus_t_k_iCallback: TimedTrialStatus_t__bindgen_ty_1 = 1030;
pub type TimedTrialStatus_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_TimedTrialStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<TimedTrialStatus_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TimedTrialStatus_t>(),
        16usize,
        concat!("Size of: ", stringify!(TimedTrialStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<TimedTrialStatus_t>(),
        4usize,
        concat!("Alignment of ", stringify!(TimedTrialStatus_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TimedTrialStatus_t),
            "::",
            stringify!(m_unAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsOffline) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TimedTrialStatus_t),
            "::",
            stringify!(m_bIsOffline)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unSecondsAllowed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TimedTrialStatus_t),
            "::",
            stringify!(m_unSecondsAllowed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unSecondsPlayed) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TimedTrialStatus_t),
            "::",
            stringify!(m_unSecondsPlayed)
        )
    );
}
pub const EP2PSessionError_k_EP2PSessionErrorNone: EP2PSessionError = 0;
pub const EP2PSessionError_k_EP2PSessionErrorNoRightsToApp: EP2PSessionError = 2;
pub const EP2PSessionError_k_EP2PSessionErrorTimeout: EP2PSessionError = 4;
pub const EP2PSessionError_k_EP2PSessionErrorNotRunningApp_DELETED: EP2PSessionError = 1;
pub const EP2PSessionError_k_EP2PSessionErrorDestinationNotLoggedIn_DELETED: EP2PSessionError = 3;
pub const EP2PSessionError_k_EP2PSessionErrorMax: EP2PSessionError = 5;
pub type EP2PSessionError = ::std::os::raw::c_int;
pub const EP2PSend_k_EP2PSendUnreliable: EP2PSend = 0;
pub const EP2PSend_k_EP2PSendUnreliableNoDelay: EP2PSend = 1;
pub const EP2PSend_k_EP2PSendReliable: EP2PSend = 2;
pub const EP2PSend_k_EP2PSendReliableWithBuffering: EP2PSend = 3;
pub type EP2PSend = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct P2PSessionState_t {
    pub m_bConnectionActive: uint8,
    pub m_bConnecting: uint8,
    pub m_eP2PSessionError: uint8,
    pub m_bUsingRelay: uint8,
    pub m_nBytesQueuedForSend: int32,
    pub m_nPacketsQueuedForSend: int32,
    pub m_nRemoteIP: uint32,
    pub m_nRemotePort: uint16,
}
#[test]
fn bindgen_test_layout_P2PSessionState_t() {
    const UNINIT: ::std::mem::MaybeUninit<P2PSessionState_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<P2PSessionState_t>(),
        20usize,
        concat!("Size of: ", stringify!(P2PSessionState_t))
    );
    assert_eq!(
        ::std::mem::align_of::<P2PSessionState_t>(),
        4usize,
        concat!("Alignment of ", stringify!(P2PSessionState_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bConnectionActive) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_bConnectionActive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bConnecting) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_bConnecting)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eP2PSessionError) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_eP2PSessionError)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUsingRelay) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_bUsingRelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nBytesQueuedForSend) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_nBytesQueuedForSend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPacketsQueuedForSend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_nPacketsQueuedForSend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nRemoteIP) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_nRemoteIP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nRemotePort) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionState_t),
            "::",
            stringify!(m_nRemotePort)
        )
    );
}
pub type SNetSocket_t = uint32;
pub type SNetListenSocket_t = uint32;
pub const ESNetSocketState_k_ESNetSocketStateInvalid: ESNetSocketState = 0;
pub const ESNetSocketState_k_ESNetSocketStateConnected: ESNetSocketState = 1;
pub const ESNetSocketState_k_ESNetSocketStateInitiated: ESNetSocketState = 10;
pub const ESNetSocketState_k_ESNetSocketStateLocalCandidatesFound: ESNetSocketState = 11;
pub const ESNetSocketState_k_ESNetSocketStateReceivedRemoteCandidates: ESNetSocketState = 12;
pub const ESNetSocketState_k_ESNetSocketStateChallengeHandshake: ESNetSocketState = 15;
pub const ESNetSocketState_k_ESNetSocketStateDisconnecting: ESNetSocketState = 21;
pub const ESNetSocketState_k_ESNetSocketStateLocalDisconnect: ESNetSocketState = 22;
pub const ESNetSocketState_k_ESNetSocketStateTimeoutDuringConnect: ESNetSocketState = 23;
pub const ESNetSocketState_k_ESNetSocketStateRemoteEndDisconnected: ESNetSocketState = 24;
pub const ESNetSocketState_k_ESNetSocketStateConnectionBroken: ESNetSocketState = 25;
pub type ESNetSocketState = ::std::os::raw::c_int;
pub const ESNetSocketConnectionType_k_ESNetSocketConnectionTypeNotConnected:
    ESNetSocketConnectionType = 0;
pub const ESNetSocketConnectionType_k_ESNetSocketConnectionTypeUDP: ESNetSocketConnectionType = 1;
pub const ESNetSocketConnectionType_k_ESNetSocketConnectionTypeUDPRelay: ESNetSocketConnectionType =
    2;
pub type ESNetSocketConnectionType = ::std::os::raw::c_int;
#[repr(C)]
pub struct ISteamNetworking__bindgen_vtable(::std::os::raw::c_void);
#[doc = "      the Steamworks SDK.  Please see ISteamNetworkingSockets and\n      ISteamNetworkingMessages"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworking {
    pub vtable_: *const ISteamNetworking__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamNetworking() {
    assert_eq!(
        ::std::mem::size_of::<ISteamNetworking>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamNetworking))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamNetworking>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamNetworking))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct P2PSessionRequest_t {
    pub m_steamIDRemote: CSteamID,
}
pub const P2PSessionRequest_t_k_iCallback: P2PSessionRequest_t__bindgen_ty_1 = 1202;
pub type P2PSessionRequest_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_P2PSessionRequest_t() {
    const UNINIT: ::std::mem::MaybeUninit<P2PSessionRequest_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<P2PSessionRequest_t>(),
        8usize,
        concat!("Size of: ", stringify!(P2PSessionRequest_t))
    );
    assert_eq!(
        ::std::mem::align_of::<P2PSessionRequest_t>(),
        1usize,
        concat!("Alignment of ", stringify!(P2PSessionRequest_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDRemote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionRequest_t),
            "::",
            stringify!(m_steamIDRemote)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct P2PSessionConnectFail_t {
    pub m_steamIDRemote: CSteamID,
    pub m_eP2PSessionError: uint8,
}
pub const P2PSessionConnectFail_t_k_iCallback: P2PSessionConnectFail_t__bindgen_ty_1 = 1203;
pub type P2PSessionConnectFail_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_P2PSessionConnectFail_t() {
    const UNINIT: ::std::mem::MaybeUninit<P2PSessionConnectFail_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<P2PSessionConnectFail_t>(),
        9usize,
        concat!("Size of: ", stringify!(P2PSessionConnectFail_t))
    );
    assert_eq!(
        ::std::mem::align_of::<P2PSessionConnectFail_t>(),
        1usize,
        concat!("Alignment of ", stringify!(P2PSessionConnectFail_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDRemote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionConnectFail_t),
            "::",
            stringify!(m_steamIDRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eP2PSessionError) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(P2PSessionConnectFail_t),
            "::",
            stringify!(m_eP2PSessionError)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SocketStatusCallback_t {
    pub m_hSocket: SNetSocket_t,
    pub m_hListenSocket: SNetListenSocket_t,
    pub m_steamIDRemote: CSteamID,
    pub m_eSNetSocketState: ::std::os::raw::c_int,
}
pub const SocketStatusCallback_t_k_iCallback: SocketStatusCallback_t__bindgen_ty_1 = 1201;
pub type SocketStatusCallback_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SocketStatusCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<SocketStatusCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SocketStatusCallback_t>(),
        20usize,
        concat!("Size of: ", stringify!(SocketStatusCallback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SocketStatusCallback_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SocketStatusCallback_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hSocket) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketStatusCallback_t),
            "::",
            stringify!(m_hSocket)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hListenSocket) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketStatusCallback_t),
            "::",
            stringify!(m_hListenSocket)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDRemote) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketStatusCallback_t),
            "::",
            stringify!(m_steamIDRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eSNetSocketState) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketStatusCallback_t),
            "::",
            stringify!(m_eSNetSocketState)
        )
    );
}
pub const k_nScreenshotMaxTaggedUsers: uint32 = 32;
pub const k_nScreenshotMaxTaggedPublishedFiles: uint32 = 32;
pub const k_cubUFSTagTypeMax: ::std::os::raw::c_int = 255;
pub const k_cubUFSTagValueMax: ::std::os::raw::c_int = 255;
pub const k_ScreenshotThumbWidth: ::std::os::raw::c_int = 200;
pub type ScreenshotHandle = uint32;
pub const EVRScreenshotType_k_EVRScreenshotType_None: EVRScreenshotType = 0;
pub const EVRScreenshotType_k_EVRScreenshotType_Mono: EVRScreenshotType = 1;
pub const EVRScreenshotType_k_EVRScreenshotType_Stereo: EVRScreenshotType = 2;
pub const EVRScreenshotType_k_EVRScreenshotType_MonoCubemap: EVRScreenshotType = 3;
pub const EVRScreenshotType_k_EVRScreenshotType_MonoPanorama: EVRScreenshotType = 4;
pub const EVRScreenshotType_k_EVRScreenshotType_StereoPanorama: EVRScreenshotType = 5;
pub type EVRScreenshotType = ::std::os::raw::c_int;
#[repr(C)]
pub struct ISteamScreenshots__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamScreenshots {
    pub vtable_: *const ISteamScreenshots__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamScreenshots() {
    assert_eq!(
        ::std::mem::size_of::<ISteamScreenshots>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamScreenshots))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamScreenshots>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamScreenshots))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScreenshotReady_t {
    pub m_hLocal: ScreenshotHandle,
    pub m_eResult: EResult,
}
pub const ScreenshotReady_t_k_iCallback: ScreenshotReady_t__bindgen_ty_1 = 2301;
pub type ScreenshotReady_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_ScreenshotReady_t() {
    const UNINIT: ::std::mem::MaybeUninit<ScreenshotReady_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ScreenshotReady_t>(),
        8usize,
        concat!("Size of: ", stringify!(ScreenshotReady_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ScreenshotReady_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ScreenshotReady_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hLocal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ScreenshotReady_t),
            "::",
            stringify!(m_hLocal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ScreenshotReady_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScreenshotRequested_t {
    pub _address: u8,
}
pub const ScreenshotRequested_t_k_iCallback: ScreenshotRequested_t__bindgen_ty_1 = 2302;
pub type ScreenshotRequested_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_ScreenshotRequested_t() {
    assert_eq!(
        ::std::mem::size_of::<ScreenshotRequested_t>(),
        1usize,
        concat!("Size of: ", stringify!(ScreenshotRequested_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ScreenshotRequested_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ScreenshotRequested_t))
    );
}
pub const AudioPlayback_Status_AudioPlayback_Undefined: AudioPlayback_Status = 0;
pub const AudioPlayback_Status_AudioPlayback_Playing: AudioPlayback_Status = 1;
pub const AudioPlayback_Status_AudioPlayback_Paused: AudioPlayback_Status = 2;
pub const AudioPlayback_Status_AudioPlayback_Idle: AudioPlayback_Status = 3;
pub type AudioPlayback_Status = ::std::os::raw::c_int;
#[repr(C)]
pub struct ISteamMusic__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMusic {
    pub vtable_: *const ISteamMusic__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMusic() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMusic>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMusic))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMusic>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMusic))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlaybackStatusHasChanged_t {
    pub _address: u8,
}
pub const PlaybackStatusHasChanged_t_k_iCallback: PlaybackStatusHasChanged_t__bindgen_ty_1 = 4001;
pub type PlaybackStatusHasChanged_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_PlaybackStatusHasChanged_t() {
    assert_eq!(
        ::std::mem::size_of::<PlaybackStatusHasChanged_t>(),
        1usize,
        concat!("Size of: ", stringify!(PlaybackStatusHasChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<PlaybackStatusHasChanged_t>(),
        1usize,
        concat!("Alignment of ", stringify!(PlaybackStatusHasChanged_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VolumeHasChanged_t {
    pub m_flNewVolume: f32,
}
pub const VolumeHasChanged_t_k_iCallback: VolumeHasChanged_t__bindgen_ty_1 = 4002;
pub type VolumeHasChanged_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_VolumeHasChanged_t() {
    const UNINIT: ::std::mem::MaybeUninit<VolumeHasChanged_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VolumeHasChanged_t>(),
        4usize,
        concat!("Size of: ", stringify!(VolumeHasChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<VolumeHasChanged_t>(),
        4usize,
        concat!("Alignment of ", stringify!(VolumeHasChanged_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flNewVolume) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VolumeHasChanged_t),
            "::",
            stringify!(m_flNewVolume)
        )
    );
}
#[repr(C)]
pub struct ISteamMusicRemote__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamMusicRemote {
    pub vtable_: *const ISteamMusicRemote__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamMusicRemote() {
    assert_eq!(
        ::std::mem::size_of::<ISteamMusicRemote>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamMusicRemote))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamMusicRemote>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamMusicRemote))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerRemoteWillActivate_t {
    pub _address: u8,
}
pub const MusicPlayerRemoteWillActivate_t_k_iCallback:
    MusicPlayerRemoteWillActivate_t__bindgen_ty_1 = 4101;
pub type MusicPlayerRemoteWillActivate_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_MusicPlayerRemoteWillActivate_t() {
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerRemoteWillActivate_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerRemoteWillActivate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerRemoteWillActivate_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerRemoteWillActivate_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerRemoteWillDeactivate_t {
    pub _address: u8,
}
pub const MusicPlayerRemoteWillDeactivate_t_k_iCallback:
    MusicPlayerRemoteWillDeactivate_t__bindgen_ty_1 = 4102;
pub type MusicPlayerRemoteWillDeactivate_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_MusicPlayerRemoteWillDeactivate_t() {
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerRemoteWillDeactivate_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerRemoteWillDeactivate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerRemoteWillDeactivate_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(MusicPlayerRemoteWillDeactivate_t)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerRemoteToFront_t {
    pub _address: u8,
}
pub const MusicPlayerRemoteToFront_t_k_iCallback: MusicPlayerRemoteToFront_t__bindgen_ty_1 = 4103;
pub type MusicPlayerRemoteToFront_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_MusicPlayerRemoteToFront_t() {
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerRemoteToFront_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerRemoteToFront_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerRemoteToFront_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerRemoteToFront_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWillQuit_t {
    pub _address: u8,
}
pub const MusicPlayerWillQuit_t_k_iCallback: MusicPlayerWillQuit_t__bindgen_ty_1 = 4104;
pub type MusicPlayerWillQuit_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_MusicPlayerWillQuit_t() {
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWillQuit_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerWillQuit_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWillQuit_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerWillQuit_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWantsPlay_t {
    pub _address: u8,
}
pub const MusicPlayerWantsPlay_t_k_iCallback: MusicPlayerWantsPlay_t__bindgen_ty_1 = 4105;
pub type MusicPlayerWantsPlay_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_MusicPlayerWantsPlay_t() {
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWantsPlay_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerWantsPlay_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWantsPlay_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerWantsPlay_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWantsPause_t {
    pub _address: u8,
}
pub const MusicPlayerWantsPause_t_k_iCallback: MusicPlayerWantsPause_t__bindgen_ty_1 = 4106;
pub type MusicPlayerWantsPause_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_MusicPlayerWantsPause_t() {
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWantsPause_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerWantsPause_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWantsPause_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerWantsPause_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWantsPlayPrevious_t {
    pub _address: u8,
}
pub const MusicPlayerWantsPlayPrevious_t_k_iCallback: MusicPlayerWantsPlayPrevious_t__bindgen_ty_1 =
    4107;
pub type MusicPlayerWantsPlayPrevious_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_MusicPlayerWantsPlayPrevious_t() {
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWantsPlayPrevious_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerWantsPlayPrevious_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWantsPlayPrevious_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerWantsPlayPrevious_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWantsPlayNext_t {
    pub _address: u8,
}
pub const MusicPlayerWantsPlayNext_t_k_iCallback: MusicPlayerWantsPlayNext_t__bindgen_ty_1 = 4108;
pub type MusicPlayerWantsPlayNext_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_MusicPlayerWantsPlayNext_t() {
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWantsPlayNext_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerWantsPlayNext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWantsPlayNext_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerWantsPlayNext_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWantsShuffled_t {
    pub m_bShuffled: bool,
}
pub const MusicPlayerWantsShuffled_t_k_iCallback: MusicPlayerWantsShuffled_t__bindgen_ty_1 = 4109;
pub type MusicPlayerWantsShuffled_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_MusicPlayerWantsShuffled_t() {
    const UNINIT: ::std::mem::MaybeUninit<MusicPlayerWantsShuffled_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWantsShuffled_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerWantsShuffled_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWantsShuffled_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerWantsShuffled_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bShuffled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicPlayerWantsShuffled_t),
            "::",
            stringify!(m_bShuffled)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWantsLooped_t {
    pub m_bLooped: bool,
}
pub const MusicPlayerWantsLooped_t_k_iCallback: MusicPlayerWantsLooped_t__bindgen_ty_1 = 4110;
pub type MusicPlayerWantsLooped_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_MusicPlayerWantsLooped_t() {
    const UNINIT: ::std::mem::MaybeUninit<MusicPlayerWantsLooped_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWantsLooped_t>(),
        1usize,
        concat!("Size of: ", stringify!(MusicPlayerWantsLooped_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWantsLooped_t>(),
        1usize,
        concat!("Alignment of ", stringify!(MusicPlayerWantsLooped_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bLooped) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicPlayerWantsLooped_t),
            "::",
            stringify!(m_bLooped)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWantsVolume_t {
    pub m_flNewVolume: f32,
}
pub const MusicPlayerWantsVolume_t_k_iCallback: MusicPlayerWantsVolume_t__bindgen_ty_1 = 4011;
pub type MusicPlayerWantsVolume_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_MusicPlayerWantsVolume_t() {
    const UNINIT: ::std::mem::MaybeUninit<MusicPlayerWantsVolume_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWantsVolume_t>(),
        4usize,
        concat!("Size of: ", stringify!(MusicPlayerWantsVolume_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWantsVolume_t>(),
        4usize,
        concat!("Alignment of ", stringify!(MusicPlayerWantsVolume_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flNewVolume) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicPlayerWantsVolume_t),
            "::",
            stringify!(m_flNewVolume)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerSelectsQueueEntry_t {
    pub nID: ::std::os::raw::c_int,
}
pub const MusicPlayerSelectsQueueEntry_t_k_iCallback: MusicPlayerSelectsQueueEntry_t__bindgen_ty_1 =
    4012;
pub type MusicPlayerSelectsQueueEntry_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_MusicPlayerSelectsQueueEntry_t() {
    const UNINIT: ::std::mem::MaybeUninit<MusicPlayerSelectsQueueEntry_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerSelectsQueueEntry_t>(),
        4usize,
        concat!("Size of: ", stringify!(MusicPlayerSelectsQueueEntry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerSelectsQueueEntry_t>(),
        4usize,
        concat!("Alignment of ", stringify!(MusicPlayerSelectsQueueEntry_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicPlayerSelectsQueueEntry_t),
            "::",
            stringify!(nID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerSelectsPlaylistEntry_t {
    pub nID: ::std::os::raw::c_int,
}
pub const MusicPlayerSelectsPlaylistEntry_t_k_iCallback:
    MusicPlayerSelectsPlaylistEntry_t__bindgen_ty_1 = 4013;
pub type MusicPlayerSelectsPlaylistEntry_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_MusicPlayerSelectsPlaylistEntry_t() {
    const UNINIT: ::std::mem::MaybeUninit<MusicPlayerSelectsPlaylistEntry_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerSelectsPlaylistEntry_t>(),
        4usize,
        concat!("Size of: ", stringify!(MusicPlayerSelectsPlaylistEntry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerSelectsPlaylistEntry_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MusicPlayerSelectsPlaylistEntry_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicPlayerSelectsPlaylistEntry_t),
            "::",
            stringify!(nID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicPlayerWantsPlayingRepeatStatus_t {
    pub m_nPlayingRepeatStatus: ::std::os::raw::c_int,
}
pub const MusicPlayerWantsPlayingRepeatStatus_t_k_iCallback:
    MusicPlayerWantsPlayingRepeatStatus_t__bindgen_ty_1 = 4114;
pub type MusicPlayerWantsPlayingRepeatStatus_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_MusicPlayerWantsPlayingRepeatStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<MusicPlayerWantsPlayingRepeatStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MusicPlayerWantsPlayingRepeatStatus_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(MusicPlayerWantsPlayingRepeatStatus_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MusicPlayerWantsPlayingRepeatStatus_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MusicPlayerWantsPlayingRepeatStatus_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPlayingRepeatStatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MusicPlayerWantsPlayingRepeatStatus_t),
            "::",
            stringify!(m_nPlayingRepeatStatus)
        )
    );
}
pub const EHTTPMethod_k_EHTTPMethodInvalid: EHTTPMethod = 0;
pub const EHTTPMethod_k_EHTTPMethodGET: EHTTPMethod = 1;
pub const EHTTPMethod_k_EHTTPMethodHEAD: EHTTPMethod = 2;
pub const EHTTPMethod_k_EHTTPMethodPOST: EHTTPMethod = 3;
pub const EHTTPMethod_k_EHTTPMethodPUT: EHTTPMethod = 4;
pub const EHTTPMethod_k_EHTTPMethodDELETE: EHTTPMethod = 5;
pub const EHTTPMethod_k_EHTTPMethodOPTIONS: EHTTPMethod = 6;
pub const EHTTPMethod_k_EHTTPMethodPATCH: EHTTPMethod = 7;
pub type EHTTPMethod = ::std::os::raw::c_int;
pub const EHTTPStatusCode_k_EHTTPStatusCodeInvalid: EHTTPStatusCode = 0;
pub const EHTTPStatusCode_k_EHTTPStatusCode100Continue: EHTTPStatusCode = 100;
pub const EHTTPStatusCode_k_EHTTPStatusCode101SwitchingProtocols: EHTTPStatusCode = 101;
pub const EHTTPStatusCode_k_EHTTPStatusCode200OK: EHTTPStatusCode = 200;
pub const EHTTPStatusCode_k_EHTTPStatusCode201Created: EHTTPStatusCode = 201;
pub const EHTTPStatusCode_k_EHTTPStatusCode202Accepted: EHTTPStatusCode = 202;
pub const EHTTPStatusCode_k_EHTTPStatusCode203NonAuthoritative: EHTTPStatusCode = 203;
pub const EHTTPStatusCode_k_EHTTPStatusCode204NoContent: EHTTPStatusCode = 204;
pub const EHTTPStatusCode_k_EHTTPStatusCode205ResetContent: EHTTPStatusCode = 205;
pub const EHTTPStatusCode_k_EHTTPStatusCode206PartialContent: EHTTPStatusCode = 206;
pub const EHTTPStatusCode_k_EHTTPStatusCode300MultipleChoices: EHTTPStatusCode = 300;
pub const EHTTPStatusCode_k_EHTTPStatusCode301MovedPermanently: EHTTPStatusCode = 301;
pub const EHTTPStatusCode_k_EHTTPStatusCode302Found: EHTTPStatusCode = 302;
pub const EHTTPStatusCode_k_EHTTPStatusCode303SeeOther: EHTTPStatusCode = 303;
pub const EHTTPStatusCode_k_EHTTPStatusCode304NotModified: EHTTPStatusCode = 304;
pub const EHTTPStatusCode_k_EHTTPStatusCode305UseProxy: EHTTPStatusCode = 305;
pub const EHTTPStatusCode_k_EHTTPStatusCode307TemporaryRedirect: EHTTPStatusCode = 307;
pub const EHTTPStatusCode_k_EHTTPStatusCode308PermanentRedirect: EHTTPStatusCode = 308;
pub const EHTTPStatusCode_k_EHTTPStatusCode400BadRequest: EHTTPStatusCode = 400;
pub const EHTTPStatusCode_k_EHTTPStatusCode401Unauthorized: EHTTPStatusCode = 401;
pub const EHTTPStatusCode_k_EHTTPStatusCode402PaymentRequired: EHTTPStatusCode = 402;
pub const EHTTPStatusCode_k_EHTTPStatusCode403Forbidden: EHTTPStatusCode = 403;
pub const EHTTPStatusCode_k_EHTTPStatusCode404NotFound: EHTTPStatusCode = 404;
pub const EHTTPStatusCode_k_EHTTPStatusCode405MethodNotAllowed: EHTTPStatusCode = 405;
pub const EHTTPStatusCode_k_EHTTPStatusCode406NotAcceptable: EHTTPStatusCode = 406;
pub const EHTTPStatusCode_k_EHTTPStatusCode407ProxyAuthRequired: EHTTPStatusCode = 407;
pub const EHTTPStatusCode_k_EHTTPStatusCode408RequestTimeout: EHTTPStatusCode = 408;
pub const EHTTPStatusCode_k_EHTTPStatusCode409Conflict: EHTTPStatusCode = 409;
pub const EHTTPStatusCode_k_EHTTPStatusCode410Gone: EHTTPStatusCode = 410;
pub const EHTTPStatusCode_k_EHTTPStatusCode411LengthRequired: EHTTPStatusCode = 411;
pub const EHTTPStatusCode_k_EHTTPStatusCode412PreconditionFailed: EHTTPStatusCode = 412;
pub const EHTTPStatusCode_k_EHTTPStatusCode413RequestEntityTooLarge: EHTTPStatusCode = 413;
pub const EHTTPStatusCode_k_EHTTPStatusCode414RequestURITooLong: EHTTPStatusCode = 414;
pub const EHTTPStatusCode_k_EHTTPStatusCode415UnsupportedMediaType: EHTTPStatusCode = 415;
pub const EHTTPStatusCode_k_EHTTPStatusCode416RequestedRangeNotSatisfiable: EHTTPStatusCode = 416;
pub const EHTTPStatusCode_k_EHTTPStatusCode417ExpectationFailed: EHTTPStatusCode = 417;
pub const EHTTPStatusCode_k_EHTTPStatusCode4xxUnknown: EHTTPStatusCode = 418;
pub const EHTTPStatusCode_k_EHTTPStatusCode429TooManyRequests: EHTTPStatusCode = 429;
pub const EHTTPStatusCode_k_EHTTPStatusCode444ConnectionClosed: EHTTPStatusCode = 444;
pub const EHTTPStatusCode_k_EHTTPStatusCode500InternalServerError: EHTTPStatusCode = 500;
pub const EHTTPStatusCode_k_EHTTPStatusCode501NotImplemented: EHTTPStatusCode = 501;
pub const EHTTPStatusCode_k_EHTTPStatusCode502BadGateway: EHTTPStatusCode = 502;
pub const EHTTPStatusCode_k_EHTTPStatusCode503ServiceUnavailable: EHTTPStatusCode = 503;
pub const EHTTPStatusCode_k_EHTTPStatusCode504GatewayTimeout: EHTTPStatusCode = 504;
pub const EHTTPStatusCode_k_EHTTPStatusCode505HTTPVersionNotSupported: EHTTPStatusCode = 505;
pub const EHTTPStatusCode_k_EHTTPStatusCode5xxUnknown: EHTTPStatusCode = 599;
pub type EHTTPStatusCode = ::std::os::raw::c_int;
pub type HTTPRequestHandle = uint32;
pub type HTTPCookieContainerHandle = uint32;
#[repr(C)]
pub struct ISteamHTTP__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamHTTP {
    pub vtable_: *const ISteamHTTP__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamHTTP() {
    assert_eq!(
        ::std::mem::size_of::<ISteamHTTP>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamHTTP))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamHTTP>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamHTTP))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTTPRequestCompleted_t {
    pub m_hRequest: HTTPRequestHandle,
    pub m_ulContextValue: uint64,
    pub m_bRequestSuccessful: bool,
    pub m_eStatusCode: EHTTPStatusCode,
    pub m_unBodySize: uint32,
}
pub const HTTPRequestCompleted_t_k_iCallback: HTTPRequestCompleted_t__bindgen_ty_1 = 2101;
pub type HTTPRequestCompleted_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTTPRequestCompleted_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTTPRequestCompleted_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTTPRequestCompleted_t>(),
        32usize,
        concat!("Size of: ", stringify!(HTTPRequestCompleted_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTTPRequestCompleted_t>(),
        8usize,
        concat!("Alignment of ", stringify!(HTTPRequestCompleted_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hRequest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestCompleted_t),
            "::",
            stringify!(m_hRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulContextValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestCompleted_t),
            "::",
            stringify!(m_ulContextValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bRequestSuccessful) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestCompleted_t),
            "::",
            stringify!(m_bRequestSuccessful)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eStatusCode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestCompleted_t),
            "::",
            stringify!(m_eStatusCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unBodySize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestCompleted_t),
            "::",
            stringify!(m_unBodySize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTTPRequestHeadersReceived_t {
    pub m_hRequest: HTTPRequestHandle,
    pub m_ulContextValue: uint64,
}
pub const HTTPRequestHeadersReceived_t_k_iCallback: HTTPRequestHeadersReceived_t__bindgen_ty_1 =
    2102;
pub type HTTPRequestHeadersReceived_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTTPRequestHeadersReceived_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTTPRequestHeadersReceived_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTTPRequestHeadersReceived_t>(),
        16usize,
        concat!("Size of: ", stringify!(HTTPRequestHeadersReceived_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTTPRequestHeadersReceived_t>(),
        8usize,
        concat!("Alignment of ", stringify!(HTTPRequestHeadersReceived_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hRequest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestHeadersReceived_t),
            "::",
            stringify!(m_hRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulContextValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestHeadersReceived_t),
            "::",
            stringify!(m_ulContextValue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTTPRequestDataReceived_t {
    pub m_hRequest: HTTPRequestHandle,
    pub m_ulContextValue: uint64,
    pub m_cOffset: uint32,
    pub m_cBytesReceived: uint32,
}
pub const HTTPRequestDataReceived_t_k_iCallback: HTTPRequestDataReceived_t__bindgen_ty_1 = 2103;
pub type HTTPRequestDataReceived_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTTPRequestDataReceived_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTTPRequestDataReceived_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTTPRequestDataReceived_t>(),
        24usize,
        concat!("Size of: ", stringify!(HTTPRequestDataReceived_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTTPRequestDataReceived_t>(),
        8usize,
        concat!("Alignment of ", stringify!(HTTPRequestDataReceived_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hRequest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestDataReceived_t),
            "::",
            stringify!(m_hRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulContextValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestDataReceived_t),
            "::",
            stringify!(m_ulContextValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestDataReceived_t),
            "::",
            stringify!(m_cOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cBytesReceived) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HTTPRequestDataReceived_t),
            "::",
            stringify!(m_cBytesReceived)
        )
    );
}
pub const EInputSourceMode_k_EInputSourceMode_None: EInputSourceMode = 0;
pub const EInputSourceMode_k_EInputSourceMode_Dpad: EInputSourceMode = 1;
pub const EInputSourceMode_k_EInputSourceMode_Buttons: EInputSourceMode = 2;
pub const EInputSourceMode_k_EInputSourceMode_FourButtons: EInputSourceMode = 3;
pub const EInputSourceMode_k_EInputSourceMode_AbsoluteMouse: EInputSourceMode = 4;
pub const EInputSourceMode_k_EInputSourceMode_RelativeMouse: EInputSourceMode = 5;
pub const EInputSourceMode_k_EInputSourceMode_JoystickMove: EInputSourceMode = 6;
pub const EInputSourceMode_k_EInputSourceMode_JoystickMouse: EInputSourceMode = 7;
pub const EInputSourceMode_k_EInputSourceMode_JoystickCamera: EInputSourceMode = 8;
pub const EInputSourceMode_k_EInputSourceMode_ScrollWheel: EInputSourceMode = 9;
pub const EInputSourceMode_k_EInputSourceMode_Trigger: EInputSourceMode = 10;
pub const EInputSourceMode_k_EInputSourceMode_TouchMenu: EInputSourceMode = 11;
pub const EInputSourceMode_k_EInputSourceMode_MouseJoystick: EInputSourceMode = 12;
pub const EInputSourceMode_k_EInputSourceMode_MouseRegion: EInputSourceMode = 13;
pub const EInputSourceMode_k_EInputSourceMode_RadialMenu: EInputSourceMode = 14;
pub const EInputSourceMode_k_EInputSourceMode_SingleButton: EInputSourceMode = 15;
pub const EInputSourceMode_k_EInputSourceMode_Switches: EInputSourceMode = 16;
pub type EInputSourceMode = ::std::os::raw::c_int;
pub const EInputActionOrigin_k_EInputActionOrigin_None: EInputActionOrigin = 0;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_A: EInputActionOrigin = 1;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_B: EInputActionOrigin = 2;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_X: EInputActionOrigin = 3;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Y: EInputActionOrigin = 4;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_LeftBumper: EInputActionOrigin =
    5;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_RightBumper: EInputActionOrigin =
    6;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_LeftGrip: EInputActionOrigin = 7;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_RightGrip: EInputActionOrigin = 8;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Start: EInputActionOrigin = 9;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Back: EInputActionOrigin = 10;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_LeftPad_Touch:
    EInputActionOrigin = 11;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_LeftPad_Swipe:
    EInputActionOrigin = 12;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_LeftPad_Click:
    EInputActionOrigin = 13;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_LeftPad_DPadNorth:
    EInputActionOrigin = 14;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_LeftPad_DPadSouth:
    EInputActionOrigin = 15;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_LeftPad_DPadWest:
    EInputActionOrigin = 16;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_LeftPad_DPadEast:
    EInputActionOrigin = 17;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_RightPad_Touch:
    EInputActionOrigin = 18;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_RightPad_Swipe:
    EInputActionOrigin = 19;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_RightPad_Click:
    EInputActionOrigin = 20;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_RightPad_DPadNorth:
    EInputActionOrigin = 21;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_RightPad_DPadSouth:
    EInputActionOrigin = 22;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_RightPad_DPadWest:
    EInputActionOrigin = 23;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_RightPad_DPadEast:
    EInputActionOrigin = 24;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_LeftTrigger_Pull:
    EInputActionOrigin = 25;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_LeftTrigger_Click:
    EInputActionOrigin = 26;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_RightTrigger_Pull:
    EInputActionOrigin = 27;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_RightTrigger_Click:
    EInputActionOrigin = 28;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_LeftStick_Move:
    EInputActionOrigin = 29;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_LeftStick_Click:
    EInputActionOrigin = 30;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_LeftStick_DPadNorth:
    EInputActionOrigin = 31;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_LeftStick_DPadSouth:
    EInputActionOrigin = 32;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_LeftStick_DPadWest:
    EInputActionOrigin = 33;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_LeftStick_DPadEast:
    EInputActionOrigin = 34;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Gyro_Move: EInputActionOrigin =
    35;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Gyro_Pitch: EInputActionOrigin =
    36;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Gyro_Yaw: EInputActionOrigin = 37;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Gyro_Roll: EInputActionOrigin =
    38;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Reserved0: EInputActionOrigin =
    39;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Reserved1: EInputActionOrigin =
    40;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Reserved2: EInputActionOrigin =
    41;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Reserved3: EInputActionOrigin =
    42;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Reserved4: EInputActionOrigin =
    43;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Reserved5: EInputActionOrigin =
    44;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Reserved6: EInputActionOrigin =
    45;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Reserved7: EInputActionOrigin =
    46;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Reserved8: EInputActionOrigin =
    47;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Reserved9: EInputActionOrigin =
    48;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamController_Reserved10: EInputActionOrigin =
    49;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_X: EInputActionOrigin = 50;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Circle: EInputActionOrigin = 51;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Triangle: EInputActionOrigin = 52;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Square: EInputActionOrigin = 53;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_LeftBumper: EInputActionOrigin = 54;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_RightBumper: EInputActionOrigin = 55;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Options: EInputActionOrigin = 56;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Share: EInputActionOrigin = 57;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_LeftPad_Touch: EInputActionOrigin = 58;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_LeftPad_Swipe: EInputActionOrigin = 59;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_LeftPad_Click: EInputActionOrigin = 60;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_LeftPad_DPadNorth: EInputActionOrigin = 61;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_LeftPad_DPadSouth: EInputActionOrigin = 62;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_LeftPad_DPadWest: EInputActionOrigin = 63;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_LeftPad_DPadEast: EInputActionOrigin = 64;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_RightPad_Touch: EInputActionOrigin = 65;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_RightPad_Swipe: EInputActionOrigin = 66;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_RightPad_Click: EInputActionOrigin = 67;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_RightPad_DPadNorth: EInputActionOrigin = 68;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_RightPad_DPadSouth: EInputActionOrigin = 69;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_RightPad_DPadWest: EInputActionOrigin = 70;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_RightPad_DPadEast: EInputActionOrigin = 71;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_CenterPad_Touch: EInputActionOrigin = 72;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_CenterPad_Swipe: EInputActionOrigin = 73;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_CenterPad_Click: EInputActionOrigin = 74;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_CenterPad_DPadNorth: EInputActionOrigin = 75;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_CenterPad_DPadSouth: EInputActionOrigin = 76;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_CenterPad_DPadWest: EInputActionOrigin = 77;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_CenterPad_DPadEast: EInputActionOrigin = 78;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_LeftTrigger_Pull: EInputActionOrigin = 79;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_LeftTrigger_Click: EInputActionOrigin = 80;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_RightTrigger_Pull: EInputActionOrigin = 81;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_RightTrigger_Click: EInputActionOrigin = 82;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_LeftStick_Move: EInputActionOrigin = 83;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_LeftStick_Click: EInputActionOrigin = 84;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_LeftStick_DPadNorth: EInputActionOrigin = 85;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_LeftStick_DPadSouth: EInputActionOrigin = 86;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_LeftStick_DPadWest: EInputActionOrigin = 87;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_LeftStick_DPadEast: EInputActionOrigin = 88;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_RightStick_Move: EInputActionOrigin = 89;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_RightStick_Click: EInputActionOrigin = 90;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_RightStick_DPadNorth: EInputActionOrigin = 91;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_RightStick_DPadSouth: EInputActionOrigin = 92;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_RightStick_DPadWest: EInputActionOrigin = 93;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_RightStick_DPadEast: EInputActionOrigin = 94;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_DPad_North: EInputActionOrigin = 95;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_DPad_South: EInputActionOrigin = 96;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_DPad_West: EInputActionOrigin = 97;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_DPad_East: EInputActionOrigin = 98;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Gyro_Move: EInputActionOrigin = 99;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Gyro_Pitch: EInputActionOrigin = 100;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Gyro_Yaw: EInputActionOrigin = 101;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Gyro_Roll: EInputActionOrigin = 102;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_DPad_Move: EInputActionOrigin = 103;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Reserved1: EInputActionOrigin = 104;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Reserved2: EInputActionOrigin = 105;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Reserved3: EInputActionOrigin = 106;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Reserved4: EInputActionOrigin = 107;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Reserved5: EInputActionOrigin = 108;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Reserved6: EInputActionOrigin = 109;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Reserved7: EInputActionOrigin = 110;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Reserved8: EInputActionOrigin = 111;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Reserved9: EInputActionOrigin = 112;
pub const EInputActionOrigin_k_EInputActionOrigin_PS4_Reserved10: EInputActionOrigin = 113;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_A: EInputActionOrigin = 114;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_B: EInputActionOrigin = 115;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_X: EInputActionOrigin = 116;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_Y: EInputActionOrigin = 117;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_LeftBumper: EInputActionOrigin = 118;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_RightBumper: EInputActionOrigin = 119;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_Menu: EInputActionOrigin = 120;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_View: EInputActionOrigin = 121;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_LeftTrigger_Pull: EInputActionOrigin =
    122;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_LeftTrigger_Click: EInputActionOrigin =
    123;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_RightTrigger_Pull: EInputActionOrigin =
    124;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_RightTrigger_Click: EInputActionOrigin =
    125;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_LeftStick_Move: EInputActionOrigin = 126;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_LeftStick_Click: EInputActionOrigin = 127;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_LeftStick_DPadNorth: EInputActionOrigin =
    128;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_LeftStick_DPadSouth: EInputActionOrigin =
    129;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_LeftStick_DPadWest: EInputActionOrigin =
    130;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_LeftStick_DPadEast: EInputActionOrigin =
    131;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_RightStick_Move: EInputActionOrigin = 132;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_RightStick_Click: EInputActionOrigin =
    133;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_RightStick_DPadNorth: EInputActionOrigin =
    134;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_RightStick_DPadSouth: EInputActionOrigin =
    135;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_RightStick_DPadWest: EInputActionOrigin =
    136;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_RightStick_DPadEast: EInputActionOrigin =
    137;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_DPad_North: EInputActionOrigin = 138;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_DPad_South: EInputActionOrigin = 139;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_DPad_West: EInputActionOrigin = 140;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_DPad_East: EInputActionOrigin = 141;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_DPad_Move: EInputActionOrigin = 142;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_LeftGrip_Lower: EInputActionOrigin = 143;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_LeftGrip_Upper: EInputActionOrigin = 144;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_RightGrip_Lower: EInputActionOrigin = 145;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_RightGrip_Upper: EInputActionOrigin = 146;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_Share: EInputActionOrigin = 147;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_Reserved6: EInputActionOrigin = 148;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_Reserved7: EInputActionOrigin = 149;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_Reserved8: EInputActionOrigin = 150;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_Reserved9: EInputActionOrigin = 151;
pub const EInputActionOrigin_k_EInputActionOrigin_XBoxOne_Reserved10: EInputActionOrigin = 152;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_A: EInputActionOrigin = 153;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_B: EInputActionOrigin = 154;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_X: EInputActionOrigin = 155;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_Y: EInputActionOrigin = 156;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_LeftBumper: EInputActionOrigin = 157;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_RightBumper: EInputActionOrigin = 158;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_Start: EInputActionOrigin = 159;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_Back: EInputActionOrigin = 160;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_LeftTrigger_Pull: EInputActionOrigin =
    161;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_LeftTrigger_Click: EInputActionOrigin =
    162;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_RightTrigger_Pull: EInputActionOrigin =
    163;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_RightTrigger_Click: EInputActionOrigin =
    164;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_LeftStick_Move: EInputActionOrigin = 165;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_LeftStick_Click: EInputActionOrigin = 166;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_LeftStick_DPadNorth: EInputActionOrigin =
    167;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_LeftStick_DPadSouth: EInputActionOrigin =
    168;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_LeftStick_DPadWest: EInputActionOrigin =
    169;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_LeftStick_DPadEast: EInputActionOrigin =
    170;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_RightStick_Move: EInputActionOrigin = 171;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_RightStick_Click: EInputActionOrigin =
    172;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_RightStick_DPadNorth: EInputActionOrigin =
    173;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_RightStick_DPadSouth: EInputActionOrigin =
    174;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_RightStick_DPadWest: EInputActionOrigin =
    175;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_RightStick_DPadEast: EInputActionOrigin =
    176;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_DPad_North: EInputActionOrigin = 177;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_DPad_South: EInputActionOrigin = 178;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_DPad_West: EInputActionOrigin = 179;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_DPad_East: EInputActionOrigin = 180;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_DPad_Move: EInputActionOrigin = 181;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_Reserved1: EInputActionOrigin = 182;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_Reserved2: EInputActionOrigin = 183;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_Reserved3: EInputActionOrigin = 184;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_Reserved4: EInputActionOrigin = 185;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_Reserved5: EInputActionOrigin = 186;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_Reserved6: EInputActionOrigin = 187;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_Reserved7: EInputActionOrigin = 188;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_Reserved8: EInputActionOrigin = 189;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_Reserved9: EInputActionOrigin = 190;
pub const EInputActionOrigin_k_EInputActionOrigin_XBox360_Reserved10: EInputActionOrigin = 191;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_A: EInputActionOrigin = 192;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_B: EInputActionOrigin = 193;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_X: EInputActionOrigin = 194;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Y: EInputActionOrigin = 195;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_LeftBumper: EInputActionOrigin = 196;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_RightBumper: EInputActionOrigin = 197;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Plus: EInputActionOrigin = 198;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Minus: EInputActionOrigin = 199;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Capture: EInputActionOrigin = 200;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_LeftTrigger_Pull: EInputActionOrigin = 201;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_LeftTrigger_Click: EInputActionOrigin =
    202;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_RightTrigger_Pull: EInputActionOrigin =
    203;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_RightTrigger_Click: EInputActionOrigin =
    204;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_LeftStick_Move: EInputActionOrigin = 205;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_LeftStick_Click: EInputActionOrigin = 206;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_LeftStick_DPadNorth: EInputActionOrigin =
    207;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_LeftStick_DPadSouth: EInputActionOrigin =
    208;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_LeftStick_DPadWest: EInputActionOrigin =
    209;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_LeftStick_DPadEast: EInputActionOrigin =
    210;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_RightStick_Move: EInputActionOrigin = 211;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_RightStick_Click: EInputActionOrigin = 212;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_RightStick_DPadNorth: EInputActionOrigin =
    213;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_RightStick_DPadSouth: EInputActionOrigin =
    214;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_RightStick_DPadWest: EInputActionOrigin =
    215;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_RightStick_DPadEast: EInputActionOrigin =
    216;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_DPad_North: EInputActionOrigin = 217;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_DPad_South: EInputActionOrigin = 218;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_DPad_West: EInputActionOrigin = 219;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_DPad_East: EInputActionOrigin = 220;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_ProGyro_Move: EInputActionOrigin = 221;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_ProGyro_Pitch: EInputActionOrigin = 222;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_ProGyro_Yaw: EInputActionOrigin = 223;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_ProGyro_Roll: EInputActionOrigin = 224;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_DPad_Move: EInputActionOrigin = 225;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Reserved1: EInputActionOrigin = 226;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Reserved2: EInputActionOrigin = 227;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Reserved3: EInputActionOrigin = 228;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Reserved4: EInputActionOrigin = 229;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Reserved5: EInputActionOrigin = 230;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Reserved6: EInputActionOrigin = 231;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Reserved7: EInputActionOrigin = 232;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Reserved8: EInputActionOrigin = 233;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Reserved9: EInputActionOrigin = 234;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Reserved10: EInputActionOrigin = 235;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_RightGyro_Move: EInputActionOrigin = 236;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_RightGyro_Pitch: EInputActionOrigin = 237;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_RightGyro_Yaw: EInputActionOrigin = 238;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_RightGyro_Roll: EInputActionOrigin = 239;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_LeftGyro_Move: EInputActionOrigin = 240;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_LeftGyro_Pitch: EInputActionOrigin = 241;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_LeftGyro_Yaw: EInputActionOrigin = 242;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_LeftGyro_Roll: EInputActionOrigin = 243;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_LeftGrip_Lower: EInputActionOrigin = 244;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_LeftGrip_Upper: EInputActionOrigin = 245;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_RightGrip_Lower: EInputActionOrigin = 246;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_RightGrip_Upper: EInputActionOrigin = 247;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_JoyConButton_N: EInputActionOrigin = 248;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_JoyConButton_E: EInputActionOrigin = 249;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_JoyConButton_S: EInputActionOrigin = 250;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_JoyConButton_W: EInputActionOrigin = 251;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Reserved15: EInputActionOrigin = 252;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Reserved16: EInputActionOrigin = 253;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Reserved17: EInputActionOrigin = 254;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Reserved18: EInputActionOrigin = 255;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Reserved19: EInputActionOrigin = 256;
pub const EInputActionOrigin_k_EInputActionOrigin_Switch_Reserved20: EInputActionOrigin = 257;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_X: EInputActionOrigin = 258;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Circle: EInputActionOrigin = 259;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Triangle: EInputActionOrigin = 260;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Square: EInputActionOrigin = 261;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftBumper: EInputActionOrigin = 262;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightBumper: EInputActionOrigin = 263;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Option: EInputActionOrigin = 264;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Create: EInputActionOrigin = 265;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Mute: EInputActionOrigin = 266;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftPad_Touch: EInputActionOrigin = 267;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftPad_Swipe: EInputActionOrigin = 268;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftPad_Click: EInputActionOrigin = 269;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftPad_DPadNorth: EInputActionOrigin = 270;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftPad_DPadSouth: EInputActionOrigin = 271;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftPad_DPadWest: EInputActionOrigin = 272;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftPad_DPadEast: EInputActionOrigin = 273;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightPad_Touch: EInputActionOrigin = 274;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightPad_Swipe: EInputActionOrigin = 275;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightPad_Click: EInputActionOrigin = 276;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightPad_DPadNorth: EInputActionOrigin = 277;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightPad_DPadSouth: EInputActionOrigin = 278;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightPad_DPadWest: EInputActionOrigin = 279;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightPad_DPadEast: EInputActionOrigin = 280;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_CenterPad_Touch: EInputActionOrigin = 281;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_CenterPad_Swipe: EInputActionOrigin = 282;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_CenterPad_Click: EInputActionOrigin = 283;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_CenterPad_DPadNorth: EInputActionOrigin = 284;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_CenterPad_DPadSouth: EInputActionOrigin = 285;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_CenterPad_DPadWest: EInputActionOrigin = 286;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_CenterPad_DPadEast: EInputActionOrigin = 287;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftTrigger_Pull: EInputActionOrigin = 288;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftTrigger_Click: EInputActionOrigin = 289;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightTrigger_Pull: EInputActionOrigin = 290;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightTrigger_Click: EInputActionOrigin = 291;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftStick_Move: EInputActionOrigin = 292;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftStick_Click: EInputActionOrigin = 293;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftStick_DPadNorth: EInputActionOrigin = 294;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftStick_DPadSouth: EInputActionOrigin = 295;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftStick_DPadWest: EInputActionOrigin = 296;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftStick_DPadEast: EInputActionOrigin = 297;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightStick_Move: EInputActionOrigin = 298;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightStick_Click: EInputActionOrigin = 299;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightStick_DPadNorth: EInputActionOrigin =
    300;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightStick_DPadSouth: EInputActionOrigin =
    301;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightStick_DPadWest: EInputActionOrigin = 302;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightStick_DPadEast: EInputActionOrigin = 303;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_DPad_North: EInputActionOrigin = 304;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_DPad_South: EInputActionOrigin = 305;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_DPad_West: EInputActionOrigin = 306;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_DPad_East: EInputActionOrigin = 307;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Gyro_Move: EInputActionOrigin = 308;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Gyro_Pitch: EInputActionOrigin = 309;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Gyro_Yaw: EInputActionOrigin = 310;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Gyro_Roll: EInputActionOrigin = 311;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_DPad_Move: EInputActionOrigin = 312;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftGrip: EInputActionOrigin = 313;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightGrip: EInputActionOrigin = 314;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_LeftFn: EInputActionOrigin = 315;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_RightFn: EInputActionOrigin = 316;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Reserved5: EInputActionOrigin = 317;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Reserved6: EInputActionOrigin = 318;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Reserved7: EInputActionOrigin = 319;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Reserved8: EInputActionOrigin = 320;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Reserved9: EInputActionOrigin = 321;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Reserved10: EInputActionOrigin = 322;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Reserved11: EInputActionOrigin = 323;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Reserved12: EInputActionOrigin = 324;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Reserved13: EInputActionOrigin = 325;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Reserved14: EInputActionOrigin = 326;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Reserved15: EInputActionOrigin = 327;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Reserved16: EInputActionOrigin = 328;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Reserved17: EInputActionOrigin = 329;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Reserved18: EInputActionOrigin = 330;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Reserved19: EInputActionOrigin = 331;
pub const EInputActionOrigin_k_EInputActionOrigin_PS5_Reserved20: EInputActionOrigin = 332;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_A: EInputActionOrigin = 333;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_B: EInputActionOrigin = 334;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_X: EInputActionOrigin = 335;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Y: EInputActionOrigin = 336;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_L1: EInputActionOrigin = 337;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_R1: EInputActionOrigin = 338;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Menu: EInputActionOrigin = 339;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_View: EInputActionOrigin = 340;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_LeftPad_Touch: EInputActionOrigin = 341;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_LeftPad_Swipe: EInputActionOrigin = 342;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_LeftPad_Click: EInputActionOrigin = 343;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_LeftPad_DPadNorth: EInputActionOrigin =
    344;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_LeftPad_DPadSouth: EInputActionOrigin =
    345;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_LeftPad_DPadWest: EInputActionOrigin =
    346;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_LeftPad_DPadEast: EInputActionOrigin =
    347;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_RightPad_Touch: EInputActionOrigin =
    348;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_RightPad_Swipe: EInputActionOrigin =
    349;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_RightPad_Click: EInputActionOrigin =
    350;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_RightPad_DPadNorth: EInputActionOrigin =
    351;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_RightPad_DPadSouth: EInputActionOrigin =
    352;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_RightPad_DPadWest: EInputActionOrigin =
    353;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_RightPad_DPadEast: EInputActionOrigin =
    354;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_L2_SoftPull: EInputActionOrigin = 355;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_L2: EInputActionOrigin = 356;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_R2_SoftPull: EInputActionOrigin = 357;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_R2: EInputActionOrigin = 358;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_LeftStick_Move: EInputActionOrigin =
    359;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_L3: EInputActionOrigin = 360;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_LeftStick_DPadNorth:
    EInputActionOrigin = 361;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_LeftStick_DPadSouth:
    EInputActionOrigin = 362;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_LeftStick_DPadWest: EInputActionOrigin =
    363;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_LeftStick_DPadEast: EInputActionOrigin =
    364;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_LeftStick_Touch: EInputActionOrigin =
    365;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_RightStick_Move: EInputActionOrigin =
    366;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_R3: EInputActionOrigin = 367;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_RightStick_DPadNorth:
    EInputActionOrigin = 368;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_RightStick_DPadSouth:
    EInputActionOrigin = 369;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_RightStick_DPadWest:
    EInputActionOrigin = 370;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_RightStick_DPadEast:
    EInputActionOrigin = 371;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_RightStick_Touch: EInputActionOrigin =
    372;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_L4: EInputActionOrigin = 373;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_R4: EInputActionOrigin = 374;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_L5: EInputActionOrigin = 375;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_R5: EInputActionOrigin = 376;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_DPad_Move: EInputActionOrigin = 377;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_DPad_North: EInputActionOrigin = 378;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_DPad_South: EInputActionOrigin = 379;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_DPad_West: EInputActionOrigin = 380;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_DPad_East: EInputActionOrigin = 381;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Gyro_Move: EInputActionOrigin = 382;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Gyro_Pitch: EInputActionOrigin = 383;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Gyro_Yaw: EInputActionOrigin = 384;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Gyro_Roll: EInputActionOrigin = 385;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved1: EInputActionOrigin = 386;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved2: EInputActionOrigin = 387;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved3: EInputActionOrigin = 388;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved4: EInputActionOrigin = 389;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved5: EInputActionOrigin = 390;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved6: EInputActionOrigin = 391;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved7: EInputActionOrigin = 392;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved8: EInputActionOrigin = 393;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved9: EInputActionOrigin = 394;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved10: EInputActionOrigin = 395;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved11: EInputActionOrigin = 396;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved12: EInputActionOrigin = 397;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved13: EInputActionOrigin = 398;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved14: EInputActionOrigin = 399;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved15: EInputActionOrigin = 400;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved16: EInputActionOrigin = 401;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved17: EInputActionOrigin = 402;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved18: EInputActionOrigin = 403;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved19: EInputActionOrigin = 404;
pub const EInputActionOrigin_k_EInputActionOrigin_SteamDeck_Reserved20: EInputActionOrigin = 405;
pub const EInputActionOrigin_k_EInputActionOrigin_Count: EInputActionOrigin = 406;
pub const EInputActionOrigin_k_EInputActionOrigin_MaximumPossibleValue: EInputActionOrigin = 32767;
pub type EInputActionOrigin = ::std::os::raw::c_int;
pub const EXboxOrigin_k_EXboxOrigin_A: EXboxOrigin = 0;
pub const EXboxOrigin_k_EXboxOrigin_B: EXboxOrigin = 1;
pub const EXboxOrigin_k_EXboxOrigin_X: EXboxOrigin = 2;
pub const EXboxOrigin_k_EXboxOrigin_Y: EXboxOrigin = 3;
pub const EXboxOrigin_k_EXboxOrigin_LeftBumper: EXboxOrigin = 4;
pub const EXboxOrigin_k_EXboxOrigin_RightBumper: EXboxOrigin = 5;
pub const EXboxOrigin_k_EXboxOrigin_Menu: EXboxOrigin = 6;
pub const EXboxOrigin_k_EXboxOrigin_View: EXboxOrigin = 7;
pub const EXboxOrigin_k_EXboxOrigin_LeftTrigger_Pull: EXboxOrigin = 8;
pub const EXboxOrigin_k_EXboxOrigin_LeftTrigger_Click: EXboxOrigin = 9;
pub const EXboxOrigin_k_EXboxOrigin_RightTrigger_Pull: EXboxOrigin = 10;
pub const EXboxOrigin_k_EXboxOrigin_RightTrigger_Click: EXboxOrigin = 11;
pub const EXboxOrigin_k_EXboxOrigin_LeftStick_Move: EXboxOrigin = 12;
pub const EXboxOrigin_k_EXboxOrigin_LeftStick_Click: EXboxOrigin = 13;
pub const EXboxOrigin_k_EXboxOrigin_LeftStick_DPadNorth: EXboxOrigin = 14;
pub const EXboxOrigin_k_EXboxOrigin_LeftStick_DPadSouth: EXboxOrigin = 15;
pub const EXboxOrigin_k_EXboxOrigin_LeftStick_DPadWest: EXboxOrigin = 16;
pub const EXboxOrigin_k_EXboxOrigin_LeftStick_DPadEast: EXboxOrigin = 17;
pub const EXboxOrigin_k_EXboxOrigin_RightStick_Move: EXboxOrigin = 18;
pub const EXboxOrigin_k_EXboxOrigin_RightStick_Click: EXboxOrigin = 19;
pub const EXboxOrigin_k_EXboxOrigin_RightStick_DPadNorth: EXboxOrigin = 20;
pub const EXboxOrigin_k_EXboxOrigin_RightStick_DPadSouth: EXboxOrigin = 21;
pub const EXboxOrigin_k_EXboxOrigin_RightStick_DPadWest: EXboxOrigin = 22;
pub const EXboxOrigin_k_EXboxOrigin_RightStick_DPadEast: EXboxOrigin = 23;
pub const EXboxOrigin_k_EXboxOrigin_DPad_North: EXboxOrigin = 24;
pub const EXboxOrigin_k_EXboxOrigin_DPad_South: EXboxOrigin = 25;
pub const EXboxOrigin_k_EXboxOrigin_DPad_West: EXboxOrigin = 26;
pub const EXboxOrigin_k_EXboxOrigin_DPad_East: EXboxOrigin = 27;
pub const EXboxOrigin_k_EXboxOrigin_Count: EXboxOrigin = 28;
pub type EXboxOrigin = ::std::os::raw::c_int;
pub const ESteamControllerPad_k_ESteamControllerPad_Left: ESteamControllerPad = 0;
pub const ESteamControllerPad_k_ESteamControllerPad_Right: ESteamControllerPad = 1;
pub type ESteamControllerPad = ::std::os::raw::c_int;
pub const EControllerHapticLocation_k_EControllerHapticLocation_Left: EControllerHapticLocation = 1;
pub const EControllerHapticLocation_k_EControllerHapticLocation_Right: EControllerHapticLocation =
    2;
pub const EControllerHapticLocation_k_EControllerHapticLocation_Both: EControllerHapticLocation = 3;
pub type EControllerHapticLocation = ::std::os::raw::c_int;
pub const EControllerHapticType_k_EControllerHapticType_Off: EControllerHapticType = 0;
pub const EControllerHapticType_k_EControllerHapticType_Tick: EControllerHapticType = 1;
pub const EControllerHapticType_k_EControllerHapticType_Click: EControllerHapticType = 2;
pub type EControllerHapticType = ::std::os::raw::c_int;
pub const ESteamInputType_k_ESteamInputType_Unknown: ESteamInputType = 0;
pub const ESteamInputType_k_ESteamInputType_SteamController: ESteamInputType = 1;
pub const ESteamInputType_k_ESteamInputType_XBox360Controller: ESteamInputType = 2;
pub const ESteamInputType_k_ESteamInputType_XBoxOneController: ESteamInputType = 3;
pub const ESteamInputType_k_ESteamInputType_GenericGamepad: ESteamInputType = 4;
pub const ESteamInputType_k_ESteamInputType_PS4Controller: ESteamInputType = 5;
pub const ESteamInputType_k_ESteamInputType_AppleMFiController: ESteamInputType = 6;
pub const ESteamInputType_k_ESteamInputType_AndroidController: ESteamInputType = 7;
pub const ESteamInputType_k_ESteamInputType_SwitchJoyConPair: ESteamInputType = 8;
pub const ESteamInputType_k_ESteamInputType_SwitchJoyConSingle: ESteamInputType = 9;
pub const ESteamInputType_k_ESteamInputType_SwitchProController: ESteamInputType = 10;
pub const ESteamInputType_k_ESteamInputType_MobileTouch: ESteamInputType = 11;
pub const ESteamInputType_k_ESteamInputType_PS3Controller: ESteamInputType = 12;
pub const ESteamInputType_k_ESteamInputType_PS5Controller: ESteamInputType = 13;
pub const ESteamInputType_k_ESteamInputType_SteamDeckController: ESteamInputType = 14;
pub const ESteamInputType_k_ESteamInputType_Count: ESteamInputType = 15;
pub const ESteamInputType_k_ESteamInputType_MaximumPossibleValue: ESteamInputType = 255;
pub type ESteamInputType = ::std::os::raw::c_int;
pub const ESteamInputConfigurationEnableType_k_ESteamInputConfigurationEnableType_None:
    ESteamInputConfigurationEnableType = 0;
pub const ESteamInputConfigurationEnableType_k_ESteamInputConfigurationEnableType_Playstation:
    ESteamInputConfigurationEnableType = 1;
pub const ESteamInputConfigurationEnableType_k_ESteamInputConfigurationEnableType_Xbox:
    ESteamInputConfigurationEnableType = 2;
pub const ESteamInputConfigurationEnableType_k_ESteamInputConfigurationEnableType_Generic:
    ESteamInputConfigurationEnableType = 4;
pub const ESteamInputConfigurationEnableType_k_ESteamInputConfigurationEnableType_Switch:
    ESteamInputConfigurationEnableType = 8;
pub type ESteamInputConfigurationEnableType = ::std::os::raw::c_int;
pub const ESteamInputLEDFlag_k_ESteamInputLEDFlag_SetColor: ESteamInputLEDFlag = 0;
pub const ESteamInputLEDFlag_k_ESteamInputLEDFlag_RestoreUserDefault: ESteamInputLEDFlag = 1;
pub type ESteamInputLEDFlag = ::std::os::raw::c_int;
pub const ESteamInputGlyphSize_k_ESteamInputGlyphSize_Small: ESteamInputGlyphSize = 0;
pub const ESteamInputGlyphSize_k_ESteamInputGlyphSize_Medium: ESteamInputGlyphSize = 1;
pub const ESteamInputGlyphSize_k_ESteamInputGlyphSize_Large: ESteamInputGlyphSize = 2;
pub const ESteamInputGlyphSize_k_ESteamInputGlyphSize_Count: ESteamInputGlyphSize = 3;
pub type ESteamInputGlyphSize = ::std::os::raw::c_int;
pub const ESteamInputGlyphStyle_ESteamInputGlyphStyle_Knockout: ESteamInputGlyphStyle = 0;
pub const ESteamInputGlyphStyle_ESteamInputGlyphStyle_Light: ESteamInputGlyphStyle = 1;
pub const ESteamInputGlyphStyle_ESteamInputGlyphStyle_Dark: ESteamInputGlyphStyle = 2;
pub const ESteamInputGlyphStyle_ESteamInputGlyphStyle_NeutralColorABXY: ESteamInputGlyphStyle = 16;
pub const ESteamInputGlyphStyle_ESteamInputGlyphStyle_SolidABXY: ESteamInputGlyphStyle = 32;
pub type ESteamInputGlyphStyle = ::std::os::raw::c_int;
pub const ESteamInputActionEventType_ESteamInputActionEventType_DigitalAction:
    ESteamInputActionEventType = 0;
pub const ESteamInputActionEventType_ESteamInputActionEventType_AnalogAction:
    ESteamInputActionEventType = 1;
pub type ESteamInputActionEventType = ::std::os::raw::c_int;
pub type InputHandle_t = uint64;
pub type InputActionSetHandle_t = uint64;
pub type InputDigitalActionHandle_t = uint64;
pub type InputAnalogActionHandle_t = uint64;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct InputAnalogActionData_t {
    pub eMode: EInputSourceMode,
    pub x: f32,
    pub y: f32,
    pub bActive: bool,
}
#[test]
fn bindgen_test_layout_InputAnalogActionData_t() {
    const UNINIT: ::std::mem::MaybeUninit<InputAnalogActionData_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<InputAnalogActionData_t>(),
        13usize,
        concat!("Size of: ", stringify!(InputAnalogActionData_t))
    );
    assert_eq!(
        ::std::mem::align_of::<InputAnalogActionData_t>(),
        1usize,
        concat!("Alignment of ", stringify!(InputAnalogActionData_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputAnalogActionData_t),
            "::",
            stringify!(eMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(InputAnalogActionData_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InputAnalogActionData_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bActive) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(InputAnalogActionData_t),
            "::",
            stringify!(bActive)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InputDigitalActionData_t {
    pub bState: bool,
    pub bActive: bool,
}
#[test]
fn bindgen_test_layout_InputDigitalActionData_t() {
    const UNINIT: ::std::mem::MaybeUninit<InputDigitalActionData_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<InputDigitalActionData_t>(),
        2usize,
        concat!("Size of: ", stringify!(InputDigitalActionData_t))
    );
    assert_eq!(
        ::std::mem::align_of::<InputDigitalActionData_t>(),
        1usize,
        concat!("Alignment of ", stringify!(InputDigitalActionData_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputDigitalActionData_t),
            "::",
            stringify!(bState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bActive) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(InputDigitalActionData_t),
            "::",
            stringify!(bActive)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct InputMotionData_t {
    pub rotQuatX: f32,
    pub rotQuatY: f32,
    pub rotQuatZ: f32,
    pub rotQuatW: f32,
    pub posAccelX: f32,
    pub posAccelY: f32,
    pub posAccelZ: f32,
    pub rotVelX: f32,
    pub rotVelY: f32,
    pub rotVelZ: f32,
}
#[test]
fn bindgen_test_layout_InputMotionData_t() {
    const UNINIT: ::std::mem::MaybeUninit<InputMotionData_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<InputMotionData_t>(),
        40usize,
        concat!("Size of: ", stringify!(InputMotionData_t))
    );
    assert_eq!(
        ::std::mem::align_of::<InputMotionData_t>(),
        1usize,
        concat!("Alignment of ", stringify!(InputMotionData_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotQuatX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotQuatX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotQuatY) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotQuatY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotQuatZ) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotQuatZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotQuatW) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotQuatW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posAccelX) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(posAccelX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posAccelY) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(posAccelY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posAccelZ) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(posAccelZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotVelX) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotVelX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotVelY) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotVelY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotVelZ) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(InputMotionData_t),
            "::",
            stringify!(rotVelZ)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamInputActionEvent_t {
    pub controllerHandle: InputHandle_t,
    pub eEventType: ESteamInputActionEventType,
    pub __bindgen_anon_1: SteamInputActionEvent_t__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInputActionEvent_t_AnalogAction_t {
    pub actionHandle: InputAnalogActionHandle_t,
    pub analogActionData: InputAnalogActionData_t,
}
#[test]
fn bindgen_test_layout_SteamInputActionEvent_t_AnalogAction_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputActionEvent_t_AnalogAction_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputActionEvent_t_AnalogAction_t>(),
        21usize,
        concat!(
            "Size of: ",
            stringify!(SteamInputActionEvent_t_AnalogAction_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputActionEvent_t_AnalogAction_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInputActionEvent_t_AnalogAction_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actionHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t_AnalogAction_t),
            "::",
            stringify!(actionHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogActionData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t_AnalogAction_t),
            "::",
            stringify!(analogActionData)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInputActionEvent_t_DigitalAction_t {
    pub actionHandle: InputDigitalActionHandle_t,
    pub digitalActionData: InputDigitalActionData_t,
}
#[test]
fn bindgen_test_layout_SteamInputActionEvent_t_DigitalAction_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputActionEvent_t_DigitalAction_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputActionEvent_t_DigitalAction_t>(),
        10usize,
        concat!(
            "Size of: ",
            stringify!(SteamInputActionEvent_t_DigitalAction_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputActionEvent_t_DigitalAction_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInputActionEvent_t_DigitalAction_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actionHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t_DigitalAction_t),
            "::",
            stringify!(actionHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digitalActionData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t_DigitalAction_t),
            "::",
            stringify!(digitalActionData)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SteamInputActionEvent_t__bindgen_ty_1 {
    pub analogAction: SteamInputActionEvent_t_AnalogAction_t,
    pub digitalAction: SteamInputActionEvent_t_DigitalAction_t,
}
#[test]
fn bindgen_test_layout_SteamInputActionEvent_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputActionEvent_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputActionEvent_t__bindgen_ty_1>(),
        21usize,
        concat!(
            "Size of: ",
            stringify!(SteamInputActionEvent_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputActionEvent_t__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInputActionEvent_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogAction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t__bindgen_ty_1),
            "::",
            stringify!(analogAction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digitalAction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t__bindgen_ty_1),
            "::",
            stringify!(digitalAction)
        )
    );
}
#[test]
fn bindgen_test_layout_SteamInputActionEvent_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputActionEvent_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputActionEvent_t>(),
        33usize,
        concat!("Size of: ", stringify!(SteamInputActionEvent_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputActionEvent_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamInputActionEvent_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).controllerHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t),
            "::",
            stringify!(controllerHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eEventType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputActionEvent_t),
            "::",
            stringify!(eEventType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScePadTriggerEffectParam {
    _unused: [u8; 0],
}
pub type SteamInputActionEventCallbackPointer =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamInputActionEvent_t)>;
#[repr(C)]
pub struct ISteamInput__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamInput {
    pub vtable_: *const ISteamInput__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamInput() {
    assert_eq!(
        ::std::mem::size_of::<ISteamInput>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamInput))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamInput>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamInput))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInputDeviceConnected_t {
    pub m_ulConnectedDeviceHandle: InputHandle_t,
}
pub const SteamInputDeviceConnected_t_k_iCallback: SteamInputDeviceConnected_t__bindgen_ty_1 = 2801;
pub type SteamInputDeviceConnected_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamInputDeviceConnected_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputDeviceConnected_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputDeviceConnected_t>(),
        8usize,
        concat!("Size of: ", stringify!(SteamInputDeviceConnected_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputDeviceConnected_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamInputDeviceConnected_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulConnectedDeviceHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputDeviceConnected_t),
            "::",
            stringify!(m_ulConnectedDeviceHandle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInputDeviceDisconnected_t {
    pub m_ulDisconnectedDeviceHandle: InputHandle_t,
}
pub const SteamInputDeviceDisconnected_t_k_iCallback: SteamInputDeviceDisconnected_t__bindgen_ty_1 =
    2802;
pub type SteamInputDeviceDisconnected_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamInputDeviceDisconnected_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputDeviceDisconnected_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputDeviceDisconnected_t>(),
        8usize,
        concat!("Size of: ", stringify!(SteamInputDeviceDisconnected_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputDeviceDisconnected_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamInputDeviceDisconnected_t))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_ulDisconnectedDeviceHandle) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputDeviceDisconnected_t),
            "::",
            stringify!(m_ulDisconnectedDeviceHandle)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SteamInputConfigurationLoaded_t {
    pub m_unAppID: AppId_t,
    pub m_ulDeviceHandle: InputHandle_t,
    pub m_ulMappingCreator: CSteamID,
    pub m_unMajorRevision: uint32,
    pub m_unMinorRevision: uint32,
    pub m_bUsesSteamInputAPI: bool,
    pub m_bUsesGamepadAPI: bool,
}
pub const SteamInputConfigurationLoaded_t_k_iCallback:
    SteamInputConfigurationLoaded_t__bindgen_ty_1 = 2803;
pub type SteamInputConfigurationLoaded_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamInputConfigurationLoaded_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputConfigurationLoaded_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputConfigurationLoaded_t>(),
        40usize,
        concat!("Size of: ", stringify!(SteamInputConfigurationLoaded_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputConfigurationLoaded_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamInputConfigurationLoaded_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_unAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulDeviceHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_ulDeviceHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulMappingCreator) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_ulMappingCreator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unMajorRevision) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_unMajorRevision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unMinorRevision) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_unMinorRevision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUsesSteamInputAPI) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_bUsesSteamInputAPI)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUsesGamepadAPI) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputConfigurationLoaded_t),
            "::",
            stringify!(m_bUsesGamepadAPI)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInputGamepadSlotChange_t {
    pub m_unAppID: AppId_t,
    pub m_ulDeviceHandle: InputHandle_t,
    pub m_eDeviceType: ESteamInputType,
    pub m_nOldGamepadSlot: ::std::os::raw::c_int,
    pub m_nNewGamepadSlot: ::std::os::raw::c_int,
}
pub const SteamInputGamepadSlotChange_t_k_iCallback: SteamInputGamepadSlotChange_t__bindgen_ty_1 =
    2804;
pub type SteamInputGamepadSlotChange_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamInputGamepadSlotChange_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInputGamepadSlotChange_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInputGamepadSlotChange_t>(),
        32usize,
        concat!("Size of: ", stringify!(SteamInputGamepadSlotChange_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInputGamepadSlotChange_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamInputGamepadSlotChange_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputGamepadSlotChange_t),
            "::",
            stringify!(m_unAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulDeviceHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputGamepadSlotChange_t),
            "::",
            stringify!(m_ulDeviceHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eDeviceType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputGamepadSlotChange_t),
            "::",
            stringify!(m_eDeviceType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nOldGamepadSlot) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputGamepadSlotChange_t),
            "::",
            stringify!(m_nOldGamepadSlot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nNewGamepadSlot) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInputGamepadSlotChange_t),
            "::",
            stringify!(m_nNewGamepadSlot)
        )
    );
}
pub const EControllerActionOrigin_k_EControllerActionOrigin_None: EControllerActionOrigin = 0;
pub const EControllerActionOrigin_k_EControllerActionOrigin_A: EControllerActionOrigin = 1;
pub const EControllerActionOrigin_k_EControllerActionOrigin_B: EControllerActionOrigin = 2;
pub const EControllerActionOrigin_k_EControllerActionOrigin_X: EControllerActionOrigin = 3;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Y: EControllerActionOrigin = 4;
pub const EControllerActionOrigin_k_EControllerActionOrigin_LeftBumper: EControllerActionOrigin = 5;
pub const EControllerActionOrigin_k_EControllerActionOrigin_RightBumper: EControllerActionOrigin =
    6;
pub const EControllerActionOrigin_k_EControllerActionOrigin_LeftGrip: EControllerActionOrigin = 7;
pub const EControllerActionOrigin_k_EControllerActionOrigin_RightGrip: EControllerActionOrigin = 8;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Start: EControllerActionOrigin = 9;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Back: EControllerActionOrigin = 10;
pub const EControllerActionOrigin_k_EControllerActionOrigin_LeftPad_Touch: EControllerActionOrigin =
    11;
pub const EControllerActionOrigin_k_EControllerActionOrigin_LeftPad_Swipe: EControllerActionOrigin =
    12;
pub const EControllerActionOrigin_k_EControllerActionOrigin_LeftPad_Click: EControllerActionOrigin =
    13;
pub const EControllerActionOrigin_k_EControllerActionOrigin_LeftPad_DPadNorth:
    EControllerActionOrigin = 14;
pub const EControllerActionOrigin_k_EControllerActionOrigin_LeftPad_DPadSouth:
    EControllerActionOrigin = 15;
pub const EControllerActionOrigin_k_EControllerActionOrigin_LeftPad_DPadWest:
    EControllerActionOrigin = 16;
pub const EControllerActionOrigin_k_EControllerActionOrigin_LeftPad_DPadEast:
    EControllerActionOrigin = 17;
pub const EControllerActionOrigin_k_EControllerActionOrigin_RightPad_Touch:
    EControllerActionOrigin = 18;
pub const EControllerActionOrigin_k_EControllerActionOrigin_RightPad_Swipe:
    EControllerActionOrigin = 19;
pub const EControllerActionOrigin_k_EControllerActionOrigin_RightPad_Click:
    EControllerActionOrigin = 20;
pub const EControllerActionOrigin_k_EControllerActionOrigin_RightPad_DPadNorth:
    EControllerActionOrigin = 21;
pub const EControllerActionOrigin_k_EControllerActionOrigin_RightPad_DPadSouth:
    EControllerActionOrigin = 22;
pub const EControllerActionOrigin_k_EControllerActionOrigin_RightPad_DPadWest:
    EControllerActionOrigin = 23;
pub const EControllerActionOrigin_k_EControllerActionOrigin_RightPad_DPadEast:
    EControllerActionOrigin = 24;
pub const EControllerActionOrigin_k_EControllerActionOrigin_LeftTrigger_Pull:
    EControllerActionOrigin = 25;
pub const EControllerActionOrigin_k_EControllerActionOrigin_LeftTrigger_Click:
    EControllerActionOrigin = 26;
pub const EControllerActionOrigin_k_EControllerActionOrigin_RightTrigger_Pull:
    EControllerActionOrigin = 27;
pub const EControllerActionOrigin_k_EControllerActionOrigin_RightTrigger_Click:
    EControllerActionOrigin = 28;
pub const EControllerActionOrigin_k_EControllerActionOrigin_LeftStick_Move:
    EControllerActionOrigin = 29;
pub const EControllerActionOrigin_k_EControllerActionOrigin_LeftStick_Click:
    EControllerActionOrigin = 30;
pub const EControllerActionOrigin_k_EControllerActionOrigin_LeftStick_DPadNorth:
    EControllerActionOrigin = 31;
pub const EControllerActionOrigin_k_EControllerActionOrigin_LeftStick_DPadSouth:
    EControllerActionOrigin = 32;
pub const EControllerActionOrigin_k_EControllerActionOrigin_LeftStick_DPadWest:
    EControllerActionOrigin = 33;
pub const EControllerActionOrigin_k_EControllerActionOrigin_LeftStick_DPadEast:
    EControllerActionOrigin = 34;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Gyro_Move: EControllerActionOrigin = 35;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Gyro_Pitch: EControllerActionOrigin =
    36;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Gyro_Yaw: EControllerActionOrigin = 37;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Gyro_Roll: EControllerActionOrigin = 38;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_X: EControllerActionOrigin = 39;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_Circle: EControllerActionOrigin =
    40;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_Triangle: EControllerActionOrigin =
    41;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_Square: EControllerActionOrigin =
    42;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_LeftBumper:
    EControllerActionOrigin = 43;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_RightBumper:
    EControllerActionOrigin = 44;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_Options: EControllerActionOrigin =
    45;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_Share: EControllerActionOrigin = 46;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_LeftPad_Touch:
    EControllerActionOrigin = 47;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_LeftPad_Swipe:
    EControllerActionOrigin = 48;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_LeftPad_Click:
    EControllerActionOrigin = 49;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_LeftPad_DPadNorth:
    EControllerActionOrigin = 50;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_LeftPad_DPadSouth:
    EControllerActionOrigin = 51;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_LeftPad_DPadWest:
    EControllerActionOrigin = 52;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_LeftPad_DPadEast:
    EControllerActionOrigin = 53;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_RightPad_Touch:
    EControllerActionOrigin = 54;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_RightPad_Swipe:
    EControllerActionOrigin = 55;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_RightPad_Click:
    EControllerActionOrigin = 56;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_RightPad_DPadNorth:
    EControllerActionOrigin = 57;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_RightPad_DPadSouth:
    EControllerActionOrigin = 58;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_RightPad_DPadWest:
    EControllerActionOrigin = 59;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_RightPad_DPadEast:
    EControllerActionOrigin = 60;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_CenterPad_Touch:
    EControllerActionOrigin = 61;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_CenterPad_Swipe:
    EControllerActionOrigin = 62;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_CenterPad_Click:
    EControllerActionOrigin = 63;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_CenterPad_DPadNorth:
    EControllerActionOrigin = 64;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_CenterPad_DPadSouth:
    EControllerActionOrigin = 65;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_CenterPad_DPadWest:
    EControllerActionOrigin = 66;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_CenterPad_DPadEast:
    EControllerActionOrigin = 67;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_LeftTrigger_Pull:
    EControllerActionOrigin = 68;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_LeftTrigger_Click:
    EControllerActionOrigin = 69;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_RightTrigger_Pull:
    EControllerActionOrigin = 70;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_RightTrigger_Click:
    EControllerActionOrigin = 71;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_LeftStick_Move:
    EControllerActionOrigin = 72;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_LeftStick_Click:
    EControllerActionOrigin = 73;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_LeftStick_DPadNorth:
    EControllerActionOrigin = 74;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_LeftStick_DPadSouth:
    EControllerActionOrigin = 75;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_LeftStick_DPadWest:
    EControllerActionOrigin = 76;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_LeftStick_DPadEast:
    EControllerActionOrigin = 77;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_RightStick_Move:
    EControllerActionOrigin = 78;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_RightStick_Click:
    EControllerActionOrigin = 79;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_RightStick_DPadNorth:
    EControllerActionOrigin = 80;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_RightStick_DPadSouth:
    EControllerActionOrigin = 81;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_RightStick_DPadWest:
    EControllerActionOrigin = 82;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_RightStick_DPadEast:
    EControllerActionOrigin = 83;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_DPad_North:
    EControllerActionOrigin = 84;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_DPad_South:
    EControllerActionOrigin = 85;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_DPad_West: EControllerActionOrigin =
    86;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_DPad_East: EControllerActionOrigin =
    87;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_Gyro_Move: EControllerActionOrigin =
    88;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_Gyro_Pitch:
    EControllerActionOrigin = 89;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_Gyro_Yaw: EControllerActionOrigin =
    90;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_Gyro_Roll: EControllerActionOrigin =
    91;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_A: EControllerActionOrigin = 92;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_B: EControllerActionOrigin = 93;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_X: EControllerActionOrigin = 94;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_Y: EControllerActionOrigin = 95;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_LeftBumper:
    EControllerActionOrigin = 96;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_RightBumper:
    EControllerActionOrigin = 97;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_Menu: EControllerActionOrigin =
    98;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_View: EControllerActionOrigin =
    99;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_LeftTrigger_Pull:
    EControllerActionOrigin = 100;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_LeftTrigger_Click:
    EControllerActionOrigin = 101;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_RightTrigger_Pull:
    EControllerActionOrigin = 102;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_RightTrigger_Click:
    EControllerActionOrigin = 103;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_LeftStick_Move:
    EControllerActionOrigin = 104;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_LeftStick_Click:
    EControllerActionOrigin = 105;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_LeftStick_DPadNorth:
    EControllerActionOrigin = 106;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_LeftStick_DPadSouth:
    EControllerActionOrigin = 107;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_LeftStick_DPadWest:
    EControllerActionOrigin = 108;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_LeftStick_DPadEast:
    EControllerActionOrigin = 109;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_RightStick_Move:
    EControllerActionOrigin = 110;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_RightStick_Click:
    EControllerActionOrigin = 111;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_RightStick_DPadNorth:
    EControllerActionOrigin = 112;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_RightStick_DPadSouth:
    EControllerActionOrigin = 113;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_RightStick_DPadWest:
    EControllerActionOrigin = 114;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_RightStick_DPadEast:
    EControllerActionOrigin = 115;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_DPad_North:
    EControllerActionOrigin = 116;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_DPad_South:
    EControllerActionOrigin = 117;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_DPad_West:
    EControllerActionOrigin = 118;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_DPad_East:
    EControllerActionOrigin = 119;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_A: EControllerActionOrigin =
    120;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_B: EControllerActionOrigin =
    121;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_X: EControllerActionOrigin =
    122;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_Y: EControllerActionOrigin =
    123;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_LeftBumper:
    EControllerActionOrigin = 124;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_RightBumper:
    EControllerActionOrigin = 125;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_Start: EControllerActionOrigin =
    126;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_Back: EControllerActionOrigin =
    127;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_LeftTrigger_Pull:
    EControllerActionOrigin = 128;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_LeftTrigger_Click:
    EControllerActionOrigin = 129;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_RightTrigger_Pull:
    EControllerActionOrigin = 130;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_RightTrigger_Click:
    EControllerActionOrigin = 131;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_LeftStick_Move:
    EControllerActionOrigin = 132;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_LeftStick_Click:
    EControllerActionOrigin = 133;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_LeftStick_DPadNorth:
    EControllerActionOrigin = 134;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_LeftStick_DPadSouth:
    EControllerActionOrigin = 135;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_LeftStick_DPadWest:
    EControllerActionOrigin = 136;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_LeftStick_DPadEast:
    EControllerActionOrigin = 137;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_RightStick_Move:
    EControllerActionOrigin = 138;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_RightStick_Click:
    EControllerActionOrigin = 139;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_RightStick_DPadNorth:
    EControllerActionOrigin = 140;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_RightStick_DPadSouth:
    EControllerActionOrigin = 141;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_RightStick_DPadWest:
    EControllerActionOrigin = 142;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_RightStick_DPadEast:
    EControllerActionOrigin = 143;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_DPad_North:
    EControllerActionOrigin = 144;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_DPad_South:
    EControllerActionOrigin = 145;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_DPad_West:
    EControllerActionOrigin = 146;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_DPad_East:
    EControllerActionOrigin = 147;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_A: EControllerActionOrigin =
    148;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_B: EControllerActionOrigin =
    149;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_X: EControllerActionOrigin =
    150;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_Y: EControllerActionOrigin =
    151;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftBumper:
    EControllerActionOrigin = 152;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_RightBumper:
    EControllerActionOrigin = 153;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftGrip_Lower:
    EControllerActionOrigin = 154;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftGrip_Upper:
    EControllerActionOrigin = 155;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_RightGrip_Lower:
    EControllerActionOrigin = 156;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_RightGrip_Upper:
    EControllerActionOrigin = 157;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftBumper_Pressure:
    EControllerActionOrigin = 158;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_RightBumper_Pressure:
    EControllerActionOrigin = 159;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftGrip_Pressure:
    EControllerActionOrigin = 160;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_RightGrip_Pressure:
    EControllerActionOrigin = 161;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftGrip_Upper_Pressure:
    EControllerActionOrigin = 162;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_RightGrip_Upper_Pressure:
    EControllerActionOrigin = 163;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_Start: EControllerActionOrigin =
    164;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_Back: EControllerActionOrigin =
    165;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftPad_Touch:
    EControllerActionOrigin = 166;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftPad_Swipe:
    EControllerActionOrigin = 167;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftPad_Click:
    EControllerActionOrigin = 168;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftPad_Pressure:
    EControllerActionOrigin = 169;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftPad_DPadNorth:
    EControllerActionOrigin = 170;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftPad_DPadSouth:
    EControllerActionOrigin = 171;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftPad_DPadWest:
    EControllerActionOrigin = 172;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftPad_DPadEast:
    EControllerActionOrigin = 173;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_RightPad_Touch:
    EControllerActionOrigin = 174;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_RightPad_Swipe:
    EControllerActionOrigin = 175;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_RightPad_Click:
    EControllerActionOrigin = 176;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_RightPad_Pressure:
    EControllerActionOrigin = 177;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_RightPad_DPadNorth:
    EControllerActionOrigin = 178;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_RightPad_DPadSouth:
    EControllerActionOrigin = 179;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_RightPad_DPadWest:
    EControllerActionOrigin = 180;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_RightPad_DPadEast:
    EControllerActionOrigin = 181;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftTrigger_Pull:
    EControllerActionOrigin = 182;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftTrigger_Click:
    EControllerActionOrigin = 183;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_RightTrigger_Pull:
    EControllerActionOrigin = 184;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_RightTrigger_Click:
    EControllerActionOrigin = 185;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftStick_Move:
    EControllerActionOrigin = 186;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftStick_Click:
    EControllerActionOrigin = 187;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftStick_DPadNorth:
    EControllerActionOrigin = 188;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftStick_DPadSouth:
    EControllerActionOrigin = 189;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftStick_DPadWest:
    EControllerActionOrigin = 190;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_LeftStick_DPadEast:
    EControllerActionOrigin = 191;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_Gyro_Move:
    EControllerActionOrigin = 192;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_Gyro_Pitch:
    EControllerActionOrigin = 193;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_Gyro_Yaw:
    EControllerActionOrigin = 194;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamV2_Gyro_Roll:
    EControllerActionOrigin = 195;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_A: EControllerActionOrigin = 196;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_B: EControllerActionOrigin = 197;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_X: EControllerActionOrigin = 198;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_Y: EControllerActionOrigin = 199;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_LeftBumper:
    EControllerActionOrigin = 200;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_RightBumper:
    EControllerActionOrigin = 201;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_Plus: EControllerActionOrigin =
    202;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_Minus: EControllerActionOrigin =
    203;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_Capture:
    EControllerActionOrigin = 204;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_LeftTrigger_Pull:
    EControllerActionOrigin = 205;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_LeftTrigger_Click:
    EControllerActionOrigin = 206;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_RightTrigger_Pull:
    EControllerActionOrigin = 207;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_RightTrigger_Click:
    EControllerActionOrigin = 208;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_LeftStick_Move:
    EControllerActionOrigin = 209;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_LeftStick_Click:
    EControllerActionOrigin = 210;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_LeftStick_DPadNorth:
    EControllerActionOrigin = 211;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_LeftStick_DPadSouth:
    EControllerActionOrigin = 212;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_LeftStick_DPadWest:
    EControllerActionOrigin = 213;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_LeftStick_DPadEast:
    EControllerActionOrigin = 214;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_RightStick_Move:
    EControllerActionOrigin = 215;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_RightStick_Click:
    EControllerActionOrigin = 216;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_RightStick_DPadNorth:
    EControllerActionOrigin = 217;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_RightStick_DPadSouth:
    EControllerActionOrigin = 218;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_RightStick_DPadWest:
    EControllerActionOrigin = 219;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_RightStick_DPadEast:
    EControllerActionOrigin = 220;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_DPad_North:
    EControllerActionOrigin = 221;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_DPad_South:
    EControllerActionOrigin = 222;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_DPad_West:
    EControllerActionOrigin = 223;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_DPad_East:
    EControllerActionOrigin = 224;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_ProGyro_Move:
    EControllerActionOrigin = 225;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_ProGyro_Pitch:
    EControllerActionOrigin = 226;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_ProGyro_Yaw:
    EControllerActionOrigin = 227;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_ProGyro_Roll:
    EControllerActionOrigin = 228;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_RightGyro_Move:
    EControllerActionOrigin = 229;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_RightGyro_Pitch:
    EControllerActionOrigin = 230;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_RightGyro_Yaw:
    EControllerActionOrigin = 231;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_RightGyro_Roll:
    EControllerActionOrigin = 232;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_LeftGyro_Move:
    EControllerActionOrigin = 233;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_LeftGyro_Pitch:
    EControllerActionOrigin = 234;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_LeftGyro_Yaw:
    EControllerActionOrigin = 235;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_LeftGyro_Roll:
    EControllerActionOrigin = 236;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_LeftGrip_Lower:
    EControllerActionOrigin = 237;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_LeftGrip_Upper:
    EControllerActionOrigin = 238;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_RightGrip_Lower:
    EControllerActionOrigin = 239;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_RightGrip_Upper:
    EControllerActionOrigin = 240;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS4_DPad_Move: EControllerActionOrigin =
    241;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_DPad_Move:
    EControllerActionOrigin = 242;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBox360_DPad_Move:
    EControllerActionOrigin = 243;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_DPad_Move:
    EControllerActionOrigin = 244;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_X: EControllerActionOrigin = 245;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_Circle: EControllerActionOrigin =
    246;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_Triangle: EControllerActionOrigin =
    247;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_Square: EControllerActionOrigin =
    248;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftBumper:
    EControllerActionOrigin = 249;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightBumper:
    EControllerActionOrigin = 250;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_Option: EControllerActionOrigin =
    251;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_Create: EControllerActionOrigin =
    252;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_Mute: EControllerActionOrigin = 253;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftPad_Touch:
    EControllerActionOrigin = 254;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftPad_Swipe:
    EControllerActionOrigin = 255;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftPad_Click:
    EControllerActionOrigin = 256;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftPad_DPadNorth:
    EControllerActionOrigin = 257;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftPad_DPadSouth:
    EControllerActionOrigin = 258;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftPad_DPadWest:
    EControllerActionOrigin = 259;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftPad_DPadEast:
    EControllerActionOrigin = 260;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightPad_Touch:
    EControllerActionOrigin = 261;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightPad_Swipe:
    EControllerActionOrigin = 262;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightPad_Click:
    EControllerActionOrigin = 263;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightPad_DPadNorth:
    EControllerActionOrigin = 264;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightPad_DPadSouth:
    EControllerActionOrigin = 265;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightPad_DPadWest:
    EControllerActionOrigin = 266;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightPad_DPadEast:
    EControllerActionOrigin = 267;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_CenterPad_Touch:
    EControllerActionOrigin = 268;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_CenterPad_Swipe:
    EControllerActionOrigin = 269;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_CenterPad_Click:
    EControllerActionOrigin = 270;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_CenterPad_DPadNorth:
    EControllerActionOrigin = 271;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_CenterPad_DPadSouth:
    EControllerActionOrigin = 272;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_CenterPad_DPadWest:
    EControllerActionOrigin = 273;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_CenterPad_DPadEast:
    EControllerActionOrigin = 274;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftTrigger_Pull:
    EControllerActionOrigin = 275;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftTrigger_Click:
    EControllerActionOrigin = 276;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightTrigger_Pull:
    EControllerActionOrigin = 277;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightTrigger_Click:
    EControllerActionOrigin = 278;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftStick_Move:
    EControllerActionOrigin = 279;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftStick_Click:
    EControllerActionOrigin = 280;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftStick_DPadNorth:
    EControllerActionOrigin = 281;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftStick_DPadSouth:
    EControllerActionOrigin = 282;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftStick_DPadWest:
    EControllerActionOrigin = 283;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftStick_DPadEast:
    EControllerActionOrigin = 284;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightStick_Move:
    EControllerActionOrigin = 285;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightStick_Click:
    EControllerActionOrigin = 286;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightStick_DPadNorth:
    EControllerActionOrigin = 287;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightStick_DPadSouth:
    EControllerActionOrigin = 288;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightStick_DPadWest:
    EControllerActionOrigin = 289;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightStick_DPadEast:
    EControllerActionOrigin = 290;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_DPad_Move: EControllerActionOrigin =
    291;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_DPad_North:
    EControllerActionOrigin = 292;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_DPad_South:
    EControllerActionOrigin = 293;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_DPad_West: EControllerActionOrigin =
    294;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_DPad_East: EControllerActionOrigin =
    295;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_Gyro_Move: EControllerActionOrigin =
    296;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_Gyro_Pitch:
    EControllerActionOrigin = 297;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_Gyro_Yaw: EControllerActionOrigin =
    298;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_Gyro_Roll: EControllerActionOrigin =
    299;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_LeftGrip_Lower:
    EControllerActionOrigin = 300;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_LeftGrip_Upper:
    EControllerActionOrigin = 301;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_RightGrip_Lower:
    EControllerActionOrigin = 302;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_RightGrip_Upper:
    EControllerActionOrigin = 303;
pub const EControllerActionOrigin_k_EControllerActionOrigin_XBoxOne_Share: EControllerActionOrigin =
    304;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_A: EControllerActionOrigin =
    305;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_B: EControllerActionOrigin =
    306;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_X: EControllerActionOrigin =
    307;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Y: EControllerActionOrigin =
    308;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_L1: EControllerActionOrigin =
    309;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_R1: EControllerActionOrigin =
    310;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Menu:
    EControllerActionOrigin = 311;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_View:
    EControllerActionOrigin = 312;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_LeftPad_Touch:
    EControllerActionOrigin = 313;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_LeftPad_Swipe:
    EControllerActionOrigin = 314;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_LeftPad_Click:
    EControllerActionOrigin = 315;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_LeftPad_DPadNorth:
    EControllerActionOrigin = 316;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_LeftPad_DPadSouth:
    EControllerActionOrigin = 317;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_LeftPad_DPadWest:
    EControllerActionOrigin = 318;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_LeftPad_DPadEast:
    EControllerActionOrigin = 319;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_RightPad_Touch:
    EControllerActionOrigin = 320;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_RightPad_Swipe:
    EControllerActionOrigin = 321;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_RightPad_Click:
    EControllerActionOrigin = 322;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_RightPad_DPadNorth:
    EControllerActionOrigin = 323;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_RightPad_DPadSouth:
    EControllerActionOrigin = 324;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_RightPad_DPadWest:
    EControllerActionOrigin = 325;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_RightPad_DPadEast:
    EControllerActionOrigin = 326;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_L2_SoftPull:
    EControllerActionOrigin = 327;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_L2: EControllerActionOrigin =
    328;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_R2_SoftPull:
    EControllerActionOrigin = 329;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_R2: EControllerActionOrigin =
    330;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_LeftStick_Move:
    EControllerActionOrigin = 331;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_L3: EControllerActionOrigin =
    332;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_LeftStick_DPadNorth:
    EControllerActionOrigin = 333;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_LeftStick_DPadSouth:
    EControllerActionOrigin = 334;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_LeftStick_DPadWest:
    EControllerActionOrigin = 335;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_LeftStick_DPadEast:
    EControllerActionOrigin = 336;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_LeftStick_Touch:
    EControllerActionOrigin = 337;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_RightStick_Move:
    EControllerActionOrigin = 338;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_R3: EControllerActionOrigin =
    339;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_RightStick_DPadNorth:
    EControllerActionOrigin = 340;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_RightStick_DPadSouth:
    EControllerActionOrigin = 341;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_RightStick_DPadWest:
    EControllerActionOrigin = 342;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_RightStick_DPadEast:
    EControllerActionOrigin = 343;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_RightStick_Touch:
    EControllerActionOrigin = 344;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_L4: EControllerActionOrigin =
    345;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_R4: EControllerActionOrigin =
    346;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_L5: EControllerActionOrigin =
    347;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_R5: EControllerActionOrigin =
    348;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_DPad_Move:
    EControllerActionOrigin = 349;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_DPad_North:
    EControllerActionOrigin = 350;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_DPad_South:
    EControllerActionOrigin = 351;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_DPad_West:
    EControllerActionOrigin = 352;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_DPad_East:
    EControllerActionOrigin = 353;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Gyro_Move:
    EControllerActionOrigin = 354;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Gyro_Pitch:
    EControllerActionOrigin = 355;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Gyro_Yaw:
    EControllerActionOrigin = 356;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Gyro_Roll:
    EControllerActionOrigin = 357;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved1:
    EControllerActionOrigin = 358;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved2:
    EControllerActionOrigin = 359;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved3:
    EControllerActionOrigin = 360;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved4:
    EControllerActionOrigin = 361;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved5:
    EControllerActionOrigin = 362;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved6:
    EControllerActionOrigin = 363;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved7:
    EControllerActionOrigin = 364;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved8:
    EControllerActionOrigin = 365;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved9:
    EControllerActionOrigin = 366;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved10:
    EControllerActionOrigin = 367;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved11:
    EControllerActionOrigin = 368;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved12:
    EControllerActionOrigin = 369;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved13:
    EControllerActionOrigin = 370;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved14:
    EControllerActionOrigin = 371;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved15:
    EControllerActionOrigin = 372;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved16:
    EControllerActionOrigin = 373;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved17:
    EControllerActionOrigin = 374;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved18:
    EControllerActionOrigin = 375;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved19:
    EControllerActionOrigin = 376;
pub const EControllerActionOrigin_k_EControllerActionOrigin_SteamDeck_Reserved20:
    EControllerActionOrigin = 377;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_JoyConButton_N:
    EControllerActionOrigin = 378;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_JoyConButton_E:
    EControllerActionOrigin = 379;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_JoyConButton_S:
    EControllerActionOrigin = 380;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Switch_JoyConButton_W:
    EControllerActionOrigin = 381;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftGrip: EControllerActionOrigin =
    382;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightGrip: EControllerActionOrigin =
    383;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_LeftFn: EControllerActionOrigin =
    384;
pub const EControllerActionOrigin_k_EControllerActionOrigin_PS5_RightFn: EControllerActionOrigin =
    385;
pub const EControllerActionOrigin_k_EControllerActionOrigin_Count: EControllerActionOrigin = 386;
pub const EControllerActionOrigin_k_EControllerActionOrigin_MaximumPossibleValue:
    EControllerActionOrigin = 32767;
pub type EControllerActionOrigin = ::std::os::raw::c_int;
pub const ESteamControllerLEDFlag_k_ESteamControllerLEDFlag_SetColor: ESteamControllerLEDFlag = 0;
pub const ESteamControllerLEDFlag_k_ESteamControllerLEDFlag_RestoreUserDefault:
    ESteamControllerLEDFlag = 1;
pub type ESteamControllerLEDFlag = ::std::os::raw::c_int;
pub type ControllerHandle_t = uint64;
pub type ControllerActionSetHandle_t = uint64;
pub type ControllerDigitalActionHandle_t = uint64;
pub type ControllerAnalogActionHandle_t = uint64;
#[repr(C)]
pub struct ISteamController__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamController {
    pub vtable_: *const ISteamController__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamController() {
    assert_eq!(
        ::std::mem::size_of::<ISteamController>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamController))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamController>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamController))
    );
}
pub type UGCQueryHandle_t = uint64;
pub type UGCUpdateHandle_t = uint64;
pub const k_UGCQueryHandleInvalid: UGCQueryHandle_t = 18446744073709551615;
pub const k_UGCUpdateHandleInvalid: UGCUpdateHandle_t = 18446744073709551615;
pub const EUGCMatchingUGCType_k_EUGCMatchingUGCType_Items: EUGCMatchingUGCType = 0;
pub const EUGCMatchingUGCType_k_EUGCMatchingUGCType_Items_Mtx: EUGCMatchingUGCType = 1;
pub const EUGCMatchingUGCType_k_EUGCMatchingUGCType_Items_ReadyToUse: EUGCMatchingUGCType = 2;
pub const EUGCMatchingUGCType_k_EUGCMatchingUGCType_Collections: EUGCMatchingUGCType = 3;
pub const EUGCMatchingUGCType_k_EUGCMatchingUGCType_Artwork: EUGCMatchingUGCType = 4;
pub const EUGCMatchingUGCType_k_EUGCMatchingUGCType_Videos: EUGCMatchingUGCType = 5;
pub const EUGCMatchingUGCType_k_EUGCMatchingUGCType_Screenshots: EUGCMatchingUGCType = 6;
pub const EUGCMatchingUGCType_k_EUGCMatchingUGCType_AllGuides: EUGCMatchingUGCType = 7;
pub const EUGCMatchingUGCType_k_EUGCMatchingUGCType_WebGuides: EUGCMatchingUGCType = 8;
pub const EUGCMatchingUGCType_k_EUGCMatchingUGCType_IntegratedGuides: EUGCMatchingUGCType = 9;
pub const EUGCMatchingUGCType_k_EUGCMatchingUGCType_UsableInGame: EUGCMatchingUGCType = 10;
pub const EUGCMatchingUGCType_k_EUGCMatchingUGCType_ControllerBindings: EUGCMatchingUGCType = 11;
pub const EUGCMatchingUGCType_k_EUGCMatchingUGCType_GameManagedItems: EUGCMatchingUGCType = 12;
pub const EUGCMatchingUGCType_k_EUGCMatchingUGCType_All: EUGCMatchingUGCType = -1;
pub type EUGCMatchingUGCType = ::std::os::raw::c_int;
pub const EUserUGCList_k_EUserUGCList_Published: EUserUGCList = 0;
pub const EUserUGCList_k_EUserUGCList_VotedOn: EUserUGCList = 1;
pub const EUserUGCList_k_EUserUGCList_VotedUp: EUserUGCList = 2;
pub const EUserUGCList_k_EUserUGCList_VotedDown: EUserUGCList = 3;
pub const EUserUGCList_k_EUserUGCList_WillVoteLater: EUserUGCList = 4;
pub const EUserUGCList_k_EUserUGCList_Favorited: EUserUGCList = 5;
pub const EUserUGCList_k_EUserUGCList_Subscribed: EUserUGCList = 6;
pub const EUserUGCList_k_EUserUGCList_UsedOrPlayed: EUserUGCList = 7;
pub const EUserUGCList_k_EUserUGCList_Followed: EUserUGCList = 8;
pub type EUserUGCList = ::std::os::raw::c_int;
pub const EUserUGCListSortOrder_k_EUserUGCListSortOrder_CreationOrderDesc: EUserUGCListSortOrder =
    0;
pub const EUserUGCListSortOrder_k_EUserUGCListSortOrder_CreationOrderAsc: EUserUGCListSortOrder = 1;
pub const EUserUGCListSortOrder_k_EUserUGCListSortOrder_TitleAsc: EUserUGCListSortOrder = 2;
pub const EUserUGCListSortOrder_k_EUserUGCListSortOrder_LastUpdatedDesc: EUserUGCListSortOrder = 3;
pub const EUserUGCListSortOrder_k_EUserUGCListSortOrder_SubscriptionDateDesc:
    EUserUGCListSortOrder = 4;
pub const EUserUGCListSortOrder_k_EUserUGCListSortOrder_VoteScoreDesc: EUserUGCListSortOrder = 5;
pub const EUserUGCListSortOrder_k_EUserUGCListSortOrder_ForModeration: EUserUGCListSortOrder = 6;
pub type EUserUGCListSortOrder = ::std::os::raw::c_int;
pub const EUGCQuery_k_EUGCQuery_RankedByVote: EUGCQuery = 0;
pub const EUGCQuery_k_EUGCQuery_RankedByPublicationDate: EUGCQuery = 1;
pub const EUGCQuery_k_EUGCQuery_AcceptedForGameRankedByAcceptanceDate: EUGCQuery = 2;
pub const EUGCQuery_k_EUGCQuery_RankedByTrend: EUGCQuery = 3;
pub const EUGCQuery_k_EUGCQuery_FavoritedByFriendsRankedByPublicationDate: EUGCQuery = 4;
pub const EUGCQuery_k_EUGCQuery_CreatedByFriendsRankedByPublicationDate: EUGCQuery = 5;
pub const EUGCQuery_k_EUGCQuery_RankedByNumTimesReported: EUGCQuery = 6;
pub const EUGCQuery_k_EUGCQuery_CreatedByFollowedUsersRankedByPublicationDate: EUGCQuery = 7;
pub const EUGCQuery_k_EUGCQuery_NotYetRated: EUGCQuery = 8;
pub const EUGCQuery_k_EUGCQuery_RankedByTotalVotesAsc: EUGCQuery = 9;
pub const EUGCQuery_k_EUGCQuery_RankedByVotesUp: EUGCQuery = 10;
pub const EUGCQuery_k_EUGCQuery_RankedByTextSearch: EUGCQuery = 11;
pub const EUGCQuery_k_EUGCQuery_RankedByTotalUniqueSubscriptions: EUGCQuery = 12;
pub const EUGCQuery_k_EUGCQuery_RankedByPlaytimeTrend: EUGCQuery = 13;
pub const EUGCQuery_k_EUGCQuery_RankedByTotalPlaytime: EUGCQuery = 14;
pub const EUGCQuery_k_EUGCQuery_RankedByAveragePlaytimeTrend: EUGCQuery = 15;
pub const EUGCQuery_k_EUGCQuery_RankedByLifetimeAveragePlaytime: EUGCQuery = 16;
pub const EUGCQuery_k_EUGCQuery_RankedByPlaytimeSessionsTrend: EUGCQuery = 17;
pub const EUGCQuery_k_EUGCQuery_RankedByLifetimePlaytimeSessions: EUGCQuery = 18;
pub const EUGCQuery_k_EUGCQuery_RankedByLastUpdatedDate: EUGCQuery = 19;
pub type EUGCQuery = ::std::os::raw::c_int;
pub const EItemUpdateStatus_k_EItemUpdateStatusInvalid: EItemUpdateStatus = 0;
pub const EItemUpdateStatus_k_EItemUpdateStatusPreparingConfig: EItemUpdateStatus = 1;
pub const EItemUpdateStatus_k_EItemUpdateStatusPreparingContent: EItemUpdateStatus = 2;
pub const EItemUpdateStatus_k_EItemUpdateStatusUploadingContent: EItemUpdateStatus = 3;
pub const EItemUpdateStatus_k_EItemUpdateStatusUploadingPreviewFile: EItemUpdateStatus = 4;
pub const EItemUpdateStatus_k_EItemUpdateStatusCommittingChanges: EItemUpdateStatus = 5;
pub type EItemUpdateStatus = ::std::os::raw::c_int;
pub const EItemState_k_EItemStateNone: EItemState = 0;
pub const EItemState_k_EItemStateSubscribed: EItemState = 1;
pub const EItemState_k_EItemStateLegacyItem: EItemState = 2;
pub const EItemState_k_EItemStateInstalled: EItemState = 4;
pub const EItemState_k_EItemStateNeedsUpdate: EItemState = 8;
pub const EItemState_k_EItemStateDownloading: EItemState = 16;
pub const EItemState_k_EItemStateDownloadPending: EItemState = 32;
pub const EItemState_k_EItemStateDisabledLocally: EItemState = 64;
pub type EItemState = ::std::os::raw::c_int;
pub const EItemStatistic_k_EItemStatistic_NumSubscriptions: EItemStatistic = 0;
pub const EItemStatistic_k_EItemStatistic_NumFavorites: EItemStatistic = 1;
pub const EItemStatistic_k_EItemStatistic_NumFollowers: EItemStatistic = 2;
pub const EItemStatistic_k_EItemStatistic_NumUniqueSubscriptions: EItemStatistic = 3;
pub const EItemStatistic_k_EItemStatistic_NumUniqueFavorites: EItemStatistic = 4;
pub const EItemStatistic_k_EItemStatistic_NumUniqueFollowers: EItemStatistic = 5;
pub const EItemStatistic_k_EItemStatistic_NumUniqueWebsiteViews: EItemStatistic = 6;
pub const EItemStatistic_k_EItemStatistic_ReportScore: EItemStatistic = 7;
pub const EItemStatistic_k_EItemStatistic_NumSecondsPlayed: EItemStatistic = 8;
pub const EItemStatistic_k_EItemStatistic_NumPlaytimeSessions: EItemStatistic = 9;
pub const EItemStatistic_k_EItemStatistic_NumComments: EItemStatistic = 10;
pub const EItemStatistic_k_EItemStatistic_NumSecondsPlayedDuringTimePeriod: EItemStatistic = 11;
pub const EItemStatistic_k_EItemStatistic_NumPlaytimeSessionsDuringTimePeriod: EItemStatistic = 12;
pub type EItemStatistic = ::std::os::raw::c_int;
pub const EItemPreviewType_k_EItemPreviewType_Image: EItemPreviewType = 0;
pub const EItemPreviewType_k_EItemPreviewType_YouTubeVideo: EItemPreviewType = 1;
pub const EItemPreviewType_k_EItemPreviewType_Sketchfab: EItemPreviewType = 2;
pub const EItemPreviewType_k_EItemPreviewType_EnvironmentMap_HorizontalCross: EItemPreviewType = 3;
pub const EItemPreviewType_k_EItemPreviewType_EnvironmentMap_LatLong: EItemPreviewType = 4;
pub const EItemPreviewType_k_EItemPreviewType_Clip: EItemPreviewType = 5;
pub const EItemPreviewType_k_EItemPreviewType_ReservedMax: EItemPreviewType = 255;
pub type EItemPreviewType = ::std::os::raw::c_int;
pub const EUGCContentDescriptorID_k_EUGCContentDescriptor_NudityOrSexualContent:
    EUGCContentDescriptorID = 1;
pub const EUGCContentDescriptorID_k_EUGCContentDescriptor_FrequentViolenceOrGore:
    EUGCContentDescriptorID = 2;
pub const EUGCContentDescriptorID_k_EUGCContentDescriptor_AdultOnlySexualContent:
    EUGCContentDescriptorID = 3;
pub const EUGCContentDescriptorID_k_EUGCContentDescriptor_GratuitousSexualContent:
    EUGCContentDescriptorID = 4;
pub const EUGCContentDescriptorID_k_EUGCContentDescriptor_AnyMatureContent:
    EUGCContentDescriptorID = 5;
pub type EUGCContentDescriptorID = ::std::os::raw::c_int;
pub const kNumUGCResultsPerPage: uint32 = 50;
pub const k_cchDeveloperMetadataMax: uint32 = 5000;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamUGCDetails_t {
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_eResult: EResult,
    pub m_eFileType: EWorkshopFileType,
    pub m_nCreatorAppID: AppId_t,
    pub m_nConsumerAppID: AppId_t,
    pub m_rgchTitle: [::std::os::raw::c_char; 129usize],
    pub m_rgchDescription: [::std::os::raw::c_char; 8000usize],
    pub m_ulSteamIDOwner: uint64,
    pub m_rtimeCreated: uint32,
    pub m_rtimeUpdated: uint32,
    pub m_rtimeAddedToUserList: uint32,
    pub m_eVisibility: ERemoteStoragePublishedFileVisibility,
    pub m_bBanned: bool,
    pub m_bAcceptedForUse: bool,
    pub m_bTagsTruncated: bool,
    pub m_rgchTags: [::std::os::raw::c_char; 1025usize],
    pub m_hFile: UGCHandle_t,
    pub m_hPreviewFile: UGCHandle_t,
    pub m_pchFileName: [::std::os::raw::c_char; 260usize],
    pub m_nFileSize: int32,
    pub m_nPreviewFileSize: int32,
    pub m_rgchURL: [::std::os::raw::c_char; 256usize],
    pub m_unVotesUp: uint32,
    pub m_unVotesDown: uint32,
    pub m_flScore: f32,
    pub m_unNumChildren: uint32,
}
#[test]
fn bindgen_test_layout_SteamUGCDetails_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamUGCDetails_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamUGCDetails_t>(),
        9776usize,
        concat!("Size of: ", stringify!(SteamUGCDetails_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamUGCDetails_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamUGCDetails_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eFileType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_eFileType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCreatorAppID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_nCreatorAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nConsumerAppID) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_nConsumerAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchTitle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rgchTitle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchDescription) as usize - ptr as usize },
        153usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rgchDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulSteamIDOwner) as usize - ptr as usize },
        8160usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_ulSteamIDOwner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rtimeCreated) as usize - ptr as usize },
        8168usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rtimeCreated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rtimeUpdated) as usize - ptr as usize },
        8172usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rtimeUpdated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rtimeAddedToUserList) as usize - ptr as usize },
        8176usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rtimeAddedToUserList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eVisibility) as usize - ptr as usize },
        8180usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_eVisibility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bBanned) as usize - ptr as usize },
        8184usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_bBanned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAcceptedForUse) as usize - ptr as usize },
        8185usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_bAcceptedForUse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bTagsTruncated) as usize - ptr as usize },
        8186usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_bTagsTruncated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchTags) as usize - ptr as usize },
        8187usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rgchTags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hFile) as usize - ptr as usize },
        9216usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_hFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hPreviewFile) as usize - ptr as usize },
        9224usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_hPreviewFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pchFileName) as usize - ptr as usize },
        9232usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_pchFileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nFileSize) as usize - ptr as usize },
        9492usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_nFileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPreviewFileSize) as usize - ptr as usize },
        9496usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_nPreviewFileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchURL) as usize - ptr as usize },
        9500usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_rgchURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unVotesUp) as usize - ptr as usize },
        9756usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_unVotesUp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unVotesDown) as usize - ptr as usize },
        9760usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_unVotesDown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flScore) as usize - ptr as usize },
        9764usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_flScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unNumChildren) as usize - ptr as usize },
        9768usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCDetails_t),
            "::",
            stringify!(m_unNumChildren)
        )
    );
}
#[repr(C)]
pub struct ISteamUGC__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamUGC {
    pub vtable_: *const ISteamUGC__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamUGC() {
    assert_eq!(
        ::std::mem::size_of::<ISteamUGC>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamUGC))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamUGC>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamUGC))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamUGCQueryCompleted_t {
    pub m_handle: UGCQueryHandle_t,
    pub m_eResult: EResult,
    pub m_unNumResultsReturned: uint32,
    pub m_unTotalMatchingResults: uint32,
    pub m_bCachedData: bool,
    pub m_rgchNextCursor: [::std::os::raw::c_char; 256usize],
}
pub const SteamUGCQueryCompleted_t_k_iCallback: SteamUGCQueryCompleted_t__bindgen_ty_1 = 3401;
pub type SteamUGCQueryCompleted_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamUGCQueryCompleted_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamUGCQueryCompleted_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamUGCQueryCompleted_t>(),
        280usize,
        concat!("Size of: ", stringify!(SteamUGCQueryCompleted_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamUGCQueryCompleted_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamUGCQueryCompleted_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unNumResultsReturned) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_unNumResultsReturned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unTotalMatchingResults) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_unTotalMatchingResults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bCachedData) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_bCachedData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchNextCursor) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCQueryCompleted_t),
            "::",
            stringify!(m_rgchNextCursor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamUGCRequestUGCDetailsResult_t {
    pub m_details: SteamUGCDetails_t,
    pub m_bCachedData: bool,
}
pub const SteamUGCRequestUGCDetailsResult_t_k_iCallback:
    SteamUGCRequestUGCDetailsResult_t__bindgen_ty_1 = 3402;
pub type SteamUGCRequestUGCDetailsResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamUGCRequestUGCDetailsResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamUGCRequestUGCDetailsResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamUGCRequestUGCDetailsResult_t>(),
        9784usize,
        concat!("Size of: ", stringify!(SteamUGCRequestUGCDetailsResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamUGCRequestUGCDetailsResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SteamUGCRequestUGCDetailsResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_details) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCRequestUGCDetailsResult_t),
            "::",
            stringify!(m_details)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bCachedData) as usize - ptr as usize },
        9776usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamUGCRequestUGCDetailsResult_t),
            "::",
            stringify!(m_bCachedData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateItemResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_bUserNeedsToAcceptWorkshopLegalAgreement: bool,
}
pub const CreateItemResult_t_k_iCallback: CreateItemResult_t__bindgen_ty_1 = 3403;
pub type CreateItemResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_CreateItemResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<CreateItemResult_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CreateItemResult_t>(),
        24usize,
        concat!("Size of: ", stringify!(CreateItemResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateItemResult_t>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateItemResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateItemResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateItemResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_bUserNeedsToAcceptWorkshopLegalAgreement) as usize
                - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateItemResult_t),
            "::",
            stringify!(m_bUserNeedsToAcceptWorkshopLegalAgreement)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubmitItemUpdateResult_t {
    pub m_eResult: EResult,
    pub m_bUserNeedsToAcceptWorkshopLegalAgreement: bool,
    pub m_nPublishedFileId: PublishedFileId_t,
}
pub const SubmitItemUpdateResult_t_k_iCallback: SubmitItemUpdateResult_t__bindgen_ty_1 = 3404;
pub type SubmitItemUpdateResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SubmitItemUpdateResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<SubmitItemUpdateResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SubmitItemUpdateResult_t>(),
        16usize,
        concat!("Size of: ", stringify!(SubmitItemUpdateResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SubmitItemUpdateResult_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SubmitItemUpdateResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubmitItemUpdateResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_bUserNeedsToAcceptWorkshopLegalAgreement) as usize
                - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubmitItemUpdateResult_t),
            "::",
            stringify!(m_bUserNeedsToAcceptWorkshopLegalAgreement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubmitItemUpdateResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ItemInstalled_t {
    pub m_unAppID: AppId_t,
    pub m_nPublishedFileId: PublishedFileId_t,
}
pub const ItemInstalled_t_k_iCallback: ItemInstalled_t__bindgen_ty_1 = 3405;
pub type ItemInstalled_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_ItemInstalled_t() {
    const UNINIT: ::std::mem::MaybeUninit<ItemInstalled_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ItemInstalled_t>(),
        16usize,
        concat!("Size of: ", stringify!(ItemInstalled_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ItemInstalled_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ItemInstalled_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ItemInstalled_t),
            "::",
            stringify!(m_unAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ItemInstalled_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DownloadItemResult_t {
    pub m_unAppID: AppId_t,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_eResult: EResult,
}
pub const DownloadItemResult_t_k_iCallback: DownloadItemResult_t__bindgen_ty_1 = 3406;
pub type DownloadItemResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_DownloadItemResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<DownloadItemResult_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DownloadItemResult_t>(),
        24usize,
        concat!("Size of: ", stringify!(DownloadItemResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<DownloadItemResult_t>(),
        8usize,
        concat!("Alignment of ", stringify!(DownloadItemResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DownloadItemResult_t),
            "::",
            stringify!(m_unAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DownloadItemResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DownloadItemResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UserFavoriteItemsListChanged_t {
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_eResult: EResult,
    pub m_bWasAddRequest: bool,
}
pub const UserFavoriteItemsListChanged_t_k_iCallback: UserFavoriteItemsListChanged_t__bindgen_ty_1 =
    3407;
pub type UserFavoriteItemsListChanged_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_UserFavoriteItemsListChanged_t() {
    const UNINIT: ::std::mem::MaybeUninit<UserFavoriteItemsListChanged_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UserFavoriteItemsListChanged_t>(),
        16usize,
        concat!("Size of: ", stringify!(UserFavoriteItemsListChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<UserFavoriteItemsListChanged_t>(),
        8usize,
        concat!("Alignment of ", stringify!(UserFavoriteItemsListChanged_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UserFavoriteItemsListChanged_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UserFavoriteItemsListChanged_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bWasAddRequest) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UserFavoriteItemsListChanged_t),
            "::",
            stringify!(m_bWasAddRequest)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetUserItemVoteResult_t {
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_eResult: EResult,
    pub m_bVoteUp: bool,
}
pub const SetUserItemVoteResult_t_k_iCallback: SetUserItemVoteResult_t__bindgen_ty_1 = 3408;
pub type SetUserItemVoteResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SetUserItemVoteResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<SetUserItemVoteResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SetUserItemVoteResult_t>(),
        16usize,
        concat!("Size of: ", stringify!(SetUserItemVoteResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SetUserItemVoteResult_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SetUserItemVoteResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SetUserItemVoteResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SetUserItemVoteResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bVoteUp) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SetUserItemVoteResult_t),
            "::",
            stringify!(m_bVoteUp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GetUserItemVoteResult_t {
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_eResult: EResult,
    pub m_bVotedUp: bool,
    pub m_bVotedDown: bool,
    pub m_bVoteSkipped: bool,
}
pub const GetUserItemVoteResult_t_k_iCallback: GetUserItemVoteResult_t__bindgen_ty_1 = 3409;
pub type GetUserItemVoteResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GetUserItemVoteResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<GetUserItemVoteResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GetUserItemVoteResult_t>(),
        16usize,
        concat!("Size of: ", stringify!(GetUserItemVoteResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GetUserItemVoteResult_t>(),
        8usize,
        concat!("Alignment of ", stringify!(GetUserItemVoteResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GetUserItemVoteResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GetUserItemVoteResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bVotedUp) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GetUserItemVoteResult_t),
            "::",
            stringify!(m_bVotedUp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bVotedDown) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(GetUserItemVoteResult_t),
            "::",
            stringify!(m_bVotedDown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bVoteSkipped) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(GetUserItemVoteResult_t),
            "::",
            stringify!(m_bVoteSkipped)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StartPlaytimeTrackingResult_t {
    pub m_eResult: EResult,
}
pub const StartPlaytimeTrackingResult_t_k_iCallback: StartPlaytimeTrackingResult_t__bindgen_ty_1 =
    3410;
pub type StartPlaytimeTrackingResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_StartPlaytimeTrackingResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<StartPlaytimeTrackingResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<StartPlaytimeTrackingResult_t>(),
        4usize,
        concat!("Size of: ", stringify!(StartPlaytimeTrackingResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<StartPlaytimeTrackingResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(StartPlaytimeTrackingResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StartPlaytimeTrackingResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StopPlaytimeTrackingResult_t {
    pub m_eResult: EResult,
}
pub const StopPlaytimeTrackingResult_t_k_iCallback: StopPlaytimeTrackingResult_t__bindgen_ty_1 =
    3411;
pub type StopPlaytimeTrackingResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_StopPlaytimeTrackingResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<StopPlaytimeTrackingResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<StopPlaytimeTrackingResult_t>(),
        4usize,
        concat!("Size of: ", stringify!(StopPlaytimeTrackingResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<StopPlaytimeTrackingResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(StopPlaytimeTrackingResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StopPlaytimeTrackingResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AddUGCDependencyResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nChildPublishedFileId: PublishedFileId_t,
}
pub const AddUGCDependencyResult_t_k_iCallback: AddUGCDependencyResult_t__bindgen_ty_1 = 3412;
pub type AddUGCDependencyResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_AddUGCDependencyResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<AddUGCDependencyResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AddUGCDependencyResult_t>(),
        24usize,
        concat!("Size of: ", stringify!(AddUGCDependencyResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<AddUGCDependencyResult_t>(),
        8usize,
        concat!("Alignment of ", stringify!(AddUGCDependencyResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AddUGCDependencyResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AddUGCDependencyResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nChildPublishedFileId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AddUGCDependencyResult_t),
            "::",
            stringify!(m_nChildPublishedFileId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoveUGCDependencyResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nChildPublishedFileId: PublishedFileId_t,
}
pub const RemoveUGCDependencyResult_t_k_iCallback: RemoveUGCDependencyResult_t__bindgen_ty_1 = 3413;
pub type RemoveUGCDependencyResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoveUGCDependencyResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoveUGCDependencyResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoveUGCDependencyResult_t>(),
        24usize,
        concat!("Size of: ", stringify!(RemoveUGCDependencyResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoveUGCDependencyResult_t>(),
        8usize,
        concat!("Alignment of ", stringify!(RemoveUGCDependencyResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoveUGCDependencyResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoveUGCDependencyResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nChildPublishedFileId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoveUGCDependencyResult_t),
            "::",
            stringify!(m_nChildPublishedFileId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AddAppDependencyResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nAppID: AppId_t,
}
pub const AddAppDependencyResult_t_k_iCallback: AddAppDependencyResult_t__bindgen_ty_1 = 3414;
pub type AddAppDependencyResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_AddAppDependencyResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<AddAppDependencyResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AddAppDependencyResult_t>(),
        24usize,
        concat!("Size of: ", stringify!(AddAppDependencyResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<AddAppDependencyResult_t>(),
        8usize,
        concat!("Alignment of ", stringify!(AddAppDependencyResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AddAppDependencyResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AddAppDependencyResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AddAppDependencyResult_t),
            "::",
            stringify!(m_nAppID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RemoveAppDependencyResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_nAppID: AppId_t,
}
pub const RemoveAppDependencyResult_t_k_iCallback: RemoveAppDependencyResult_t__bindgen_ty_1 = 3415;
pub type RemoveAppDependencyResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_RemoveAppDependencyResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<RemoveAppDependencyResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RemoveAppDependencyResult_t>(),
        24usize,
        concat!("Size of: ", stringify!(RemoveAppDependencyResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<RemoveAppDependencyResult_t>(),
        8usize,
        concat!("Alignment of ", stringify!(RemoveAppDependencyResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoveAppDependencyResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoveAppDependencyResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RemoveAppDependencyResult_t),
            "::",
            stringify!(m_nAppID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GetAppDependenciesResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
    pub m_rgAppIDs: [AppId_t; 32usize],
    pub m_nNumAppDependencies: uint32,
    pub m_nTotalNumAppDependencies: uint32,
}
pub const GetAppDependenciesResult_t_k_iCallback: GetAppDependenciesResult_t__bindgen_ty_1 = 3416;
pub type GetAppDependenciesResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GetAppDependenciesResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<GetAppDependenciesResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GetAppDependenciesResult_t>(),
        152usize,
        concat!("Size of: ", stringify!(GetAppDependenciesResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GetAppDependenciesResult_t>(),
        8usize,
        concat!("Alignment of ", stringify!(GetAppDependenciesResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GetAppDependenciesResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GetAppDependenciesResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgAppIDs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GetAppDependenciesResult_t),
            "::",
            stringify!(m_rgAppIDs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nNumAppDependencies) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(GetAppDependenciesResult_t),
            "::",
            stringify!(m_nNumAppDependencies)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTotalNumAppDependencies) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(GetAppDependenciesResult_t),
            "::",
            stringify!(m_nTotalNumAppDependencies)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeleteItemResult_t {
    pub m_eResult: EResult,
    pub m_nPublishedFileId: PublishedFileId_t,
}
pub const DeleteItemResult_t_k_iCallback: DeleteItemResult_t__bindgen_ty_1 = 3417;
pub type DeleteItemResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_DeleteItemResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<DeleteItemResult_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DeleteItemResult_t>(),
        16usize,
        concat!("Size of: ", stringify!(DeleteItemResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<DeleteItemResult_t>(),
        8usize,
        concat!("Alignment of ", stringify!(DeleteItemResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DeleteItemResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPublishedFileId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DeleteItemResult_t),
            "::",
            stringify!(m_nPublishedFileId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UserSubscribedItemsListChanged_t {
    pub m_nAppID: AppId_t,
}
pub const UserSubscribedItemsListChanged_t_k_iCallback:
    UserSubscribedItemsListChanged_t__bindgen_ty_1 = 3418;
pub type UserSubscribedItemsListChanged_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_UserSubscribedItemsListChanged_t() {
    const UNINIT: ::std::mem::MaybeUninit<UserSubscribedItemsListChanged_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UserSubscribedItemsListChanged_t>(),
        4usize,
        concat!("Size of: ", stringify!(UserSubscribedItemsListChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<UserSubscribedItemsListChanged_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(UserSubscribedItemsListChanged_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UserSubscribedItemsListChanged_t),
            "::",
            stringify!(m_nAppID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WorkshopEULAStatus_t {
    pub m_eResult: EResult,
    pub m_nAppID: AppId_t,
    pub m_unVersion: uint32,
    pub m_rtAction: RTime32,
    pub m_bAccepted: bool,
    pub m_bNeedsAction: bool,
}
pub const WorkshopEULAStatus_t_k_iCallback: WorkshopEULAStatus_t__bindgen_ty_1 = 3420;
pub type WorkshopEULAStatus_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_WorkshopEULAStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<WorkshopEULAStatus_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<WorkshopEULAStatus_t>(),
        20usize,
        concat!("Size of: ", stringify!(WorkshopEULAStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<WorkshopEULAStatus_t>(),
        4usize,
        concat!("Alignment of ", stringify!(WorkshopEULAStatus_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WorkshopEULAStatus_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAppID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WorkshopEULAStatus_t),
            "::",
            stringify!(m_nAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unVersion) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WorkshopEULAStatus_t),
            "::",
            stringify!(m_unVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rtAction) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(WorkshopEULAStatus_t),
            "::",
            stringify!(m_rtAction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAccepted) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WorkshopEULAStatus_t),
            "::",
            stringify!(m_bAccepted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bNeedsAction) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(WorkshopEULAStatus_t),
            "::",
            stringify!(m_bNeedsAction)
        )
    );
}
pub type HHTMLBrowser = uint32;
pub const INVALID_HTMLBROWSER: uint32 = 0;
#[repr(C)]
pub struct ISteamHTMLSurface__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct ISteamHTMLSurface {
    pub vtable_: *const ISteamHTMLSurface__bindgen_vtable,
}
pub const ISteamHTMLSurface_EHTMLMouseButton_eHTMLMouseButton_Left:
    ISteamHTMLSurface_EHTMLMouseButton = 0;
pub const ISteamHTMLSurface_EHTMLMouseButton_eHTMLMouseButton_Right:
    ISteamHTMLSurface_EHTMLMouseButton = 1;
pub const ISteamHTMLSurface_EHTMLMouseButton_eHTMLMouseButton_Middle:
    ISteamHTMLSurface_EHTMLMouseButton = 2;
pub type ISteamHTMLSurface_EHTMLMouseButton = ::std::os::raw::c_int;
pub const ISteamHTMLSurface_EMouseCursor_dc_user: ISteamHTMLSurface_EMouseCursor = 0;
pub const ISteamHTMLSurface_EMouseCursor_dc_none: ISteamHTMLSurface_EMouseCursor = 1;
pub const ISteamHTMLSurface_EMouseCursor_dc_arrow: ISteamHTMLSurface_EMouseCursor = 2;
pub const ISteamHTMLSurface_EMouseCursor_dc_ibeam: ISteamHTMLSurface_EMouseCursor = 3;
pub const ISteamHTMLSurface_EMouseCursor_dc_hourglass: ISteamHTMLSurface_EMouseCursor = 4;
pub const ISteamHTMLSurface_EMouseCursor_dc_waitarrow: ISteamHTMLSurface_EMouseCursor = 5;
pub const ISteamHTMLSurface_EMouseCursor_dc_crosshair: ISteamHTMLSurface_EMouseCursor = 6;
pub const ISteamHTMLSurface_EMouseCursor_dc_up: ISteamHTMLSurface_EMouseCursor = 7;
pub const ISteamHTMLSurface_EMouseCursor_dc_sizenw: ISteamHTMLSurface_EMouseCursor = 8;
pub const ISteamHTMLSurface_EMouseCursor_dc_sizese: ISteamHTMLSurface_EMouseCursor = 9;
pub const ISteamHTMLSurface_EMouseCursor_dc_sizene: ISteamHTMLSurface_EMouseCursor = 10;
pub const ISteamHTMLSurface_EMouseCursor_dc_sizesw: ISteamHTMLSurface_EMouseCursor = 11;
pub const ISteamHTMLSurface_EMouseCursor_dc_sizew: ISteamHTMLSurface_EMouseCursor = 12;
pub const ISteamHTMLSurface_EMouseCursor_dc_sizee: ISteamHTMLSurface_EMouseCursor = 13;
pub const ISteamHTMLSurface_EMouseCursor_dc_sizen: ISteamHTMLSurface_EMouseCursor = 14;
pub const ISteamHTMLSurface_EMouseCursor_dc_sizes: ISteamHTMLSurface_EMouseCursor = 15;
pub const ISteamHTMLSurface_EMouseCursor_dc_sizewe: ISteamHTMLSurface_EMouseCursor = 16;
pub const ISteamHTMLSurface_EMouseCursor_dc_sizens: ISteamHTMLSurface_EMouseCursor = 17;
pub const ISteamHTMLSurface_EMouseCursor_dc_sizeall: ISteamHTMLSurface_EMouseCursor = 18;
pub const ISteamHTMLSurface_EMouseCursor_dc_no: ISteamHTMLSurface_EMouseCursor = 19;
pub const ISteamHTMLSurface_EMouseCursor_dc_hand: ISteamHTMLSurface_EMouseCursor = 20;
pub const ISteamHTMLSurface_EMouseCursor_dc_blank: ISteamHTMLSurface_EMouseCursor = 21;
pub const ISteamHTMLSurface_EMouseCursor_dc_middle_pan: ISteamHTMLSurface_EMouseCursor = 22;
pub const ISteamHTMLSurface_EMouseCursor_dc_north_pan: ISteamHTMLSurface_EMouseCursor = 23;
pub const ISteamHTMLSurface_EMouseCursor_dc_north_east_pan: ISteamHTMLSurface_EMouseCursor = 24;
pub const ISteamHTMLSurface_EMouseCursor_dc_east_pan: ISteamHTMLSurface_EMouseCursor = 25;
pub const ISteamHTMLSurface_EMouseCursor_dc_south_east_pan: ISteamHTMLSurface_EMouseCursor = 26;
pub const ISteamHTMLSurface_EMouseCursor_dc_south_pan: ISteamHTMLSurface_EMouseCursor = 27;
pub const ISteamHTMLSurface_EMouseCursor_dc_south_west_pan: ISteamHTMLSurface_EMouseCursor = 28;
pub const ISteamHTMLSurface_EMouseCursor_dc_west_pan: ISteamHTMLSurface_EMouseCursor = 29;
pub const ISteamHTMLSurface_EMouseCursor_dc_north_west_pan: ISteamHTMLSurface_EMouseCursor = 30;
pub const ISteamHTMLSurface_EMouseCursor_dc_alias: ISteamHTMLSurface_EMouseCursor = 31;
pub const ISteamHTMLSurface_EMouseCursor_dc_cell: ISteamHTMLSurface_EMouseCursor = 32;
pub const ISteamHTMLSurface_EMouseCursor_dc_colresize: ISteamHTMLSurface_EMouseCursor = 33;
pub const ISteamHTMLSurface_EMouseCursor_dc_copycur: ISteamHTMLSurface_EMouseCursor = 34;
pub const ISteamHTMLSurface_EMouseCursor_dc_verticaltext: ISteamHTMLSurface_EMouseCursor = 35;
pub const ISteamHTMLSurface_EMouseCursor_dc_rowresize: ISteamHTMLSurface_EMouseCursor = 36;
pub const ISteamHTMLSurface_EMouseCursor_dc_zoomin: ISteamHTMLSurface_EMouseCursor = 37;
pub const ISteamHTMLSurface_EMouseCursor_dc_zoomout: ISteamHTMLSurface_EMouseCursor = 38;
pub const ISteamHTMLSurface_EMouseCursor_dc_help: ISteamHTMLSurface_EMouseCursor = 39;
pub const ISteamHTMLSurface_EMouseCursor_dc_custom: ISteamHTMLSurface_EMouseCursor = 40;
pub const ISteamHTMLSurface_EMouseCursor_dc_last: ISteamHTMLSurface_EMouseCursor = 41;
pub type ISteamHTMLSurface_EMouseCursor = ::std::os::raw::c_int;
pub const ISteamHTMLSurface_EHTMLKeyModifiers_k_eHTMLKeyModifier_None:
    ISteamHTMLSurface_EHTMLKeyModifiers = 0;
pub const ISteamHTMLSurface_EHTMLKeyModifiers_k_eHTMLKeyModifier_AltDown:
    ISteamHTMLSurface_EHTMLKeyModifiers = 1;
pub const ISteamHTMLSurface_EHTMLKeyModifiers_k_eHTMLKeyModifier_CtrlDown:
    ISteamHTMLSurface_EHTMLKeyModifiers = 2;
pub const ISteamHTMLSurface_EHTMLKeyModifiers_k_eHTMLKeyModifier_ShiftDown:
    ISteamHTMLSurface_EHTMLKeyModifiers = 4;
pub type ISteamHTMLSurface_EHTMLKeyModifiers = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_ISteamHTMLSurface() {
    assert_eq!(
        ::std::mem::size_of::<ISteamHTMLSurface>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamHTMLSurface))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamHTMLSurface>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamHTMLSurface))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_BrowserReady_t {
    pub unBrowserHandle: HHTMLBrowser,
}
pub const HTML_BrowserReady_t_k_iCallback: HTML_BrowserReady_t__bindgen_ty_1 = 4501;
pub type HTML_BrowserReady_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_BrowserReady_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_BrowserReady_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_BrowserReady_t>(),
        4usize,
        concat!("Size of: ", stringify!(HTML_BrowserReady_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_BrowserReady_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_BrowserReady_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_BrowserReady_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_NeedsPaint_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pBGRA: *const ::std::os::raw::c_char,
    pub unWide: uint32,
    pub unTall: uint32,
    pub unUpdateX: uint32,
    pub unUpdateY: uint32,
    pub unUpdateWide: uint32,
    pub unUpdateTall: uint32,
    pub unScrollX: uint32,
    pub unScrollY: uint32,
    pub flPageScale: f32,
    pub unPageSerial: uint32,
}
pub const HTML_NeedsPaint_t_k_iCallback: HTML_NeedsPaint_t__bindgen_ty_1 = 4502;
pub type HTML_NeedsPaint_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_NeedsPaint_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_NeedsPaint_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_NeedsPaint_t>(),
        56usize,
        concat!("Size of: ", stringify!(HTML_NeedsPaint_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_NeedsPaint_t>(),
        8usize,
        concat!("Alignment of ", stringify!(HTML_NeedsPaint_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pBGRA) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(pBGRA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unWide) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unWide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unTall) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unTall)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unUpdateX) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unUpdateX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unUpdateY) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unUpdateY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unUpdateWide) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unUpdateWide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unUpdateTall) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unUpdateTall)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unScrollX) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unScrollX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unScrollY) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unScrollY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flPageScale) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(flPageScale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unPageSerial) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NeedsPaint_t),
            "::",
            stringify!(unPageSerial)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_StartRequest_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchURL: *const ::std::os::raw::c_char,
    pub pchTarget: *const ::std::os::raw::c_char,
    pub pchPostData: *const ::std::os::raw::c_char,
    pub bIsRedirect: bool,
}
pub const HTML_StartRequest_t_k_iCallback: HTML_StartRequest_t__bindgen_ty_1 = 4503;
pub type HTML_StartRequest_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_StartRequest_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_StartRequest_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_StartRequest_t>(),
        40usize,
        concat!("Size of: ", stringify!(HTML_StartRequest_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_StartRequest_t>(),
        8usize,
        concat!("Alignment of ", stringify!(HTML_StartRequest_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_StartRequest_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchURL) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_StartRequest_t),
            "::",
            stringify!(pchURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchTarget) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_StartRequest_t),
            "::",
            stringify!(pchTarget)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchPostData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_StartRequest_t),
            "::",
            stringify!(pchPostData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsRedirect) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_StartRequest_t),
            "::",
            stringify!(bIsRedirect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_CloseBrowser_t {
    pub unBrowserHandle: HHTMLBrowser,
}
pub const HTML_CloseBrowser_t_k_iCallback: HTML_CloseBrowser_t__bindgen_ty_1 = 4504;
pub type HTML_CloseBrowser_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_CloseBrowser_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_CloseBrowser_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_CloseBrowser_t>(),
        4usize,
        concat!("Size of: ", stringify!(HTML_CloseBrowser_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_CloseBrowser_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_CloseBrowser_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_CloseBrowser_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_URLChanged_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchURL: *const ::std::os::raw::c_char,
    pub pchPostData: *const ::std::os::raw::c_char,
    pub bIsRedirect: bool,
    pub pchPageTitle: *const ::std::os::raw::c_char,
    pub bNewNavigation: bool,
}
pub const HTML_URLChanged_t_k_iCallback: HTML_URLChanged_t__bindgen_ty_1 = 4505;
pub type HTML_URLChanged_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_URLChanged_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_URLChanged_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_URLChanged_t>(),
        48usize,
        concat!("Size of: ", stringify!(HTML_URLChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_URLChanged_t>(),
        8usize,
        concat!("Alignment of ", stringify!(HTML_URLChanged_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_URLChanged_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchURL) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_URLChanged_t),
            "::",
            stringify!(pchURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchPostData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_URLChanged_t),
            "::",
            stringify!(pchPostData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsRedirect) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_URLChanged_t),
            "::",
            stringify!(bIsRedirect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchPageTitle) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_URLChanged_t),
            "::",
            stringify!(pchPageTitle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bNewNavigation) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_URLChanged_t),
            "::",
            stringify!(bNewNavigation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_FinishedRequest_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchURL: *const ::std::os::raw::c_char,
    pub pchPageTitle: *const ::std::os::raw::c_char,
}
pub const HTML_FinishedRequest_t_k_iCallback: HTML_FinishedRequest_t__bindgen_ty_1 = 4506;
pub type HTML_FinishedRequest_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_FinishedRequest_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_FinishedRequest_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_FinishedRequest_t>(),
        24usize,
        concat!("Size of: ", stringify!(HTML_FinishedRequest_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_FinishedRequest_t>(),
        8usize,
        concat!("Alignment of ", stringify!(HTML_FinishedRequest_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_FinishedRequest_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchURL) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_FinishedRequest_t),
            "::",
            stringify!(pchURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchPageTitle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_FinishedRequest_t),
            "::",
            stringify!(pchPageTitle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_OpenLinkInNewTab_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchURL: *const ::std::os::raw::c_char,
}
pub const HTML_OpenLinkInNewTab_t_k_iCallback: HTML_OpenLinkInNewTab_t__bindgen_ty_1 = 4507;
pub type HTML_OpenLinkInNewTab_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_OpenLinkInNewTab_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_OpenLinkInNewTab_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_OpenLinkInNewTab_t>(),
        16usize,
        concat!("Size of: ", stringify!(HTML_OpenLinkInNewTab_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_OpenLinkInNewTab_t>(),
        8usize,
        concat!("Alignment of ", stringify!(HTML_OpenLinkInNewTab_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_OpenLinkInNewTab_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchURL) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_OpenLinkInNewTab_t),
            "::",
            stringify!(pchURL)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_ChangedTitle_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchTitle: *const ::std::os::raw::c_char,
}
pub const HTML_ChangedTitle_t_k_iCallback: HTML_ChangedTitle_t__bindgen_ty_1 = 4508;
pub type HTML_ChangedTitle_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_ChangedTitle_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_ChangedTitle_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_ChangedTitle_t>(),
        16usize,
        concat!("Size of: ", stringify!(HTML_ChangedTitle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_ChangedTitle_t>(),
        8usize,
        concat!("Alignment of ", stringify!(HTML_ChangedTitle_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_ChangedTitle_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchTitle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_ChangedTitle_t),
            "::",
            stringify!(pchTitle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_SearchResults_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub unResults: uint32,
    pub unCurrentMatch: uint32,
}
pub const HTML_SearchResults_t_k_iCallback: HTML_SearchResults_t__bindgen_ty_1 = 4509;
pub type HTML_SearchResults_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_SearchResults_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_SearchResults_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_SearchResults_t>(),
        12usize,
        concat!("Size of: ", stringify!(HTML_SearchResults_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_SearchResults_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_SearchResults_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_SearchResults_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unResults) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_SearchResults_t),
            "::",
            stringify!(unResults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unCurrentMatch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_SearchResults_t),
            "::",
            stringify!(unCurrentMatch)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_CanGoBackAndForward_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub bCanGoBack: bool,
    pub bCanGoForward: bool,
}
pub const HTML_CanGoBackAndForward_t_k_iCallback: HTML_CanGoBackAndForward_t__bindgen_ty_1 = 4510;
pub type HTML_CanGoBackAndForward_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_CanGoBackAndForward_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_CanGoBackAndForward_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_CanGoBackAndForward_t>(),
        8usize,
        concat!("Size of: ", stringify!(HTML_CanGoBackAndForward_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_CanGoBackAndForward_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_CanGoBackAndForward_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_CanGoBackAndForward_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bCanGoBack) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_CanGoBackAndForward_t),
            "::",
            stringify!(bCanGoBack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bCanGoForward) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_CanGoBackAndForward_t),
            "::",
            stringify!(bCanGoForward)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_HorizontalScroll_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub unScrollMax: uint32,
    pub unScrollCurrent: uint32,
    pub flPageScale: f32,
    pub bVisible: bool,
    pub unPageSize: uint32,
}
pub const HTML_HorizontalScroll_t_k_iCallback: HTML_HorizontalScroll_t__bindgen_ty_1 = 4511;
pub type HTML_HorizontalScroll_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_HorizontalScroll_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_HorizontalScroll_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_HorizontalScroll_t>(),
        24usize,
        concat!("Size of: ", stringify!(HTML_HorizontalScroll_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_HorizontalScroll_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_HorizontalScroll_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_HorizontalScroll_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unScrollMax) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_HorizontalScroll_t),
            "::",
            stringify!(unScrollMax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unScrollCurrent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_HorizontalScroll_t),
            "::",
            stringify!(unScrollCurrent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flPageScale) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_HorizontalScroll_t),
            "::",
            stringify!(flPageScale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bVisible) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_HorizontalScroll_t),
            "::",
            stringify!(bVisible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unPageSize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_HorizontalScroll_t),
            "::",
            stringify!(unPageSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_VerticalScroll_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub unScrollMax: uint32,
    pub unScrollCurrent: uint32,
    pub flPageScale: f32,
    pub bVisible: bool,
    pub unPageSize: uint32,
}
pub const HTML_VerticalScroll_t_k_iCallback: HTML_VerticalScroll_t__bindgen_ty_1 = 4512;
pub type HTML_VerticalScroll_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_VerticalScroll_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_VerticalScroll_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_VerticalScroll_t>(),
        24usize,
        concat!("Size of: ", stringify!(HTML_VerticalScroll_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_VerticalScroll_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_VerticalScroll_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_VerticalScroll_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unScrollMax) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_VerticalScroll_t),
            "::",
            stringify!(unScrollMax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unScrollCurrent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_VerticalScroll_t),
            "::",
            stringify!(unScrollCurrent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flPageScale) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_VerticalScroll_t),
            "::",
            stringify!(flPageScale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bVisible) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_VerticalScroll_t),
            "::",
            stringify!(bVisible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unPageSize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_VerticalScroll_t),
            "::",
            stringify!(unPageSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_LinkAtPosition_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub x: uint32,
    pub y: uint32,
    pub pchURL: *const ::std::os::raw::c_char,
    pub bInput: bool,
    pub bLiveLink: bool,
}
pub const HTML_LinkAtPosition_t_k_iCallback: HTML_LinkAtPosition_t__bindgen_ty_1 = 4513;
pub type HTML_LinkAtPosition_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_LinkAtPosition_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_LinkAtPosition_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_LinkAtPosition_t>(),
        32usize,
        concat!("Size of: ", stringify!(HTML_LinkAtPosition_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_LinkAtPosition_t>(),
        8usize,
        concat!("Alignment of ", stringify!(HTML_LinkAtPosition_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_LinkAtPosition_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_LinkAtPosition_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_LinkAtPosition_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchURL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_LinkAtPosition_t),
            "::",
            stringify!(pchURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bInput) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_LinkAtPosition_t),
            "::",
            stringify!(bInput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bLiveLink) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_LinkAtPosition_t),
            "::",
            stringify!(bLiveLink)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_JSAlert_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchMessage: *const ::std::os::raw::c_char,
}
pub const HTML_JSAlert_t_k_iCallback: HTML_JSAlert_t__bindgen_ty_1 = 4514;
pub type HTML_JSAlert_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_JSAlert_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_JSAlert_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_JSAlert_t>(),
        16usize,
        concat!("Size of: ", stringify!(HTML_JSAlert_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_JSAlert_t>(),
        8usize,
        concat!("Alignment of ", stringify!(HTML_JSAlert_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_JSAlert_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchMessage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_JSAlert_t),
            "::",
            stringify!(pchMessage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_JSConfirm_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchMessage: *const ::std::os::raw::c_char,
}
pub const HTML_JSConfirm_t_k_iCallback: HTML_JSConfirm_t__bindgen_ty_1 = 4515;
pub type HTML_JSConfirm_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_JSConfirm_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_JSConfirm_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_JSConfirm_t>(),
        16usize,
        concat!("Size of: ", stringify!(HTML_JSConfirm_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_JSConfirm_t>(),
        8usize,
        concat!("Alignment of ", stringify!(HTML_JSConfirm_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_JSConfirm_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchMessage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_JSConfirm_t),
            "::",
            stringify!(pchMessage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_FileOpenDialog_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchTitle: *const ::std::os::raw::c_char,
    pub pchInitialFile: *const ::std::os::raw::c_char,
}
pub const HTML_FileOpenDialog_t_k_iCallback: HTML_FileOpenDialog_t__bindgen_ty_1 = 4516;
pub type HTML_FileOpenDialog_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_FileOpenDialog_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_FileOpenDialog_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_FileOpenDialog_t>(),
        24usize,
        concat!("Size of: ", stringify!(HTML_FileOpenDialog_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_FileOpenDialog_t>(),
        8usize,
        concat!("Alignment of ", stringify!(HTML_FileOpenDialog_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_FileOpenDialog_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchTitle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_FileOpenDialog_t),
            "::",
            stringify!(pchTitle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchInitialFile) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_FileOpenDialog_t),
            "::",
            stringify!(pchInitialFile)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_NewWindow_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchURL: *const ::std::os::raw::c_char,
    pub unX: uint32,
    pub unY: uint32,
    pub unWide: uint32,
    pub unTall: uint32,
    pub unNewWindow_BrowserHandle_IGNORE: HHTMLBrowser,
}
pub const HTML_NewWindow_t_k_iCallback: HTML_NewWindow_t__bindgen_ty_1 = 4521;
pub type HTML_NewWindow_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_NewWindow_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_NewWindow_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_NewWindow_t>(),
        40usize,
        concat!("Size of: ", stringify!(HTML_NewWindow_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_NewWindow_t>(),
        8usize,
        concat!("Alignment of ", stringify!(HTML_NewWindow_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NewWindow_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchURL) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NewWindow_t),
            "::",
            stringify!(pchURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unX) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NewWindow_t),
            "::",
            stringify!(unX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unY) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NewWindow_t),
            "::",
            stringify!(unY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unWide) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NewWindow_t),
            "::",
            stringify!(unWide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unTall) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NewWindow_t),
            "::",
            stringify!(unTall)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unNewWindow_BrowserHandle_IGNORE) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_NewWindow_t),
            "::",
            stringify!(unNewWindow_BrowserHandle_IGNORE)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_SetCursor_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub eMouseCursor: uint32,
}
pub const HTML_SetCursor_t_k_iCallback: HTML_SetCursor_t__bindgen_ty_1 = 4522;
pub type HTML_SetCursor_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_SetCursor_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_SetCursor_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_SetCursor_t>(),
        8usize,
        concat!("Size of: ", stringify!(HTML_SetCursor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_SetCursor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_SetCursor_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_SetCursor_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eMouseCursor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_SetCursor_t),
            "::",
            stringify!(eMouseCursor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_StatusText_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchMsg: *const ::std::os::raw::c_char,
}
pub const HTML_StatusText_t_k_iCallback: HTML_StatusText_t__bindgen_ty_1 = 4523;
pub type HTML_StatusText_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_StatusText_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_StatusText_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_StatusText_t>(),
        16usize,
        concat!("Size of: ", stringify!(HTML_StatusText_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_StatusText_t>(),
        8usize,
        concat!("Alignment of ", stringify!(HTML_StatusText_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_StatusText_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchMsg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_StatusText_t),
            "::",
            stringify!(pchMsg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_ShowToolTip_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchMsg: *const ::std::os::raw::c_char,
}
pub const HTML_ShowToolTip_t_k_iCallback: HTML_ShowToolTip_t__bindgen_ty_1 = 4524;
pub type HTML_ShowToolTip_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_ShowToolTip_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_ShowToolTip_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_ShowToolTip_t>(),
        16usize,
        concat!("Size of: ", stringify!(HTML_ShowToolTip_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_ShowToolTip_t>(),
        8usize,
        concat!("Alignment of ", stringify!(HTML_ShowToolTip_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_ShowToolTip_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchMsg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_ShowToolTip_t),
            "::",
            stringify!(pchMsg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_UpdateToolTip_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub pchMsg: *const ::std::os::raw::c_char,
}
pub const HTML_UpdateToolTip_t_k_iCallback: HTML_UpdateToolTip_t__bindgen_ty_1 = 4525;
pub type HTML_UpdateToolTip_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_UpdateToolTip_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_UpdateToolTip_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_UpdateToolTip_t>(),
        16usize,
        concat!("Size of: ", stringify!(HTML_UpdateToolTip_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_UpdateToolTip_t>(),
        8usize,
        concat!("Alignment of ", stringify!(HTML_UpdateToolTip_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_UpdateToolTip_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pchMsg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_UpdateToolTip_t),
            "::",
            stringify!(pchMsg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_HideToolTip_t {
    pub unBrowserHandle: HHTMLBrowser,
}
pub const HTML_HideToolTip_t_k_iCallback: HTML_HideToolTip_t__bindgen_ty_1 = 4526;
pub type HTML_HideToolTip_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_HideToolTip_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_HideToolTip_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_HideToolTip_t>(),
        4usize,
        concat!("Size of: ", stringify!(HTML_HideToolTip_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_HideToolTip_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_HideToolTip_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_HideToolTip_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTML_BrowserRestarted_t {
    pub unBrowserHandle: HHTMLBrowser,
    pub unOldBrowserHandle: HHTMLBrowser,
}
pub const HTML_BrowserRestarted_t_k_iCallback: HTML_BrowserRestarted_t__bindgen_ty_1 = 4527;
pub type HTML_BrowserRestarted_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_HTML_BrowserRestarted_t() {
    const UNINIT: ::std::mem::MaybeUninit<HTML_BrowserRestarted_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTML_BrowserRestarted_t>(),
        8usize,
        concat!("Size of: ", stringify!(HTML_BrowserRestarted_t))
    );
    assert_eq!(
        ::std::mem::align_of::<HTML_BrowserRestarted_t>(),
        4usize,
        concat!("Alignment of ", stringify!(HTML_BrowserRestarted_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unBrowserHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_BrowserRestarted_t),
            "::",
            stringify!(unBrowserHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unOldBrowserHandle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HTML_BrowserRestarted_t),
            "::",
            stringify!(unOldBrowserHandle)
        )
    );
}
pub type SteamItemInstanceID_t = uint64;
extern "C" {
    pub static k_SteamItemInstanceIDInvalid: SteamItemInstanceID_t;
}
pub type SteamItemDef_t = int32;
pub const ESteamItemFlags_k_ESteamItemNoTrade: ESteamItemFlags = 1;
pub const ESteamItemFlags_k_ESteamItemRemoved: ESteamItemFlags = 256;
pub const ESteamItemFlags_k_ESteamItemConsumed: ESteamItemFlags = 512;
pub type ESteamItemFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamItemDetails_t {
    pub m_itemId: SteamItemInstanceID_t,
    pub m_iDefinition: SteamItemDef_t,
    pub m_unQuantity: uint16,
    pub m_unFlags: uint16,
}
#[test]
fn bindgen_test_layout_SteamItemDetails_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamItemDetails_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamItemDetails_t>(),
        16usize,
        concat!("Size of: ", stringify!(SteamItemDetails_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamItemDetails_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamItemDetails_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_itemId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamItemDetails_t),
            "::",
            stringify!(m_itemId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iDefinition) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamItemDetails_t),
            "::",
            stringify!(m_iDefinition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unQuantity) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamItemDetails_t),
            "::",
            stringify!(m_unQuantity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unFlags) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamItemDetails_t),
            "::",
            stringify!(m_unFlags)
        )
    );
}
pub type SteamInventoryResult_t = int32;
pub const k_SteamInventoryResultInvalid: SteamInventoryResult_t = -1;
pub type SteamInventoryUpdateHandle_t = uint64;
pub const k_SteamInventoryUpdateHandleInvalid: SteamInventoryUpdateHandle_t = 18446744073709551615;
#[repr(C)]
pub struct ISteamInventory__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamInventory {
    pub vtable_: *const ISteamInventory__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamInventory() {
    assert_eq!(
        ::std::mem::size_of::<ISteamInventory>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamInventory))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamInventory>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamInventory))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInventoryResultReady_t {
    pub m_handle: SteamInventoryResult_t,
    pub m_result: EResult,
}
pub const SteamInventoryResultReady_t_k_iCallback: SteamInventoryResultReady_t__bindgen_ty_1 = 4700;
pub type SteamInventoryResultReady_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamInventoryResultReady_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInventoryResultReady_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryResultReady_t>(),
        8usize,
        concat!("Size of: ", stringify!(SteamInventoryResultReady_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryResultReady_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamInventoryResultReady_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryResultReady_t),
            "::",
            stringify!(m_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_result) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryResultReady_t),
            "::",
            stringify!(m_result)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInventoryFullUpdate_t {
    pub m_handle: SteamInventoryResult_t,
}
pub const SteamInventoryFullUpdate_t_k_iCallback: SteamInventoryFullUpdate_t__bindgen_ty_1 = 4701;
pub type SteamInventoryFullUpdate_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamInventoryFullUpdate_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInventoryFullUpdate_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryFullUpdate_t>(),
        4usize,
        concat!("Size of: ", stringify!(SteamInventoryFullUpdate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryFullUpdate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamInventoryFullUpdate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryFullUpdate_t),
            "::",
            stringify!(m_handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInventoryDefinitionUpdate_t {
    pub _address: u8,
}
pub const SteamInventoryDefinitionUpdate_t_k_iCallback:
    SteamInventoryDefinitionUpdate_t__bindgen_ty_1 = 4702;
pub type SteamInventoryDefinitionUpdate_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamInventoryDefinitionUpdate_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryDefinitionUpdate_t>(),
        1usize,
        concat!("Size of: ", stringify!(SteamInventoryDefinitionUpdate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryDefinitionUpdate_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInventoryDefinitionUpdate_t)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SteamInventoryEligiblePromoItemDefIDs_t {
    pub m_result: EResult,
    pub m_steamID: CSteamID,
    pub m_numEligiblePromoItemDefs: ::std::os::raw::c_int,
    pub m_bCachedData: bool,
}
pub const SteamInventoryEligiblePromoItemDefIDs_t_k_iCallback:
    SteamInventoryEligiblePromoItemDefIDs_t__bindgen_ty_1 = 4703;
pub type SteamInventoryEligiblePromoItemDefIDs_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamInventoryEligiblePromoItemDefIDs_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInventoryEligiblePromoItemDefIDs_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryEligiblePromoItemDefIDs_t>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryEligiblePromoItemDefIDs_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t),
            "::",
            stringify!(m_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t),
            "::",
            stringify!(m_steamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_numEligiblePromoItemDefs) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t),
            "::",
            stringify!(m_numEligiblePromoItemDefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bCachedData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryEligiblePromoItemDefIDs_t),
            "::",
            stringify!(m_bCachedData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInventoryStartPurchaseResult_t {
    pub m_result: EResult,
    pub m_ulOrderID: uint64,
    pub m_ulTransID: uint64,
}
pub const SteamInventoryStartPurchaseResult_t_k_iCallback:
    SteamInventoryStartPurchaseResult_t__bindgen_ty_1 = 4704;
pub type SteamInventoryStartPurchaseResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamInventoryStartPurchaseResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInventoryStartPurchaseResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryStartPurchaseResult_t>(),
        24usize,
        concat!("Size of: ", stringify!(SteamInventoryStartPurchaseResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryStartPurchaseResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInventoryStartPurchaseResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryStartPurchaseResult_t),
            "::",
            stringify!(m_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulOrderID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryStartPurchaseResult_t),
            "::",
            stringify!(m_ulOrderID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulTransID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryStartPurchaseResult_t),
            "::",
            stringify!(m_ulTransID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamInventoryRequestPricesResult_t {
    pub m_result: EResult,
    pub m_rgchCurrency: [::std::os::raw::c_char; 4usize],
}
pub const SteamInventoryRequestPricesResult_t_k_iCallback:
    SteamInventoryRequestPricesResult_t__bindgen_ty_1 = 4705;
pub type SteamInventoryRequestPricesResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamInventoryRequestPricesResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamInventoryRequestPricesResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamInventoryRequestPricesResult_t>(),
        8usize,
        concat!("Size of: ", stringify!(SteamInventoryRequestPricesResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamInventoryRequestPricesResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamInventoryRequestPricesResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryRequestPricesResult_t),
            "::",
            stringify!(m_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchCurrency) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamInventoryRequestPricesResult_t),
            "::",
            stringify!(m_rgchCurrency)
        )
    );
}
#[repr(C)]
pub struct ISteamVideo__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamVideo {
    pub vtable_: *const ISteamVideo__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamVideo() {
    assert_eq!(
        ::std::mem::size_of::<ISteamVideo>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamVideo))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamVideo>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamVideo))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GetVideoURLResult_t {
    pub m_eResult: EResult,
    pub m_unVideoAppID: AppId_t,
    pub m_rgchURL: [::std::os::raw::c_char; 256usize],
}
pub const GetVideoURLResult_t_k_iCallback: GetVideoURLResult_t__bindgen_ty_1 = 4611;
pub type GetVideoURLResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GetVideoURLResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<GetVideoURLResult_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GetVideoURLResult_t>(),
        264usize,
        concat!("Size of: ", stringify!(GetVideoURLResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GetVideoURLResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GetVideoURLResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GetVideoURLResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unVideoAppID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GetVideoURLResult_t),
            "::",
            stringify!(m_unVideoAppID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchURL) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GetVideoURLResult_t),
            "::",
            stringify!(m_rgchURL)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GetOPFSettingsResult_t {
    pub m_eResult: EResult,
    pub m_unVideoAppID: AppId_t,
}
pub const GetOPFSettingsResult_t_k_iCallback: GetOPFSettingsResult_t__bindgen_ty_1 = 4624;
pub type GetOPFSettingsResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GetOPFSettingsResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<GetOPFSettingsResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GetOPFSettingsResult_t>(),
        8usize,
        concat!("Size of: ", stringify!(GetOPFSettingsResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GetOPFSettingsResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GetOPFSettingsResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GetOPFSettingsResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unVideoAppID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GetOPFSettingsResult_t),
            "::",
            stringify!(m_unVideoAppID)
        )
    );
}
pub const EParentalFeature_k_EFeatureInvalid: EParentalFeature = 0;
pub const EParentalFeature_k_EFeatureStore: EParentalFeature = 1;
pub const EParentalFeature_k_EFeatureCommunity: EParentalFeature = 2;
pub const EParentalFeature_k_EFeatureProfile: EParentalFeature = 3;
pub const EParentalFeature_k_EFeatureFriends: EParentalFeature = 4;
pub const EParentalFeature_k_EFeatureNews: EParentalFeature = 5;
pub const EParentalFeature_k_EFeatureTrading: EParentalFeature = 6;
pub const EParentalFeature_k_EFeatureSettings: EParentalFeature = 7;
pub const EParentalFeature_k_EFeatureConsole: EParentalFeature = 8;
pub const EParentalFeature_k_EFeatureBrowser: EParentalFeature = 9;
pub const EParentalFeature_k_EFeatureParentalSetup: EParentalFeature = 10;
pub const EParentalFeature_k_EFeatureLibrary: EParentalFeature = 11;
pub const EParentalFeature_k_EFeatureTest: EParentalFeature = 12;
pub const EParentalFeature_k_EFeatureSiteLicense: EParentalFeature = 13;
pub const EParentalFeature_k_EFeatureKioskMode_Deprecated: EParentalFeature = 14;
pub const EParentalFeature_k_EFeatureMax: EParentalFeature = 15;
pub type EParentalFeature = ::std::os::raw::c_int;
#[repr(C)]
pub struct ISteamParentalSettings__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamParentalSettings {
    pub vtable_: *const ISteamParentalSettings__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamParentalSettings() {
    assert_eq!(
        ::std::mem::size_of::<ISteamParentalSettings>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamParentalSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamParentalSettings>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamParentalSettings))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamParentalSettingsChanged_t {
    pub _address: u8,
}
pub const SteamParentalSettingsChanged_t_k_iCallback: SteamParentalSettingsChanged_t__bindgen_ty_1 =
    5001;
pub type SteamParentalSettingsChanged_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamParentalSettingsChanged_t() {
    assert_eq!(
        ::std::mem::size_of::<SteamParentalSettingsChanged_t>(),
        1usize,
        concat!("Size of: ", stringify!(SteamParentalSettingsChanged_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamParentalSettingsChanged_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamParentalSettingsChanged_t))
    );
}
pub const ESteamDeviceFormFactor_k_ESteamDeviceFormFactorUnknown: ESteamDeviceFormFactor = 0;
pub const ESteamDeviceFormFactor_k_ESteamDeviceFormFactorPhone: ESteamDeviceFormFactor = 1;
pub const ESteamDeviceFormFactor_k_ESteamDeviceFormFactorTablet: ESteamDeviceFormFactor = 2;
pub const ESteamDeviceFormFactor_k_ESteamDeviceFormFactorComputer: ESteamDeviceFormFactor = 3;
pub const ESteamDeviceFormFactor_k_ESteamDeviceFormFactorTV: ESteamDeviceFormFactor = 4;
pub const ESteamDeviceFormFactor_k_ESteamDeviceFormFactorVRHeadset: ESteamDeviceFormFactor = 5;
pub type ESteamDeviceFormFactor = ::std::os::raw::c_int;
pub type RemotePlaySessionID_t = uint32;
#[repr(C)]
pub struct ISteamRemotePlay__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamRemotePlay {
    pub vtable_: *const ISteamRemotePlay__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamRemotePlay() {
    assert_eq!(
        ::std::mem::size_of::<ISteamRemotePlay>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamRemotePlay))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamRemotePlay>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamRemotePlay))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamRemotePlaySessionConnected_t {
    pub m_unSessionID: RemotePlaySessionID_t,
}
pub const SteamRemotePlaySessionConnected_t_k_iCallback:
    SteamRemotePlaySessionConnected_t__bindgen_ty_1 = 5701;
pub type SteamRemotePlaySessionConnected_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamRemotePlaySessionConnected_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamRemotePlaySessionConnected_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamRemotePlaySessionConnected_t>(),
        4usize,
        concat!("Size of: ", stringify!(SteamRemotePlaySessionConnected_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamRemotePlaySessionConnected_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamRemotePlaySessionConnected_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unSessionID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRemotePlaySessionConnected_t),
            "::",
            stringify!(m_unSessionID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamRemotePlaySessionDisconnected_t {
    pub m_unSessionID: RemotePlaySessionID_t,
}
pub const SteamRemotePlaySessionDisconnected_t_k_iCallback:
    SteamRemotePlaySessionDisconnected_t__bindgen_ty_1 = 5702;
pub type SteamRemotePlaySessionDisconnected_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamRemotePlaySessionDisconnected_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamRemotePlaySessionDisconnected_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamRemotePlaySessionDisconnected_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SteamRemotePlaySessionDisconnected_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamRemotePlaySessionDisconnected_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SteamRemotePlaySessionDisconnected_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unSessionID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRemotePlaySessionDisconnected_t),
            "::",
            stringify!(m_unSessionID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamRemotePlayTogetherGuestInvite_t {
    pub m_szConnectURL: [::std::os::raw::c_char; 1024usize],
}
pub const SteamRemotePlayTogetherGuestInvite_t_k_iCallback:
    SteamRemotePlayTogetherGuestInvite_t__bindgen_ty_1 = 5703;
pub type SteamRemotePlayTogetherGuestInvite_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamRemotePlayTogetherGuestInvite_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamRemotePlayTogetherGuestInvite_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamRemotePlayTogetherGuestInvite_t>(),
        1024usize,
        concat!(
            "Size of: ",
            stringify!(SteamRemotePlayTogetherGuestInvite_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamRemotePlayTogetherGuestInvite_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamRemotePlayTogetherGuestInvite_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szConnectURL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRemotePlayTogetherGuestInvite_t),
            "::",
            stringify!(m_szConnectURL)
        )
    );
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamDatagramRelayAuthTicket {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamDatagramHostedAddress {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamDatagramGameCoordinatorServerLogin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingFakeIPResult_t {
    _unused: [u8; 0],
}
pub type FnSteamNetConnectionStatusChanged = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut SteamNetConnectionStatusChangedCallback_t),
>;
pub type FnSteamNetAuthenticationStatusChanged =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamNetAuthenticationStatus_t)>;
pub type FnSteamRelayNetworkStatusChanged =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamRelayNetworkStatus_t)>;
pub type FnSteamNetworkingMessagesSessionRequest =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamNetworkingMessagesSessionRequest_t)>;
pub type FnSteamNetworkingMessagesSessionFailed =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamNetworkingMessagesSessionFailed_t)>;
pub type FnSteamNetworkingFakeIPResult =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut SteamNetworkingFakeIPResult_t)>;
#[doc = " Handle used to identify a connection to a remote host."]
pub type HSteamNetConnection = uint32;
pub const k_HSteamNetConnection_Invalid: HSteamNetConnection = 0;
#[doc = " Handle used to identify a \"listen socket\".  Unlike traditional\n Berkeley sockets, a listen socket and a connection are two\n different abstractions."]
pub type HSteamListenSocket = uint32;
pub const k_HSteamListenSocket_Invalid: HSteamListenSocket = 0;
#[doc = " Handle used to identify a poll group, used to query many\n connections at once efficiently."]
pub type HSteamNetPollGroup = uint32;
pub const k_HSteamNetPollGroup_Invalid: HSteamNetPollGroup = 0;
#[doc = " Max length of diagnostic error message"]
pub const k_cchMaxSteamNetworkingErrMsg: ::std::os::raw::c_int = 1024;
#[doc = " Used to return English-language diagnostic error messages to caller.\n (For debugging or spewing to a console, etc.  Not intended for UI.)"]
pub type SteamNetworkingErrMsg = [::std::os::raw::c_char; 1024usize];
#[doc = " Identifier used for a network location point of presence.  (E.g. a Valve data center.)\n Typically you won't need to directly manipulate these."]
pub type SteamNetworkingPOPID = uint32;
#[doc = " A local timestamp.  You can subtract two timestamps to get the number of elapsed\n microseconds.  This is guaranteed to increase over time during the lifetime\n of a process, but not globally across runs.  You don't need to worry about\n the value wrapping around.  Note that the underlying clock might not actually have\n microsecond resolution."]
pub type SteamNetworkingMicroseconds = int64;
pub const ESteamNetworkingAvailability_k_ESteamNetworkingAvailability_CannotTry:
    ESteamNetworkingAvailability = -102;
pub const ESteamNetworkingAvailability_k_ESteamNetworkingAvailability_Failed:
    ESteamNetworkingAvailability = -101;
pub const ESteamNetworkingAvailability_k_ESteamNetworkingAvailability_Previously:
    ESteamNetworkingAvailability = -100;
pub const ESteamNetworkingAvailability_k_ESteamNetworkingAvailability_Retrying:
    ESteamNetworkingAvailability = -10;
pub const ESteamNetworkingAvailability_k_ESteamNetworkingAvailability_NeverTried:
    ESteamNetworkingAvailability = 1;
pub const ESteamNetworkingAvailability_k_ESteamNetworkingAvailability_Waiting:
    ESteamNetworkingAvailability = 2;
pub const ESteamNetworkingAvailability_k_ESteamNetworkingAvailability_Attempting:
    ESteamNetworkingAvailability = 3;
pub const ESteamNetworkingAvailability_k_ESteamNetworkingAvailability_Current:
    ESteamNetworkingAvailability = 100;
pub const ESteamNetworkingAvailability_k_ESteamNetworkingAvailability_Unknown:
    ESteamNetworkingAvailability = 0;
pub const ESteamNetworkingAvailability_k_ESteamNetworkingAvailability__Force32bit:
    ESteamNetworkingAvailability = 2147483647;
#[doc = " Describe the status of a particular network resource"]
pub type ESteamNetworkingAvailability = ::std::os::raw::c_int;
pub const ESteamNetworkingIdentityType_k_ESteamNetworkingIdentityType_Invalid:
    ESteamNetworkingIdentityType = 0;
pub const ESteamNetworkingIdentityType_k_ESteamNetworkingIdentityType_SteamID:
    ESteamNetworkingIdentityType = 16;
pub const ESteamNetworkingIdentityType_k_ESteamNetworkingIdentityType_XboxPairwiseID:
    ESteamNetworkingIdentityType = 17;
pub const ESteamNetworkingIdentityType_k_ESteamNetworkingIdentityType_SonyPSN:
    ESteamNetworkingIdentityType = 18;
pub const ESteamNetworkingIdentityType_k_ESteamNetworkingIdentityType_GoogleStadia:
    ESteamNetworkingIdentityType = 19;
pub const ESteamNetworkingIdentityType_k_ESteamNetworkingIdentityType_IPAddress:
    ESteamNetworkingIdentityType = 1;
pub const ESteamNetworkingIdentityType_k_ESteamNetworkingIdentityType_GenericString:
    ESteamNetworkingIdentityType = 2;
pub const ESteamNetworkingIdentityType_k_ESteamNetworkingIdentityType_GenericBytes:
    ESteamNetworkingIdentityType = 3;
pub const ESteamNetworkingIdentityType_k_ESteamNetworkingIdentityType_UnknownType:
    ESteamNetworkingIdentityType = 4;
pub const ESteamNetworkingIdentityType_k_ESteamNetworkingIdentityType__Force32bit:
    ESteamNetworkingIdentityType = 2147483647;
#[doc = " Different methods of describing the identity of a network host"]
pub type ESteamNetworkingIdentityType = ::std::os::raw::c_int;
pub const ESteamNetworkingFakeIPType_k_ESteamNetworkingFakeIPType_Invalid:
    ESteamNetworkingFakeIPType = 0;
pub const ESteamNetworkingFakeIPType_k_ESteamNetworkingFakeIPType_NotFake:
    ESteamNetworkingFakeIPType = 1;
pub const ESteamNetworkingFakeIPType_k_ESteamNetworkingFakeIPType_GlobalIPv4:
    ESteamNetworkingFakeIPType = 2;
pub const ESteamNetworkingFakeIPType_k_ESteamNetworkingFakeIPType_LocalIPv4:
    ESteamNetworkingFakeIPType = 3;
pub const ESteamNetworkingFakeIPType_k_ESteamNetworkingFakeIPType__Force32Bit:
    ESteamNetworkingFakeIPType = 2147483647;
#[doc = " \"Fake IPs\" are assigned to hosts, to make it easier to interface with\n older code that assumed all hosts will have an IPv4 address"]
pub type ESteamNetworkingFakeIPType = ::std::os::raw::c_int;
#[doc = " Store an IP and port.  IPv6 is always used; IPv4 is represented using\n \"IPv4-mapped\" addresses: IPv4 aa.bb.cc.dd => IPv6 ::ffff:aabb:ccdd\n (RFC 4291 section 2.5.5.2.)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingIPAddr {
    pub __bindgen_anon_1: SteamNetworkingIPAddr__bindgen_ty_2,
    pub m_port: uint16,
}
pub const SteamNetworkingIPAddr_k_cchMaxString: SteamNetworkingIPAddr__bindgen_ty_1 = 48;
pub type SteamNetworkingIPAddr__bindgen_ty_1 = ::std::os::raw::c_int;
#[doc = " RFC4038, section 4.2"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingIPAddr_IPv4MappedAddress {
    pub m_8zeros: uint64,
    pub m_0000: uint16,
    pub m_ffff: uint16,
    pub m_ip: [uint8; 4usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingIPAddr_IPv4MappedAddress() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIPAddr_IPv4MappedAddress> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIPAddr_IPv4MappedAddress>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIPAddr_IPv4MappedAddress>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_8zeros) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress),
            "::",
            stringify!(m_8zeros)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_0000) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress),
            "::",
            stringify!(m_0000)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ffff) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress),
            "::",
            stringify!(m_ffff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ip) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr_IPv4MappedAddress),
            "::",
            stringify!(m_ip)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SteamNetworkingIPAddr__bindgen_ty_2 {
    pub m_ipv6: [uint8; 16usize],
    pub m_ipv4: SteamNetworkingIPAddr_IPv4MappedAddress,
}
#[test]
fn bindgen_test_layout_SteamNetworkingIPAddr__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIPAddr__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIPAddr__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(SteamNetworkingIPAddr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIPAddr__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingIPAddr__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ipv6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr__bindgen_ty_2),
            "::",
            stringify!(m_ipv6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ipv4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr__bindgen_ty_2),
            "::",
            stringify!(m_ipv4)
        )
    );
}
#[test]
fn bindgen_test_layout_SteamNetworkingIPAddr() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIPAddr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIPAddr>(),
        18usize,
        concat!("Size of: ", stringify!(SteamNetworkingIPAddr))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIPAddr>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingIPAddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_port) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddr),
            "::",
            stringify!(m_port)
        )
    );
}
#[doc = " An abstract way to represent the identity of a network host.  All identities can\n be represented as simple string.  Furthermore, this string representation is actually\n used on the wire in several places, even though it is less efficient, in order to\n facilitate forward compatibility.  (Old client code can handle an identity type that\n it doesn't understand.)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingIdentity {
    #[doc = " Type of identity."]
    pub m_eType: ESteamNetworkingIdentityType,
    pub m_cbSize: ::std::os::raw::c_int,
    pub __bindgen_anon_1: SteamNetworkingIdentity__bindgen_ty_2,
}
pub const SteamNetworkingIdentity_k_cchMaxString: SteamNetworkingIdentity__bindgen_ty_1 = 128;
pub const SteamNetworkingIdentity_k_cchMaxGenericString: SteamNetworkingIdentity__bindgen_ty_1 = 32;
pub const SteamNetworkingIdentity_k_cchMaxXboxPairwiseID: SteamNetworkingIdentity__bindgen_ty_1 =
    33;
pub const SteamNetworkingIdentity_k_cbMaxGenericBytes: SteamNetworkingIdentity__bindgen_ty_1 = 32;
pub type SteamNetworkingIdentity__bindgen_ty_1 = ::std::os::raw::c_int;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union SteamNetworkingIdentity__bindgen_ty_2 {
    pub m_steamID64: uint64,
    pub m_PSNID: uint64,
    pub m_stadiaID: uint64,
    pub m_szGenericString: [::std::os::raw::c_char; 32usize],
    pub m_szXboxPairwiseID: [::std::os::raw::c_char; 33usize],
    pub m_genericBytes: [uint8; 32usize],
    pub m_szUnknownRawString: [::std::os::raw::c_char; 128usize],
    pub m_ip: SteamNetworkingIPAddr,
    pub m_reserved: [uint32; 32usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingIdentity__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIdentity__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIdentity__bindgen_ty_2>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIdentity__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamID64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_steamID64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_PSNID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_PSNID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_stadiaID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_stadiaID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szGenericString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_szGenericString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szXboxPairwiseID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_szXboxPairwiseID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_genericBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_genericBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szUnknownRawString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_szUnknownRawString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ip) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity__bindgen_ty_2),
            "::",
            stringify!(m_reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_SteamNetworkingIdentity() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIdentity> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIdentity>(),
        136usize,
        concat!("Size of: ", stringify!(SteamNetworkingIdentity))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIdentity>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingIdentity))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity),
            "::",
            stringify!(m_eType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentity),
            "::",
            stringify!(m_cbSize)
        )
    );
}
#[doc = " Dummy value used to indicate an error condition in the API.\n Specified connection doesn't exist or has already been closed."]
pub const ESteamNetworkingConnectionState_k_ESteamNetworkingConnectionState_None:
    ESteamNetworkingConnectionState = 0;
#[doc = " We are trying to establish whether peers can talk to each other,\n whether they WANT to talk to each other, perform basic auth,\n and exchange crypt keys.\n\n - For connections on the \"client\" side (initiated locally):\n   We're in the process of trying to establish a connection.\n   Depending on the connection type, we might not know who they are.\n   Note that it is not possible to tell if we are waiting on the\n   network to complete handshake packets, or for the application layer\n   to accept the connection.\n\n - For connections on the \"server\" side (accepted through listen socket):\n   We have completed some basic handshake and the client has presented\n   some proof of identity.  The connection is ready to be accepted\n   using AcceptConnection().\n\n In either case, any unreliable packets sent now are almost certain\n to be dropped.  Attempts to receive packets are guaranteed to fail.\n You may send messages if the send mode allows for them to be queued.\n but if you close the connection before the connection is actually\n established, any queued messages will be discarded immediately.\n (We will not attempt to flush the queue and confirm delivery to the\n remote host, which ordinarily happens when a connection is closed.)"]
pub const ESteamNetworkingConnectionState_k_ESteamNetworkingConnectionState_Connecting:
    ESteamNetworkingConnectionState = 1;
#[doc = " Some connection types use a back channel or trusted 3rd party\n for earliest communication.  If the server accepts the connection,\n then these connections switch into the rendezvous state.  During this\n state, we still have not yet established an end-to-end route (through\n the relay network), and so if you send any messages unreliable, they\n are going to be discarded."]
pub const ESteamNetworkingConnectionState_k_ESteamNetworkingConnectionState_FindingRoute:
    ESteamNetworkingConnectionState = 2;
#[doc = " We've received communications from our peer (and we know\n who they are) and are all good.  If you close the connection now,\n we will make our best effort to flush out any reliable sent data that\n has not been acknowledged by the peer.  (But note that this happens\n from within the application process, so unlike a TCP connection, you are\n not totally handing it off to the operating system to deal with it.)"]
pub const ESteamNetworkingConnectionState_k_ESteamNetworkingConnectionState_Connected:
    ESteamNetworkingConnectionState = 3;
#[doc = " Connection has been closed by our peer, but not closed locally.\n The connection still exists from an API perspective.  You must close the\n handle to free up resources.  If there are any messages in the inbound queue,\n you may retrieve them.  Otherwise, nothing may be done with the connection\n except to close it.\n\n This stats is similar to CLOSE_WAIT in the TCP state machine."]
pub const ESteamNetworkingConnectionState_k_ESteamNetworkingConnectionState_ClosedByPeer:
    ESteamNetworkingConnectionState = 4;
#[doc = " A disruption in the connection has been detected locally.  (E.g. timeout,\n local internet connection disrupted, etc.)\n\n The connection still exists from an API perspective.  You must close the\n handle to free up resources.\n\n Attempts to send further messages will fail.  Any remaining received messages\n in the queue are available."]
pub const ESteamNetworkingConnectionState_k_ESteamNetworkingConnectionState_ProblemDetectedLocally : ESteamNetworkingConnectionState = 5 ;
#[doc = " We've disconnected on our side, and from an API perspective the connection is closed.\n No more data may be sent or received.  All reliable data has been flushed, or else\n we've given up and discarded it.  We do not yet know for sure that the peer knows\n the connection has been closed, however, so we're just hanging around so that if we do\n get a packet from them, we can send them the appropriate packets so that they can\n know why the connection was closed (and not have to rely on a timeout, which makes\n it appear as if something is wrong)."]
pub const ESteamNetworkingConnectionState_k_ESteamNetworkingConnectionState_FinWait:
    ESteamNetworkingConnectionState = -1;
#[doc = " We've disconnected on our side, and from an API perspective the connection is closed.\n No more data may be sent or received.  From a network perspective, however, on the wire,\n we have not yet given any indication to the peer that the connection is closed.\n We are in the process of flushing out the last bit of reliable data.  Once that is done,\n we will inform the peer that the connection has been closed, and transition to the\n FinWait state.\n\n Note that no indication is given to the remote host that we have closed the connection,\n until the data has been flushed.  If the remote host attempts to send us data, we will\n do whatever is necessary to keep the connection alive until it can be closed properly.\n But in fact the data will be discarded, since there is no way for the application to\n read it back.  Typically this is not a problem, as application protocols that utilize\n the lingering functionality are designed for the remote host to wait for the response\n before sending any more data."]
pub const ESteamNetworkingConnectionState_k_ESteamNetworkingConnectionState_Linger:
    ESteamNetworkingConnectionState = -2;
#[doc = " Connection is completely inactive and ready to be destroyed"]
pub const ESteamNetworkingConnectionState_k_ESteamNetworkingConnectionState_Dead:
    ESteamNetworkingConnectionState = -3;
#[doc = " Connection is completely inactive and ready to be destroyed"]
pub const ESteamNetworkingConnectionState_k_ESteamNetworkingConnectionState__Force32Bit:
    ESteamNetworkingConnectionState = 2147483647;
#[doc = " High level connection status"]
pub type ESteamNetworkingConnectionState = ::std::os::raw::c_int;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Invalid: ESteamNetConnectionEnd = 0;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_App_Min: ESteamNetConnectionEnd = 1000;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_App_Generic: ESteamNetConnectionEnd =
    1000;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_App_Max: ESteamNetConnectionEnd = 1999;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_AppException_Min: ESteamNetConnectionEnd =
    2000;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_AppException_Generic:
    ESteamNetConnectionEnd = 2000;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_AppException_Max: ESteamNetConnectionEnd =
    2999;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Local_Min: ESteamNetConnectionEnd = 3000;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Local_OfflineMode:
    ESteamNetConnectionEnd = 3001;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Local_ManyRelayConnectivity:
    ESteamNetConnectionEnd = 3002;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Local_HostedServerPrimaryRelay:
    ESteamNetConnectionEnd = 3003;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Local_NetworkConfig:
    ESteamNetConnectionEnd = 3004;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Local_Rights: ESteamNetConnectionEnd =
    3005;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Local_P2P_ICE_NoPublicAddresses:
    ESteamNetConnectionEnd = 3006;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Local_Max: ESteamNetConnectionEnd = 3999;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Remote_Min: ESteamNetConnectionEnd = 4000;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Remote_Timeout: ESteamNetConnectionEnd =
    4001;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Remote_BadCrypt: ESteamNetConnectionEnd =
    4002;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Remote_BadCert: ESteamNetConnectionEnd =
    4003;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Remote_BadProtocolVersion:
    ESteamNetConnectionEnd = 4006;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Remote_P2P_ICE_NoPublicAddresses:
    ESteamNetConnectionEnd = 4007;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Remote_Max: ESteamNetConnectionEnd = 4999;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Misc_Min: ESteamNetConnectionEnd = 5000;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Misc_Generic: ESteamNetConnectionEnd =
    5001;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Misc_InternalError:
    ESteamNetConnectionEnd = 5002;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Misc_Timeout: ESteamNetConnectionEnd =
    5003;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Misc_SteamConnectivity:
    ESteamNetConnectionEnd = 5005;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Misc_NoRelaySessionsToClient:
    ESteamNetConnectionEnd = 5006;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Misc_P2P_Rendezvous:
    ESteamNetConnectionEnd = 5008;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Misc_P2P_NAT_Firewall:
    ESteamNetConnectionEnd = 5009;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Misc_PeerSentNoConnection:
    ESteamNetConnectionEnd = 5010;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd_Misc_Max: ESteamNetConnectionEnd = 5999;
pub const ESteamNetConnectionEnd_k_ESteamNetConnectionEnd__Force32Bit: ESteamNetConnectionEnd =
    2147483647;
#[doc = " Enumerate various causes of connection termination.  These are designed to work similar\n to HTTP error codes: the numeric range gives you a rough classification as to the source\n of the problem."]
pub type ESteamNetConnectionEnd = ::std::os::raw::c_int;
#[doc = " Max length, in bytes (including null terminator) of the reason string\n when a connection is closed."]
pub const k_cchSteamNetworkingMaxConnectionCloseReason: ::std::os::raw::c_int = 128;
#[doc = " Max length, in bytes (include null terminator) of debug description\n of a connection."]
pub const k_cchSteamNetworkingMaxConnectionDescription: ::std::os::raw::c_int = 128;
#[doc = " Max length of the app's part of the description"]
pub const k_cchSteamNetworkingMaxConnectionAppName: ::std::os::raw::c_int = 32;
pub const k_nSteamNetworkConnectionInfoFlags_Unauthenticated: ::std::os::raw::c_int = 1;
pub const k_nSteamNetworkConnectionInfoFlags_Unencrypted: ::std::os::raw::c_int = 2;
pub const k_nSteamNetworkConnectionInfoFlags_LoopbackBuffers: ::std::os::raw::c_int = 4;
pub const k_nSteamNetworkConnectionInfoFlags_Fast: ::std::os::raw::c_int = 8;
pub const k_nSteamNetworkConnectionInfoFlags_Relayed: ::std::os::raw::c_int = 16;
pub const k_nSteamNetworkConnectionInfoFlags_DualWifi: ::std::os::raw::c_int = 32;
#[doc = " Describe the state of a connection."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SteamNetConnectionInfo_t {
    #[doc = " Who is on the other end?  Depending on the connection type and phase of the connection, we might not know"]
    pub m_identityRemote: SteamNetworkingIdentity,
    #[doc = " Arbitrary user data set by the local application code"]
    pub m_nUserData: int64,
    #[doc = " Handle to listen socket this was connected on, or k_HSteamListenSocket_Invalid if we initiated the connection"]
    pub m_hListenSocket: HSteamListenSocket,
    #[doc = " Remote address.  Might be all 0's if we don't know it, or if this is N/A.\n (E.g. Basically everything except direct UDP connection.)"]
    pub m_addrRemote: SteamNetworkingIPAddr,
    pub m__pad1: uint16,
    #[doc = " What data center is the remote host in?  (0 if we don't know.)"]
    pub m_idPOPRemote: SteamNetworkingPOPID,
    #[doc = " What relay are we using to communicate with the remote host?\n (0 if not applicable.)"]
    pub m_idPOPRelay: SteamNetworkingPOPID,
    #[doc = " High level state of the connection"]
    pub m_eState: ESteamNetworkingConnectionState,
    #[doc = " Basic cause of the connection termination or problem.\n See ESteamNetConnectionEnd for the values used"]
    pub m_eEndReason: ::std::os::raw::c_int,
    #[doc = " Human-readable, but non-localized explanation for connection\n termination or problem.  This is intended for debugging /\n diagnostic purposes only, not to display to users.  It might\n have some details specific to the issue."]
    pub m_szEndDebug: [::std::os::raw::c_char; 128usize],
    #[doc = " Debug description.  This includes the internal connection ID,\n connection type (and peer information), and any name\n given to the connection by the app.  This string is used in various\n internal logging messages.\n\n Note that the connection ID *usually* matches the HSteamNetConnection\n handle, but in certain cases with symmetric connections it might not."]
    pub m_szConnectionDescription: [::std::os::raw::c_char; 128usize],
    #[doc = " Misc flags.  Bitmask of k_nSteamNetworkConnectionInfoFlags_Xxxx"]
    pub m_nFlags: ::std::os::raw::c_int,
    #[doc = " Internal stuff, room to change API easily"]
    pub reserved: [uint32; 63usize],
}
#[test]
fn bindgen_test_layout_SteamNetConnectionInfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetConnectionInfo_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetConnectionInfo_t>(),
        696usize,
        concat!("Size of: ", stringify!(SteamNetConnectionInfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetConnectionInfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamNetConnectionInfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_identityRemote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_identityRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nUserData) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_nUserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hListenSocket) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_hListenSocket)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_addrRemote) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_addrRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m__pad1) as usize - ptr as usize },
        166usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_idPOPRemote) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_idPOPRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_idPOPRelay) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_idPOPRelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eState) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_eState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eEndReason) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_eEndReason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szEndDebug) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_szEndDebug)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szConnectionDescription) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_szConnectionDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nFlags) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(m_nFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionInfo_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Quick connection state, pared down to something you could call\n more frequently without it being too big of a perf hit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetConnectionRealTimeStatus_t {
    #[doc = " High level state of the connection"]
    pub m_eState: ESteamNetworkingConnectionState,
    #[doc = " Current ping (ms)"]
    pub m_nPing: ::std::os::raw::c_int,
    #[doc = " Connection quality measured locally, 0...1.  (Percentage of packets delivered\n end-to-end in order)."]
    pub m_flConnectionQualityLocal: f32,
    #[doc = " Packet delivery success rate as observed from remote host"]
    pub m_flConnectionQualityRemote: f32,
    #[doc = " Current data rates from recent history."]
    pub m_flOutPacketsPerSec: f32,
    pub m_flOutBytesPerSec: f32,
    pub m_flInPacketsPerSec: f32,
    pub m_flInBytesPerSec: f32,
    #[doc = " Estimate rate that we believe that we can send data to our peer.\n Note that this could be significantly higher than m_flOutBytesPerSec,\n meaning the capacity of the channel is higher than you are sending data.\n (That's OK!)"]
    pub m_nSendRateBytesPerSecond: ::std::os::raw::c_int,
    #[doc = " Number of bytes pending to be sent.  This is data that you have recently\n requested to be sent but has not yet actually been put on the wire.  The\n reliable number ALSO includes data that was previously placed on the wire,\n but has now been scheduled for re-transmission.  Thus, it's possible to\n observe m_cbPendingReliable increasing between two checks, even if no\n calls were made to send reliable data between the checks.  Data that is\n awaiting the Nagle delay will appear in these numbers."]
    pub m_cbPendingUnreliable: ::std::os::raw::c_int,
    pub m_cbPendingReliable: ::std::os::raw::c_int,
    #[doc = " Number of bytes of reliable data that has been placed the wire, but\n for which we have not yet received an acknowledgment, and thus we may\n have to re-transmit."]
    pub m_cbSentUnackedReliable: ::std::os::raw::c_int,
    #[doc = " If you queued a message right now, approximately how long would that message\n wait in the queue before we actually started putting its data on the wire in\n a packet?\n\n In general, data that is sent by the application is limited by the bandwidth\n of the channel.  If you send data faster than this, it must be queued and\n put on the wire at a metered rate.  Even sending a small amount of data (e.g.\n a few MTU, say ~3k) will require some of the data to be delayed a bit.\n\n Ignoring multiple lanes, the estimated delay will be approximately equal to\n\n\t\t( m_cbPendingUnreliable+m_cbPendingReliable ) / m_nSendRateBytesPerSecond\n\n plus or minus one MTU.  It depends on how much time has elapsed since the last\n packet was put on the wire.  For example, the queue might have *just* been emptied,\n and the last packet placed on the wire, and we are exactly up against the send\n rate limit.  In that case we might need to wait for one packet's worth of time to\n elapse before we can send again.  On the other extreme, the queue might have data\n in it waiting for Nagle.  (This will always be less than one packet, because as\n soon as we have a complete packet we would send it.)  In that case, we might be\n ready to send data now, and this value will be 0.\n\n This value is only valid if multiple lanes are not used.  If multiple lanes are\n in use, then the queue time will be different for each lane, and you must use\n the value in SteamNetConnectionRealTimeLaneStatus_t.\n\n Nagle delay is ignored for the purposes of this calculation."]
    pub m_usecQueueTime: SteamNetworkingMicroseconds,
    pub reserved: [uint32; 16usize],
}
#[test]
fn bindgen_test_layout_SteamNetConnectionRealTimeStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetConnectionRealTimeStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetConnectionRealTimeStatus_t>(),
        120usize,
        concat!("Size of: ", stringify!(SteamNetConnectionRealTimeStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetConnectionRealTimeStatus_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetConnectionRealTimeStatus_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_eState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPing) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_nPing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flConnectionQualityLocal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flConnectionQualityLocal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flConnectionQualityRemote) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flConnectionQualityRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flOutPacketsPerSec) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flOutPacketsPerSec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flOutBytesPerSec) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flOutBytesPerSec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flInPacketsPerSec) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flInPacketsPerSec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flInBytesPerSec) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_flInBytesPerSec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nSendRateBytesPerSecond) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_nSendRateBytesPerSecond)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbPendingUnreliable) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_cbPendingUnreliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbPendingReliable) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_cbPendingReliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbSentUnackedReliable) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_cbSentUnackedReliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usecQueueTime) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(m_usecQueueTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeStatus_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Quick status of a particular lane"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetConnectionRealTimeLaneStatus_t {
    pub m_cbPendingUnreliable: ::std::os::raw::c_int,
    pub m_cbPendingReliable: ::std::os::raw::c_int,
    pub m_cbSentUnackedReliable: ::std::os::raw::c_int,
    pub _reservePad1: ::std::os::raw::c_int,
    #[doc = " Lane-specific queue time.  This value takes into consideration lane priorities\n and weights, and how much data is queued in each lane, and attempts to predict\n how any data currently queued will be sent out."]
    pub m_usecQueueTime: SteamNetworkingMicroseconds,
    pub reserved: [uint32; 10usize],
}
#[test]
fn bindgen_test_layout_SteamNetConnectionRealTimeLaneStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetConnectionRealTimeLaneStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetConnectionRealTimeLaneStatus_t>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetConnectionRealTimeLaneStatus_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbPendingUnreliable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(m_cbPendingUnreliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbPendingReliable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(m_cbPendingReliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbSentUnackedReliable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(m_cbSentUnackedReliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._reservePad1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(_reservePad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usecQueueTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(m_usecQueueTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionRealTimeLaneStatus_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Max size of a single message that we can SEND.\n Note: We might be wiling to receive larger messages,\n and our peer might, too."]
pub const k_cbMaxSteamNetworkingSocketsMessageSizeSend: ::std::os::raw::c_int = 524288;
#[doc = " A message that has been received."]
#[repr(C)]
pub struct SteamNetworkingMessage_t {
    #[doc = " Message payload"]
    pub m_pData: *mut ::std::os::raw::c_void,
    #[doc = " Size of the payload."]
    pub m_cbSize: ::std::os::raw::c_int,
    #[doc = " For messages received on connections: what connection did this come from?\n For outgoing messages: what connection to send it to?\n Not used when using the ISteamNetworkingMessages interface"]
    pub m_conn: HSteamNetConnection,
    #[doc = " For inbound messages: Who sent this to us?\n For outbound messages on connections: not used.\n For outbound messages on the ad-hoc ISteamNetworkingMessages interface: who should we send this to?"]
    pub m_identityPeer: SteamNetworkingIdentity,
    #[doc = " For messages received on connections, this is the user data\n associated with the connection.\n\n This is *usually* the same as calling GetConnection() and then\n fetching the user data associated with that connection, but for\n the following subtle differences:\n\n - This user data will match the connection's user data at the time\n   is captured at the time the message is returned by the API.\n   If you subsequently change the userdata on the connection,\n   this won't be updated.\n - This is an inline call, so it's *much* faster.\n - You might have closed the connection, so fetching the user data\n   would not be possible.\n\n Not used when sending messages."]
    pub m_nConnUserData: int64,
    #[doc = " Local timestamp when the message was received\n Not used for outbound messages."]
    pub m_usecTimeReceived: SteamNetworkingMicroseconds,
    #[doc = " Message number assigned by the sender.  This is not used for outbound\n messages.  Note that if multiple lanes are used, each lane has its own\n message numbers, which are assigned sequentially, so messages from\n different lanes will share the same numbers."]
    pub m_nMessageNumber: int64,
    #[doc = " Function used to free up m_pData.  This mechanism exists so that\n apps can create messages with buffers allocated from their own\n heap, and pass them into the library.  This function will\n usually be something like:\n\n free( pMsg->m_pData );"]
    pub m_pfnFreeData:
        ::std::option::Option<unsafe extern "C" fn(pMsg: *mut SteamNetworkingMessage_t)>,
    #[doc = " Function to used to decrement the internal reference count and, if\n it's zero, release the message.  You should not set this function pointer,\n or need to access this directly!  Use the Release() function instead!"]
    pub m_pfnRelease:
        ::std::option::Option<unsafe extern "C" fn(pMsg: *mut SteamNetworkingMessage_t)>,
    #[doc = " When using ISteamNetworkingMessages, the channel number the message was received on\n (Not used for messages sent or received on \"connections\")"]
    pub m_nChannel: ::std::os::raw::c_int,
    #[doc = " Bitmask of k_nSteamNetworkingSend_xxx flags.\n For received messages, only the k_nSteamNetworkingSend_Reliable bit is valid.\n For outbound messages, all bits are relevant"]
    pub m_nFlags: ::std::os::raw::c_int,
    #[doc = " Arbitrary user data that you can use when sending messages using\n ISteamNetworkingUtils::AllocateMessage and ISteamNetworkingSockets::SendMessage.\n (The callback you set in m_pfnFreeData might use this field.)\n\n Not used for received messages."]
    pub m_nUserData: int64,
    #[doc = " For outbound messages, which lane to use?  See ISteamNetworkingSockets::ConfigureConnectionLanes.\n For inbound messages, what lane was the message received on?"]
    pub m_idxLane: uint16,
    pub _pad1__: uint16,
}
#[test]
fn bindgen_test_layout_SteamNetworkingMessage_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingMessage_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingMessage_t>(),
        216usize,
        concat!("Size of: ", stringify!(SteamNetworkingMessage_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingMessage_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamNetworkingMessage_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_pData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cbSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_cbSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_conn) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_conn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_identityPeer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_identityPeer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nConnUserData) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_nConnUserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usecTimeReceived) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_usecTimeReceived)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nMessageNumber) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_nMessageNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pfnFreeData) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_pfnFreeData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pfnRelease) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_pfnRelease)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nChannel) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_nChannel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nFlags) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_nFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nUserData) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_nUserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_idxLane) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(m_idxLane)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pad1__) as usize - ptr as usize },
        210usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessage_t),
            "::",
            stringify!(_pad1__)
        )
    );
}
pub const k_nSteamNetworkingSend_Unreliable: ::std::os::raw::c_int = 0;
pub const k_nSteamNetworkingSend_NoNagle: ::std::os::raw::c_int = 1;
pub const k_nSteamNetworkingSend_UnreliableNoNagle: ::std::os::raw::c_int = 1;
pub const k_nSteamNetworkingSend_NoDelay: ::std::os::raw::c_int = 4;
pub const k_nSteamNetworkingSend_UnreliableNoDelay: ::std::os::raw::c_int = 5;
pub const k_nSteamNetworkingSend_Reliable: ::std::os::raw::c_int = 8;
pub const k_nSteamNetworkingSend_ReliableNoNagle: ::std::os::raw::c_int = 9;
pub const k_nSteamNetworkingSend_UseCurrentThread: ::std::os::raw::c_int = 16;
pub const k_nSteamNetworkingSend_AutoRestartBrokenSession: ::std::os::raw::c_int = 32;
#[doc = " Object that describes a \"location\" on the Internet with sufficient\n detail that we can reasonably estimate an upper bound on the ping between\n the two hosts, even if a direct route between the hosts is not possible,\n and the connection must be routed through the Steam Datagram Relay network.\n This does not contain any information that identifies the host.  Indeed,\n if two hosts are in the same building or otherwise have nearly identical\n networking characteristics, then it's valid to use the same location\n object for both of them.\n\n NOTE: This object should only be used in the same process!  Do not serialize it,\n send it over the wire, or persist it in a file or database!  If you need\n to do that, convert it to a string representation using the methods in\n ISteamNetworkingUtils()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkPingLocation_t {
    pub m_data: [uint8; 512usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkPingLocation_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkPingLocation_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkPingLocation_t>(),
        512usize,
        concat!("Size of: ", stringify!(SteamNetworkPingLocation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkPingLocation_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkPingLocation_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkPingLocation_t),
            "::",
            stringify!(m_data)
        )
    );
}
#[doc = " Max possible length of a ping location, in string format.  This is\n an extremely conservative worst case value which leaves room for future\n syntax enhancements.  Most strings in practice are a lot shorter.\n If you are storing many of these, you will very likely benefit from\n using dynamic memory."]
pub const k_cchMaxSteamNetworkingPingLocationString: ::std::os::raw::c_int = 1024;
#[doc = " Special values that are returned by some functions that return a ping."]
pub const k_nSteamNetworkingPing_Failed: ::std::os::raw::c_int = -1;
pub const k_nSteamNetworkingPing_Unknown: ::std::os::raw::c_int = -2;
#[doc = " Get/set global option, or defaults.  Even options that apply to more specific scopes\n have global scope, and you may be able to just change the global defaults.  If you\n need different settings per connection (for example), then you will need to set those\n options at the more specific scope."]
pub const ESteamNetworkingConfigScope_k_ESteamNetworkingConfig_Global: ESteamNetworkingConfigScope =
    1;
#[doc = " Some options are specific to a particular interface.  Note that all connection\n and listen socket settings can also be set at the interface level, and they will\n apply to objects created through those interfaces."]
pub const ESteamNetworkingConfigScope_k_ESteamNetworkingConfig_SocketsInterface:
    ESteamNetworkingConfigScope = 2;
#[doc = " Options for a listen socket.  Listen socket options can be set at the interface layer,\n if  you have multiple listen sockets and they all use the same options.\n You can also set connection options on a listen socket, and they set the defaults\n for all connections accepted through this listen socket.  (They will be used if you don't\n set a connection option.)"]
pub const ESteamNetworkingConfigScope_k_ESteamNetworkingConfig_ListenSocket:
    ESteamNetworkingConfigScope = 3;
#[doc = " Options for a specific connection."]
pub const ESteamNetworkingConfigScope_k_ESteamNetworkingConfig_Connection:
    ESteamNetworkingConfigScope = 4;
#[doc = " Options for a specific connection."]
pub const ESteamNetworkingConfigScope_k_ESteamNetworkingConfigScope__Force32Bit:
    ESteamNetworkingConfigScope = 2147483647;
#[doc = " Configuration values can be applied to different types of objects."]
pub type ESteamNetworkingConfigScope = ::std::os::raw::c_int;
pub const ESteamNetworkingConfigDataType_k_ESteamNetworkingConfig_Int32:
    ESteamNetworkingConfigDataType = 1;
pub const ESteamNetworkingConfigDataType_k_ESteamNetworkingConfig_Int64:
    ESteamNetworkingConfigDataType = 2;
pub const ESteamNetworkingConfigDataType_k_ESteamNetworkingConfig_Float:
    ESteamNetworkingConfigDataType = 3;
pub const ESteamNetworkingConfigDataType_k_ESteamNetworkingConfig_String:
    ESteamNetworkingConfigDataType = 4;
pub const ESteamNetworkingConfigDataType_k_ESteamNetworkingConfig_Ptr:
    ESteamNetworkingConfigDataType = 5;
pub const ESteamNetworkingConfigDataType_k_ESteamNetworkingConfigDataType__Force32Bit:
    ESteamNetworkingConfigDataType = 2147483647;
pub type ESteamNetworkingConfigDataType = ::std::os::raw::c_int;
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_Invalid:
    ESteamNetworkingConfigValue = 0;
#[doc = " [connection int32] Timeout value (in ms) to use when first connecting"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_TimeoutInitial:
    ESteamNetworkingConfigValue = 24;
#[doc = " [connection int32] Timeout value (in ms) to use after connection is established"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_TimeoutConnected:
    ESteamNetworkingConfigValue = 25;
#[doc = " [connection int32] Upper limit of buffered pending bytes to be sent,\n if this is reached SendMessage will return k_EResultLimitExceeded\n Default is 512k (524288 bytes)"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_SendBufferSize:
    ESteamNetworkingConfigValue = 9;
#[doc = " [connection int32] Upper limit on total size (in bytes) of received messages\n that will be buffered waiting to be processed by the application.  If this limit\n is exceeded, packets will be dropped.  This is to protect us from a malicious\n peer flooding us with messages faster than we can process them.\n\n This must be bigger than k_ESteamNetworkingConfig_RecvMaxMessageSize"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_RecvBufferSize:
    ESteamNetworkingConfigValue = 47;
#[doc = " [connection int32] Upper limit on the number of received messages that will\n that will be buffered waiting to be processed by the application.  If this limit\n is exceeded, packets will be dropped.  This is to protect us from a malicious\n peer flooding us with messages faster than we can pull them off the wire."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_RecvBufferMessages:
    ESteamNetworkingConfigValue = 48;
#[doc = " [connection int32] Maximum message size that we are willing to receive.\n if a client attempts to send us a message larger than this, the connection\n will be immediately closed.\n\n Default is 512k (524288 bytes).  Note that the peer needs to be able to\n send a message this big.  (See k_cbMaxSteamNetworkingSocketsMessageSizeSend.)"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_RecvMaxMessageSize:
    ESteamNetworkingConfigValue = 49;
#[doc = " [connection int32] Max number of message segments that can be received\n in a single UDP packet.  While decoding a packet, if the number of segments\n exceeds this, we will abort further packet processing.\n\n The default is effectively unlimited.  If you know that you very rarely\n send small packets, you can protect yourself from malicious senders by\n lowering this number.\n\n In particular, if you are NOT using the reliability layer and are only using\n SteamNetworkingSockets for datagram transport, setting this to a very low\n number may be beneficial.  (We recommend a value of 2.)  Make sure your sender\n disables Nagle!"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_RecvMaxSegmentsPerPacket:
    ESteamNetworkingConfigValue = 50;
#[doc = " [connection int64] Get/set userdata as a configuration option.\n The default value is -1.   You may want to set the user data as\n a config value, instead of using ISteamNetworkingSockets::SetConnectionUserData\n in two specific instances:\n\n - You wish to set the userdata atomically when creating\n   an outbound connection, so that the userdata is filled in properly\n   for any callbacks that happen.  However, note that this trick\n   only works for connections initiated locally!  For incoming\n   connections, multiple state transitions may happen and\n   callbacks be queued, before you are able to service the first\n   callback!  Be careful!\n\n - You can set the default userdata for all newly created connections\n   by setting this value at a higher level (e.g. on the listen\n   socket or at the global level.)  Then this default\n   value will be inherited when the connection is created.\n   This is useful in case -1 is a valid userdata value, and you\n   wish to use something else as the default value so you can\n   tell if it has been set or not.\n\n   HOWEVER: once a connection is created, the effective value is\n   then bound to the connection.  Unlike other connection options,\n   if you change it again at a higher level, the new value will not\n   be inherited by connections.\n\n Using the userdata field in callback structs is not advised because\n of tricky race conditions.  Instead, you might try one of these methods:\n\n - Use a separate map with the HSteamNetConnection as the key.\n - Fetch the userdata from the connection in your callback\n   using ISteamNetworkingSockets::GetConnectionUserData, to"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_ConnectionUserData:
    ESteamNetworkingConfigValue = 40;
#[doc = " [connection int32] Minimum/maximum send rate clamp, in bytes/sec.\n At the time of this writing these two options should always be set to\n the same value, to manually configure a specific send rate.  The default\n value is 256K.  Eventually we hope to have the library estimate the bandwidth\n of the channel and set the send rate to that estimated bandwidth, and these\n values will only set limits on that send rate."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_SendRateMin:
    ESteamNetworkingConfigValue = 10;
#[doc = " [connection int32] Minimum/maximum send rate clamp, in bytes/sec.\n At the time of this writing these two options should always be set to\n the same value, to manually configure a specific send rate.  The default\n value is 256K.  Eventually we hope to have the library estimate the bandwidth\n of the channel and set the send rate to that estimated bandwidth, and these\n values will only set limits on that send rate."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_SendRateMax:
    ESteamNetworkingConfigValue = 11;
#[doc = " [connection int32] Nagle time, in microseconds.  When SendMessage is called, if\n the outgoing message is less than the size of the MTU, it will be\n queued for a delay equal to the Nagle timer value.  This is to ensure\n that if the application sends several small messages rapidly, they are\n coalesced into a single packet.\n See historical RFC 896.  Value is in microseconds.\n Default is 5000us (5ms)."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_NagleTime:
    ESteamNetworkingConfigValue = 12;
#[doc = " [connection int32] Don't automatically fail IP connections that don't have\n strong auth.  On clients, this means we will attempt the connection even if\n we don't know our identity or can't get a cert.  On the server, it means that\n we won't automatically reject a connection due to a failure to authenticate.\n (You can examine the incoming connection and decide whether to accept it.)\n\n This is a dev configuration value, and you should not let users modify it in\n production."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_IP_AllowWithoutAuth:
    ESteamNetworkingConfigValue = 23;
#[doc = " [connection int32] Do not send UDP packets with a payload of\n larger than N bytes.  If you set this, k_ESteamNetworkingConfig_MTU_DataSize\n is automatically adjusted"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_MTU_PacketSize:
    ESteamNetworkingConfigValue = 32;
#[doc = " [connection int32] (read only) Maximum message size you can send that\n will not fragment, based on k_ESteamNetworkingConfig_MTU_PacketSize"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_MTU_DataSize:
    ESteamNetworkingConfigValue = 33;
#[doc = " [connection int32] Allow unencrypted (and unauthenticated) communication.\n 0: Not allowed (the default)\n 1: Allowed, but prefer encrypted\n 2: Allowed, and preferred\n 3: Required.  (Fail the connection if the peer requires encryption.)\n\n This is a dev configuration value, since its purpose is to disable encryption.\n You should not let users modify it in production.  (But note that it requires\n the peer to also modify their value in order for encryption to be disabled.)"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_Unencrypted:
    ESteamNetworkingConfigValue = 34;
#[doc = " [connection int32] Set this to 1 on outbound connections and listen sockets,\n to enable \"symmetric connect mode\", which is useful in the following\n common peer-to-peer use case:\n\n - The two peers are \"equal\" to each other.  (Neither is clearly the \"client\"\n   or \"server\".)\n - Either peer may initiate the connection, and indeed they may do this\n   at the same time\n - The peers only desire a single connection to each other, and if both\n   peers initiate connections simultaneously, a protocol is needed for them\n   to resolve the conflict, so that we end up with a single connection.\n\n This use case is both common, and involves subtle race conditions and tricky\n pitfalls, which is why the API has support for dealing with it.\n\n If an incoming connection arrives on a listen socket or via custom signaling,\n and the application has not attempted to make a matching outbound connection\n in symmetric mode, then the incoming connection can be accepted as usual.\n A \"matching\" connection means that the relevant endpoint information matches.\n (At the time this comment is being written, this is only supported for P2P\n connections, which means that the peer identities must match, and the virtual\n port must match.  At a later time, symmetric mode may be supported for other\n connection types.)\n\n If connections are initiated by both peers simultaneously, race conditions\n can arise, but fortunately, most of them are handled internally and do not\n require any special awareness from the application.  However, there\n is one important case that application code must be aware of:\n If application code attempts an outbound connection using a ConnectXxx\n function in symmetric mode, and a matching incoming connection is already\n waiting on a listen socket, then instead of forming a new connection,\n the ConnectXxx call will accept the existing incoming connection, and return\n a connection handle to this accepted connection.\n IMPORTANT: in this case, a SteamNetConnectionStatusChangedCallback_t\n has probably *already* been posted to the queue for the incoming connection!\n (Once callbacks are posted to the queue, they are not modified.)  It doesn't\n matter if the callback has not been consumed by the app.  Thus, application\n code that makes use of symmetric connections must be aware that, when processing a\n SteamNetConnectionStatusChangedCallback_t for an incoming connection, the\n m_hConn may refer to a new connection that the app has has not\n seen before (the usual case), but it may also refer to a connection that\n has already been accepted implicitly through a call to Connect()!  In this\n case, AcceptConnection() will return k_EResultDuplicateRequest.\n\n Only one symmetric connection to a given peer (on a given virtual port)\n may exist at any given time.  If client code attempts to create a connection,\n and a (live) connection already exists on the local host, then either the\n existing connection will be accepted as described above, or the attempt\n to create a new connection will fail.  Furthermore, linger mode functionality\n is not supported on symmetric connections.\n\n A more complicated race condition can arise if both peers initiate a connection\n at roughly the same time.  In this situation, each peer will receive an incoming\n connection from the other peer, when the application code has already initiated\n an outgoing connection to that peer.  The peers must resolve this conflict and\n decide who is going to act as the \"server\" and who will act as the \"client\".\n Typically the application does not need to be aware of this case as it is handled\n internally.  On both sides, the will observe their outbound connection being\n \"accepted\", although one of them one have been converted internally to act\n as the \"server\".\n\n In general, symmetric mode should be all-or-nothing: do not mix symmetric\n connections with a non-symmetric connection that it might possible \"match\"\n with.  If you use symmetric mode on any connections, then both peers should\n use it on all connections, and the corresponding listen socket, if any.  The\n behaviour when symmetric and ordinary connections are mixed is not defined by\n this API, and you should not rely on it.  (This advice only applies when connections\n might possibly \"match\".  For example, it's OK to use all symmetric mode\n connections on one virtual port, and all ordinary, non-symmetric connections\n on a different virtual port, as there is no potential for ambiguity.)\n\n When using the feature, you should set it in the following situations on\n applicable objects:\n\n - When creating an outbound connection using ConnectXxx function\n - When creating a listen socket.  (Note that this will automatically cause\n   any accepted connections to inherit the flag.)\n - When using custom signaling, before accepting an incoming connection.\n\n Setting the flag on listen socket and accepted connections will enable the\n API to automatically deal with duplicate incoming connections, even if the\n local host has not made any outbound requests.  (In general, such duplicate\n requests from a peer are ignored internally and will not be visible to the\n application code.  The previous connection must be closed or resolved first.)"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_SymmetricConnect:
    ESteamNetworkingConfigValue = 37;
#[doc = " [connection int32] For connection types that use \"virtual ports\", this can be used\n to assign a local virtual port.  For incoming connections, this will always be the\n virtual port of the listen socket (or the port requested by the remote host if custom\n signaling is used and the connection is accepted), and cannot be changed.  For\n connections initiated locally, the local virtual port will default to the same as the\n requested remote virtual port, if you do not specify a different option when creating\n the connection.  The local port is only relevant for symmetric connections, when\n determining if two connections \"match.\"  In this case, if you need the local and remote\n port to differ, you can set this value.\n\n You can also read back this value on listen sockets.\n\n This value should not be read or written in any other context."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_LocalVirtualPort:
    ESteamNetworkingConfigValue = 38;
#[doc = " [connection int32] Enable Dual wifi band support for this connection\n 0 = no, 1 = yes, 2 = simulate it for debugging, even if dual wifi not available"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_DualWifi_Enable:
    ESteamNetworkingConfigValue = 39;
#[doc = " [connection int32] True to enable diagnostics reporting through\n generic platform UI.  (Only available on Steam.)"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_EnableDiagnosticsUI:
    ESteamNetworkingConfigValue = 46;
#[doc = " [global float, 0--100] Randomly discard N pct of packets instead of sending/recv\n This is a global option only, since it is applied at a low level\n where we don't have much context"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_FakePacketLoss_Send:
    ESteamNetworkingConfigValue = 2;
#[doc = " [global float, 0--100] Randomly discard N pct of packets instead of sending/recv\n This is a global option only, since it is applied at a low level\n where we don't have much context"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_FakePacketLoss_Recv:
    ESteamNetworkingConfigValue = 3;
#[doc = " [global int32].  Delay all outbound/inbound packets by N ms"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_FakePacketLag_Send:
    ESteamNetworkingConfigValue = 4;
#[doc = " [global int32].  Delay all outbound/inbound packets by N ms"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_FakePacketLag_Recv:
    ESteamNetworkingConfigValue = 5;
#[doc = " [global float] 0-100 Percentage of packets we will add additional delay\n to (causing them to be reordered)"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_FakePacketReorder_Send:
    ESteamNetworkingConfigValue = 6;
#[doc = " [global float] 0-100 Percentage of packets we will add additional delay\n to (causing them to be reordered)"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_FakePacketReorder_Recv:
    ESteamNetworkingConfigValue = 7;
#[doc = " [global int32] Extra delay, in ms, to apply to reordered packets."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_FakePacketReorder_Time:
    ESteamNetworkingConfigValue = 8;
#[doc = " [global float 0--100] Globally duplicate some percentage of packets we send"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_FakePacketDup_Send:
    ESteamNetworkingConfigValue = 26;
#[doc = " [global float 0--100] Globally duplicate some percentage of packets we send"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_FakePacketDup_Recv:
    ESteamNetworkingConfigValue = 27;
#[doc = " [global int32] Amount of delay, in ms, to delay duplicated packets.\n (We chose a random delay between 0 and this value)"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_FakePacketDup_TimeMax:
    ESteamNetworkingConfigValue = 28;
#[doc = " [global int32] Trace every UDP packet, similar to Wireshark or tcpdump.\n Value is max number of bytes to dump.  -1 disables tracing."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_PacketTraceMaxBytes:
    ESteamNetworkingConfigValue = 41;
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_FakeRateLimit_Send_Rate:
    ESteamNetworkingConfigValue = 42;
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_FakeRateLimit_Send_Burst:
    ESteamNetworkingConfigValue = 43;
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_FakeRateLimit_Recv_Rate:
    ESteamNetworkingConfigValue = 44;
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_FakeRateLimit_Recv_Burst:
    ESteamNetworkingConfigValue = 45;
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_OutOfOrderCorrectionWindowMicroseconds : ESteamNetworkingConfigValue = 51 ;
#[doc = " [connection FnSteamNetConnectionStatusChanged] Callback that will be invoked\n when the state of a connection changes.\n\n IMPORTANT: callbacks are dispatched to the handler that is in effect at the time\n the event occurs, which might be in another thread.  For example, immediately after\n creating a listen socket, you may receive an incoming connection.  And then immediately\n after this, the remote host may close the connection.  All of this could happen\n before the function to create the listen socket has returned.  For this reason,\n callbacks usually must be in effect at the time of object creation.  This means\n you should set them when you are creating the listen socket or connection, or have\n them in effect so they will be inherited at the time of object creation.\n\n For example:\n\n exterm void MyStatusChangedFunc( SteamNetConnectionStatusChangedCallback_t *info );\n SteamNetworkingConfigValue_t opt; opt.SetPtr( k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged, MyStatusChangedFunc );\n SteamNetworkingIPAddr localAddress; localAddress.Clear();\n HSteamListenSocket hListenSock = SteamNetworkingSockets()->CreateListenSocketIP( localAddress, 1, &opt );\n\n When accepting an incoming connection, there is no atomic way to switch the\n callback.  However, if the connection is DOA, AcceptConnection() will fail, and\n you can fetch the state of the connection at that time.\n\n If all connections and listen sockets can use the same callback, the simplest\n method is to set it globally before you create any listen sockets or connections."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged:
    ESteamNetworkingConfigValue = 201;
#[doc = " [global FnSteamNetAuthenticationStatusChanged] Callback that will be invoked\n when our auth state changes.  If you use this, install the callback before creating\n any connections or listen sockets, and don't change it.\n See: ISteamNetworkingUtils::SetGlobalCallback_SteamNetAuthenticationStatusChanged"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_Callback_AuthStatusChanged:
    ESteamNetworkingConfigValue = 202;
#[doc = " [global FnSteamRelayNetworkStatusChanged] Callback that will be invoked\n when our auth state changes.  If you use this, install the callback before creating\n any connections or listen sockets, and don't change it.\n See: ISteamNetworkingUtils::SetGlobalCallback_SteamRelayNetworkStatusChanged"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_Callback_RelayNetworkStatusChanged : ESteamNetworkingConfigValue = 203 ;
#[doc = " [global FnSteamNetworkingMessagesSessionRequest] Callback that will be invoked\n when a peer wants to initiate a SteamNetworkingMessagesSessionRequest.\n See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionRequest"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_Callback_MessagesSessionRequest:
    ESteamNetworkingConfigValue = 204;
#[doc = " [global FnSteamNetworkingMessagesSessionFailed] Callback that will be invoked\n when a session you have initiated, or accepted either fails to connect, or loses\n connection in some unexpected way.\n See: ISteamNetworkingUtils::SetGlobalCallback_MessagesSessionFailed"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_Callback_MessagesSessionFailed:
    ESteamNetworkingConfigValue = 205;
#[doc = " [global FnSteamNetworkingSocketsCreateConnectionSignaling] Callback that will\n be invoked when we need to create a signaling object for a connection\n initiated locally.  See: ISteamNetworkingSockets::ConnectP2P,\n ISteamNetworkingMessages."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling : ESteamNetworkingConfigValue = 206 ;
#[doc = " [global FnSteamNetworkingFakeIPResult] Callback that's invoked when\n a FakeIP allocation finishes.  See: ISteamNetworkingSockets::BeginAsyncRequestFakeIP,\n ISteamNetworkingUtils::SetGlobalCallback_FakeIPResult"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_Callback_FakeIPResult:
    ESteamNetworkingConfigValue = 207;
#[doc = " [connection string] Comma-separated list of STUN servers that can be used\n for NAT piercing.  If you set this to an empty string, NAT piercing will\n not be attempted.  Also if \"public\" candidates are not allowed for\n P2P_Transport_ICE_Enable, then this is ignored."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_P2P_STUN_ServerList:
    ESteamNetworkingConfigValue = 103;
#[doc = " [connection int32] What types of ICE candidates to share with the peer.\n See k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_xxx values"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_P2P_Transport_ICE_Enable:
    ESteamNetworkingConfigValue = 104;
#[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_P2P_Transport_ICE_Penalty:
    ESteamNetworkingConfigValue = 105;
#[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_P2P_Transport_SDR_Penalty:
    ESteamNetworkingConfigValue = 106;
#[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_P2P_TURN_ServerList:
    ESteamNetworkingConfigValue = 107;
#[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_P2P_TURN_UserList:
    ESteamNetworkingConfigValue = 108;
#[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_P2P_TURN_PassList:
    ESteamNetworkingConfigValue = 109;
#[doc = " [connection int32] When selecting P2P transport, add various\n penalties to the scores for selected transports.  (Route selection\n scores are on a scale of milliseconds.  The score begins with the\n route ping time and is then adjusted.)"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_P2P_Transport_ICE_Implementation:
    ESteamNetworkingConfigValue = 110;
#[doc = " [global int32] If the first N pings to a port all fail, mark that port as unavailable for\n a while, and try a different one.  Some ISPs and routers may drop the first\n packet, so setting this to 1 may greatly disrupt communications."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFailInitial : ESteamNetworkingConfigValue = 19 ;
#[doc = " [global int32] If N consecutive pings to a port fail, after having received successful\n communication, mark that port as unavailable for a while, and try a\n different one."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_SDRClient_ConsecutitivePingTimeoutsFail : ESteamNetworkingConfigValue = 20 ;
#[doc = " [global int32] Minimum number of lifetime pings we need to send, before we think our estimate\n is solid.  The first ping to each cluster is very often delayed because of NAT,\n routers not having the best route, etc.  Until we've sent a sufficient number\n of pings, our estimate is often inaccurate.  Keep pinging until we get this\n many pings."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_SDRClient_MinPingsBeforePingAccurate : ESteamNetworkingConfigValue = 21 ;
#[doc = " [global int32] Set all steam datagram traffic to originate from the same\n local port. By default, we open up a new UDP socket (on a different local\n port) for each relay.  This is slightly less optimal, but it works around\n some routers that don't implement NAT properly.  If you have intermittent\n problems talking to relays that might be NAT related, try toggling\n this flag"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_SDRClient_SingleSocket:
    ESteamNetworkingConfigValue = 22;
#[doc = " [global string] Code of relay cluster to force use.  If not empty, we will\n only use relays in that cluster.  E.g. 'iad'"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_SDRClient_ForceRelayCluster:
    ESteamNetworkingConfigValue = 29;
#[doc = " [connection string] For development, a base-64 encoded ticket generated\n using the cert tool.  This can be used to connect to a gameserver via SDR\n without a ticket generated using the game coordinator.  (You will still\n need a key that is trusted for your app, however.)\n\n This can also be passed using the SDR_DEVTICKET environment variable"]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_SDRClient_DevTicket:
    ESteamNetworkingConfigValue = 30;
#[doc = " [global string] For debugging.  Override list of relays from the config with\n this set (maybe just one).  Comma-separated list."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_SDRClient_ForceProxyAddr:
    ESteamNetworkingConfigValue = 31;
#[doc = " [global string] For debugging.  Force ping times to clusters to be the specified\n values.  A comma separated list of <cluster>=<ms> values.  E.g. \"sto=32,iad=100\"\n\n This is a dev configuration value, you probably should not let users modify it\n in production."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_SDRClient_FakeClusterPing:
    ESteamNetworkingConfigValue = 36;
#[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_SDRClient_LimitPingProbesToNearestN : ESteamNetworkingConfigValue = 60 ;
#[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_LogLevel_AckRTT:
    ESteamNetworkingConfigValue = 13;
#[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_LogLevel_PacketDecode:
    ESteamNetworkingConfigValue = 14;
#[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_LogLevel_Message:
    ESteamNetworkingConfigValue = 15;
#[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_LogLevel_PacketGaps:
    ESteamNetworkingConfigValue = 16;
#[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_LogLevel_P2PRendezvous:
    ESteamNetworkingConfigValue = 17;
#[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_LogLevel_SDRRelayPings:
    ESteamNetworkingConfigValue = 18;
#[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_ECN: ESteamNetworkingConfigValue =
    999;
#[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfig_DELETED_EnumerateDevVars:
    ESteamNetworkingConfigValue = 35;
#[doc = " [global int32] When probing the SteamDatagram network, we limit exploration\n to the closest N POPs, based on our current best approximated ping to that POP."]
pub const ESteamNetworkingConfigValue_k_ESteamNetworkingConfigValue__Force32Bit:
    ESteamNetworkingConfigValue = 2147483647;
#[doc = " Configuration options"]
pub type ESteamNetworkingConfigValue = ::std::os::raw::c_int;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Default: ::std::os::raw::c_int = -1;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Disable: ::std::os::raw::c_int = 0;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Relay: ::std::os::raw::c_int = 1;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Private: ::std::os::raw::c_int = 2;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Public: ::std::os::raw::c_int = 4;
pub const k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_All: ::std::os::raw::c_int = 2147483647;
#[doc = " In a few places we need to set configuration options on listen sockets and connections, and\n have them take effect *before* the listen socket or connection really starts doing anything.\n Creating the object and then setting the options \"immediately\" after creation doesn't work\n completely, because network packets could be received between the time the object is created and\n when the options are applied.  To set options at creation time in a reliable way, they must be\n passed to the creation function.  This structure is used to pass those options.\n\n For the meaning of these fields, see ISteamNetworkingUtils::SetConfigValue.  Basically\n when the object is created, we just iterate over the list of options and call\n ISteamNetworkingUtils::SetConfigValueStruct, where the scope arguments are supplied by the\n object being created."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingConfigValue_t {
    #[doc = " Which option is being set"]
    pub m_eValue: ESteamNetworkingConfigValue,
    #[doc = " Which field below did you fill in?"]
    pub m_eDataType: ESteamNetworkingConfigDataType,
    pub m_val: SteamNetworkingConfigValue_t__bindgen_ty_1,
}
#[doc = " Option value"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SteamNetworkingConfigValue_t__bindgen_ty_1 {
    pub m_int32: i32,
    pub m_int64: i64,
    pub m_float: f32,
    pub m_string: *const ::std::os::raw::c_char,
    pub m_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SteamNetworkingConfigValue_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingConfigValue_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingConfigValue_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingConfigValue_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_int32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
            "::",
            stringify!(m_int32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_int64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
            "::",
            stringify!(m_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
            "::",
            stringify!(m_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
            "::",
            stringify!(m_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t__bindgen_ty_1),
            "::",
            stringify!(m_ptr)
        )
    );
}
#[test]
fn bindgen_test_layout_SteamNetworkingConfigValue_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingConfigValue_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingConfigValue_t>(),
        16usize,
        concat!("Size of: ", stringify!(SteamNetworkingConfigValue_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingConfigValue_t>(),
        8usize,
        concat!("Alignment of ", stringify!(SteamNetworkingConfigValue_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t),
            "::",
            stringify!(m_eValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eDataType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t),
            "::",
            stringify!(m_eDataType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_val) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingConfigValue_t),
            "::",
            stringify!(m_val)
        )
    );
}
pub const ESteamNetworkingGetConfigValueResult_k_ESteamNetworkingGetConfigValue_BadValue:
    ESteamNetworkingGetConfigValueResult = -1;
pub const ESteamNetworkingGetConfigValueResult_k_ESteamNetworkingGetConfigValue_BadScopeObj:
    ESteamNetworkingGetConfigValueResult = -2;
pub const ESteamNetworkingGetConfigValueResult_k_ESteamNetworkingGetConfigValue_BufferTooSmall:
    ESteamNetworkingGetConfigValueResult = -3;
pub const ESteamNetworkingGetConfigValueResult_k_ESteamNetworkingGetConfigValue_OK:
    ESteamNetworkingGetConfigValueResult = 1;
pub const ESteamNetworkingGetConfigValueResult_k_ESteamNetworkingGetConfigValue_OKInherited:
    ESteamNetworkingGetConfigValueResult = 2;
pub const ESteamNetworkingGetConfigValueResult_k_ESteamNetworkingGetConfigValueResult__Force32Bit : ESteamNetworkingGetConfigValueResult = 2147483647 ;
#[doc = " Return value of ISteamNetworkintgUtils::GetConfigValue"]
pub type ESteamNetworkingGetConfigValueResult = ::std::os::raw::c_int;
pub const ESteamNetworkingSocketsDebugOutputType_k_ESteamNetworkingSocketsDebugOutputType_None:
    ESteamNetworkingSocketsDebugOutputType = 0;
pub const ESteamNetworkingSocketsDebugOutputType_k_ESteamNetworkingSocketsDebugOutputType_Bug:
    ESteamNetworkingSocketsDebugOutputType = 1;
pub const ESteamNetworkingSocketsDebugOutputType_k_ESteamNetworkingSocketsDebugOutputType_Error:
    ESteamNetworkingSocketsDebugOutputType = 2;
pub const ESteamNetworkingSocketsDebugOutputType_k_ESteamNetworkingSocketsDebugOutputType_Important : ESteamNetworkingSocketsDebugOutputType = 3 ;
pub const ESteamNetworkingSocketsDebugOutputType_k_ESteamNetworkingSocketsDebugOutputType_Warning : ESteamNetworkingSocketsDebugOutputType = 4 ;
pub const ESteamNetworkingSocketsDebugOutputType_k_ESteamNetworkingSocketsDebugOutputType_Msg:
    ESteamNetworkingSocketsDebugOutputType = 5;
pub const ESteamNetworkingSocketsDebugOutputType_k_ESteamNetworkingSocketsDebugOutputType_Verbose : ESteamNetworkingSocketsDebugOutputType = 6 ;
pub const ESteamNetworkingSocketsDebugOutputType_k_ESteamNetworkingSocketsDebugOutputType_Debug:
    ESteamNetworkingSocketsDebugOutputType = 7;
pub const ESteamNetworkingSocketsDebugOutputType_k_ESteamNetworkingSocketsDebugOutputType_Everything : ESteamNetworkingSocketsDebugOutputType = 8 ;
pub const ESteamNetworkingSocketsDebugOutputType_k_ESteamNetworkingSocketsDebugOutputType__Force32Bit : ESteamNetworkingSocketsDebugOutputType = 2147483647 ;
#[doc = " Detail level for diagnostic output callback.\n See ISteamNetworkingUtils::SetDebugOutputFunction"]
pub type ESteamNetworkingSocketsDebugOutputType = ::std::os::raw::c_int;
#[doc = " Setup callback for debug output, and the desired verbosity you want."]
pub type FSteamNetworkingSocketsDebugOutput = ::std::option::Option<
    unsafe extern "C" fn(
        nType: ESteamNetworkingSocketsDebugOutputType,
        pszMsg: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " The POPID \"dev\" is used in non-production environments for testing."]
pub const k_SteamDatagramPOPID_dev: SteamNetworkingPOPID = 6579574;
#[doc = " Utility class for printing a SteamNetworkingPOPID."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingPOPIDRender {
    pub buf: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingPOPIDRender() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingPOPIDRender> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingPOPIDRender>(),
        8usize,
        concat!("Size of: ", stringify!(SteamNetworkingPOPIDRender))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingPOPIDRender>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingPOPIDRender))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingPOPIDRender),
            "::",
            stringify!(buf)
        )
    );
}
#[doc = " A message that has been received."]
pub type ISteamNetworkingMessage = SteamNetworkingMessage_t;
pub type SteamDatagramErrMsg = SteamNetworkingErrMsg;
#[repr(C)]
pub struct ISteamNetworkingMessages__bindgen_vtable(::std::os::raw::c_void);
#[doc = " The non-connection-oriented interface to send and receive messages\n (whether they be \"clients\" or \"servers\").\n\n ISteamNetworkingSockets is connection-oriented (like TCP), meaning you\n need to listen and connect, and then you send messages using a connection\n handle.  ISteamNetworkingMessages is more like UDP, in that you can just send\n messages to arbitrary peers at any time.  The underlying connections are\n established implicitly.\n\n Under the hood ISteamNetworkingMessages works on top of the ISteamNetworkingSockets\n code, so you get the same routing and messaging efficiency.  The difference is\n mainly in your responsibility to explicitly establish a connection and\n the type of feedback you get about the state of the connection.  Both\n interfaces can do \"P2P\" communications, and both support both unreliable\n and reliable messages, fragmentation and reassembly.\n\n The primary purpose of this interface is to be \"like UDP\", so that UDP-based code\n can be ported easily to take advantage of relayed connections.  If you find\n yourself needing more low level information or control, or to be able to better\n handle failure, then you probably need to use ISteamNetworkingSockets directly.\n Also, note that if your main goal is to obtain a connection between two peers\n without concerning yourself with assigning roles of \"client\" and \"server\",\n you may find the symmetric connection mode of ISteamNetworkingSockets useful.\n (See k_ESteamNetworkingConfig_SymmetricConnect.)\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworkingMessages {
    pub vtable_: *const ISteamNetworkingMessages__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamNetworkingMessages() {
    assert_eq!(
        ::std::mem::size_of::<ISteamNetworkingMessages>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamNetworkingMessages))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamNetworkingMessages>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamNetworkingMessages))
    );
}
#[doc = " Posted when a remote host is sending us a message, and we do not already have a session with them"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingMessagesSessionRequest_t {
    pub m_identityRemote: SteamNetworkingIdentity,
}
pub const SteamNetworkingMessagesSessionRequest_t_k_iCallback:
    SteamNetworkingMessagesSessionRequest_t__bindgen_ty_1 = 1251;
pub type SteamNetworkingMessagesSessionRequest_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamNetworkingMessagesSessionRequest_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingMessagesSessionRequest_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingMessagesSessionRequest_t>(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingMessagesSessionRequest_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingMessagesSessionRequest_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingMessagesSessionRequest_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_identityRemote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessagesSessionRequest_t),
            "::",
            stringify!(m_identityRemote)
        )
    );
}
#[doc = " Posted when we fail to establish a connection, or we detect that communications\n have been disrupted it an unusual way.  There is no notification when a peer proactively\n closes the session.  (\"Closed by peer\" is not a concept of UDP-style communications, and\n SteamNetworkingMessages is primarily intended to make porting UDP code easy.)\n\n Remember: callbacks are asynchronous.   See notes on SendMessageToUser,\n and k_nSteamNetworkingSend_AutoRestartBrokenSession in particular.\n\n Also, if a session times out due to inactivity, no callbacks will be posted.  The only\n way to detect that this is happening is that querying the session state may return\n none, connecting, and findingroute again."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SteamNetworkingMessagesSessionFailed_t {
    #[doc = " Detailed info about the session that failed.\n SteamNetConnectionInfo_t::m_identityRemote indicates who this session\n was with."]
    pub m_info: SteamNetConnectionInfo_t,
}
pub const SteamNetworkingMessagesSessionFailed_t_k_iCallback:
    SteamNetworkingMessagesSessionFailed_t__bindgen_ty_1 = 1252;
pub type SteamNetworkingMessagesSessionFailed_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamNetworkingMessagesSessionFailed_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingMessagesSessionFailed_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingMessagesSessionFailed_t>(),
        696usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetworkingMessagesSessionFailed_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingMessagesSessionFailed_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetworkingMessagesSessionFailed_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingMessagesSessionFailed_t),
            "::",
            stringify!(m_info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworkingConnectionSignaling {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworkingSignalingRecvContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamNetworkingFakeUDPPort {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ISteamNetworkingSockets__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Lower level networking API.\n\n - Connection-oriented API (like TCP, not UDP).  When sending and receiving\n   messages, a connection handle is used.  (For a UDP-style interface, where\n   the peer is identified by their address with each send/recv call, see\n   ISteamNetworkingMessages.)  The typical pattern is for a \"server\" to \"listen\"\n   on a \"listen socket.\"  A \"client\" will \"connect\" to the server, and the\n   server will \"accept\" the connection.  If you have a symmetric situation\n   where either peer may initiate the connection and server/client roles are\n   not clearly defined, check out k_ESteamNetworkingConfig_SymmetricConnect.\n - But unlike TCP, it's message-oriented, not stream-oriented.\n - Mix of reliable and unreliable messages\n - Fragmentation and reassembly\n - Supports connectivity over plain UDP\n - Also supports SDR (\"Steam Datagram Relay\") connections, which are\n   addressed by the identity of the peer.  There is a \"P2P\" use case and\n   a \"hosted dedicated server\" use case.\n\n Note that neither of the terms \"connection\" nor \"socket\" necessarily correspond\n one-to-one with an underlying UDP socket.  An attempt has been made to\n keep the semantics as similar to the standard socket model when appropriate,\n but some deviations do exist.\n\n See also: ISteamNetworkingMessages, the UDP-style interface.  This API might be\n easier to use, especially when porting existing UDP code."]
#[repr(C)]
#[derive(Debug)]
pub struct ISteamNetworkingSockets {
    pub vtable_: *const ISteamNetworkingSockets__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamNetworkingSockets() {
    assert_eq!(
        ::std::mem::size_of::<ISteamNetworkingSockets>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamNetworkingSockets))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamNetworkingSockets>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamNetworkingSockets))
    );
}
extern "C" {
    #[link_name = "\u{1}??1ISteamNetworkingSockets@@IEAA@XZ"]
    pub fn ISteamNetworkingSockets_ISteamNetworkingSockets_destructor(
        this: *mut ISteamNetworkingSockets,
    );
}
impl ISteamNetworkingSockets {
    #[inline]
    pub unsafe fn destruct(&mut self) {
        ISteamNetworkingSockets_ISteamNetworkingSockets_destructor(self)
    }
}
#[doc = " This callback is posted whenever a connection is created, destroyed, or changes state.\n The m_info field will contain a complete description of the connection at the time the\n change occurred and the callback was posted.  In particular, m_eState will have the\n new connection state.\n\n You will usually need to listen for this callback to know when:\n - A new connection arrives on a listen socket.\n   m_info.m_hListenSocket will be set, m_eOldState = k_ESteamNetworkingConnectionState_None,\n   and m_info.m_eState = k_ESteamNetworkingConnectionState_Connecting.\n   See ISteamNetworkigSockets::AcceptConnection.\n - A connection you initiated has been accepted by the remote host.\n   m_eOldState = k_ESteamNetworkingConnectionState_Connecting, and\n   m_info.m_eState = k_ESteamNetworkingConnectionState_Connected.\n   Some connections might transition to k_ESteamNetworkingConnectionState_FindingRoute first.\n - A connection has been actively rejected or closed by the remote host.\n   m_eOldState = k_ESteamNetworkingConnectionState_Connecting or k_ESteamNetworkingConnectionState_Connected,\n   and m_info.m_eState = k_ESteamNetworkingConnectionState_ClosedByPeer.  m_info.m_eEndReason\n   and m_info.m_szEndDebug will have for more details.\n   NOTE: upon receiving this callback, you must still destroy the connection using\n   ISteamNetworkingSockets::CloseConnection to free up local resources.  (The details\n   passed to the function are not used in this case, since the connection is already closed.)\n - A problem was detected with the connection, and it has been closed by the local host.\n   The most common failure is timeout, but other configuration or authentication failures\n   can cause this.  m_eOldState = k_ESteamNetworkingConnectionState_Connecting or\n   k_ESteamNetworkingConnectionState_Connected, and m_info.m_eState = k_ESteamNetworkingConnectionState_ProblemDetectedLocally.\n   m_info.m_eEndReason and m_info.m_szEndDebug will have for more details.\n   NOTE: upon receiving this callback, you must still destroy the connection using\n   ISteamNetworkingSockets::CloseConnection to free up local resources.  (The details\n   passed to the function are not used in this case, since the connection is already closed.)\n\n Remember that callbacks are posted to a queue, and networking connections can\n change at any time.  It is possible that the connection has already changed\n state by the time you process this callback.\n\n Also note that callbacks will be posted when connections are created and destroyed by your own API calls."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SteamNetConnectionStatusChangedCallback_t {
    #[doc = " Connection handle"]
    pub m_hConn: HSteamNetConnection,
    #[doc = " Full connection info"]
    pub m_info: SteamNetConnectionInfo_t,
    #[doc = " Previous state.  (Current state is in m_info.m_eState)"]
    pub m_eOldState: ESteamNetworkingConnectionState,
}
pub const SteamNetConnectionStatusChangedCallback_t_k_iCallback:
    SteamNetConnectionStatusChangedCallback_t__bindgen_ty_1 = 1221;
pub type SteamNetConnectionStatusChangedCallback_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamNetConnectionStatusChangedCallback_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetConnectionStatusChangedCallback_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetConnectionStatusChangedCallback_t>(),
        712usize,
        concat!(
            "Size of: ",
            stringify!(SteamNetConnectionStatusChangedCallback_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetConnectionStatusChangedCallback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SteamNetConnectionStatusChangedCallback_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hConn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionStatusChangedCallback_t),
            "::",
            stringify!(m_hConn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionStatusChangedCallback_t),
            "::",
            stringify!(m_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eOldState) as usize - ptr as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetConnectionStatusChangedCallback_t),
            "::",
            stringify!(m_eOldState)
        )
    );
}
#[doc = " A struct used to describe our readiness to participate in authenticated,\n encrypted communication.  In order to do this we need:\n\n - The list of trusted CA certificates that might be relevant for this\n   app.\n - A valid certificate issued by a CA.\n\n This callback is posted whenever the state of our readiness changes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetAuthenticationStatus_t {
    #[doc = " Status"]
    pub m_eAvail: ESteamNetworkingAvailability,
    #[doc = " Non-localized English language status.  For diagnostic/debugging\n purposes only."]
    pub m_debugMsg: [::std::os::raw::c_char; 256usize],
}
pub const SteamNetAuthenticationStatus_t_k_iCallback: SteamNetAuthenticationStatus_t__bindgen_ty_1 =
    1222;
pub type SteamNetAuthenticationStatus_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamNetAuthenticationStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetAuthenticationStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetAuthenticationStatus_t>(),
        260usize,
        concat!("Size of: ", stringify!(SteamNetAuthenticationStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetAuthenticationStatus_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamNetAuthenticationStatus_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAvail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetAuthenticationStatus_t),
            "::",
            stringify!(m_eAvail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_debugMsg) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetAuthenticationStatus_t),
            "::",
            stringify!(m_debugMsg)
        )
    );
}
#[repr(C)]
pub struct ISteamNetworkingUtils__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Misc networking utilities for checking the local networking environment\n and estimating pings."]
#[repr(C)]
#[derive(Debug)]
pub struct ISteamNetworkingUtils {
    pub vtable_: *const ISteamNetworkingUtils__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamNetworkingUtils() {
    assert_eq!(
        ::std::mem::size_of::<ISteamNetworkingUtils>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamNetworkingUtils))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamNetworkingUtils>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamNetworkingUtils))
    );
}
extern "C" {
    #[link_name = "\u{1}??1ISteamNetworkingUtils@@IEAA@XZ"]
    pub fn ISteamNetworkingUtils_ISteamNetworkingUtils_destructor(this: *mut ISteamNetworkingUtils);
}
impl ISteamNetworkingUtils {
    #[inline]
    pub unsafe fn destruct(&mut self) {
        ISteamNetworkingUtils_ISteamNetworkingUtils_destructor(self)
    }
}
#[doc = " A struct used to describe our readiness to use the relay network.\n To do this we first need to fetch the network configuration,\n which describes what POPs are available."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamRelayNetworkStatus_t {
    #[doc = " Summary status.  When this is \"current\", initialization has\n completed.  Anything else means you are not ready yet, or\n there is a significant problem."]
    pub m_eAvail: ESteamNetworkingAvailability,
    #[doc = " Nonzero if latency measurement is in progress (or pending,\n awaiting a prerequisite)."]
    pub m_bPingMeasurementInProgress: ::std::os::raw::c_int,
    #[doc = " Status obtaining the network config.  This is a prerequisite\n for relay network access.\n\n Failure to obtain the network config almost always indicates\n a problem with the local internet connection."]
    pub m_eAvailNetworkConfig: ESteamNetworkingAvailability,
    #[doc = " Current ability to communicate with ANY relay.  Note that\n the complete failure to communicate with any relays almost\n always indicates a problem with the local Internet connection.\n (However, just because you can reach a single relay doesn't\n mean that the local connection is in perfect health.)"]
    pub m_eAvailAnyRelay: ESteamNetworkingAvailability,
    #[doc = " Non-localized English language status.  For diagnostic/debugging\n purposes only."]
    pub m_debugMsg: [::std::os::raw::c_char; 256usize],
}
pub const SteamRelayNetworkStatus_t_k_iCallback: SteamRelayNetworkStatus_t__bindgen_ty_1 = 1281;
pub type SteamRelayNetworkStatus_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_SteamRelayNetworkStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<SteamRelayNetworkStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamRelayNetworkStatus_t>(),
        272usize,
        concat!("Size of: ", stringify!(SteamRelayNetworkStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamRelayNetworkStatus_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SteamRelayNetworkStatus_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAvail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRelayNetworkStatus_t),
            "::",
            stringify!(m_eAvail)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_bPingMeasurementInProgress) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRelayNetworkStatus_t),
            "::",
            stringify!(m_bPingMeasurementInProgress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAvailNetworkConfig) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRelayNetworkStatus_t),
            "::",
            stringify!(m_eAvailNetworkConfig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eAvailAnyRelay) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRelayNetworkStatus_t),
            "::",
            stringify!(m_eAvailAnyRelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_debugMsg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamRelayNetworkStatus_t),
            "::",
            stringify!(m_debugMsg)
        )
    );
}
#[doc = " Utility class for printing a SteamNetworkingIdentity.\n E.g. printf( \"Identity is '%s'\\n\", SteamNetworkingIdentityRender( identity ).c_str() );"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingIdentityRender {
    pub buf: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingIdentityRender() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIdentityRender> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIdentityRender>(),
        128usize,
        concat!("Size of: ", stringify!(SteamNetworkingIdentityRender))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIdentityRender>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingIdentityRender))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIdentityRender),
            "::",
            stringify!(buf)
        )
    );
}
#[doc = " Utility class for printing a SteamNetworkingIPAddrRender."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SteamNetworkingIPAddrRender {
    pub buf: [::std::os::raw::c_char; 48usize],
}
#[test]
fn bindgen_test_layout_SteamNetworkingIPAddrRender() {
    const UNINIT: ::std::mem::MaybeUninit<SteamNetworkingIPAddrRender> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SteamNetworkingIPAddrRender>(),
        48usize,
        concat!("Size of: ", stringify!(SteamNetworkingIPAddrRender))
    );
    assert_eq!(
        ::std::mem::align_of::<SteamNetworkingIPAddrRender>(),
        1usize,
        concat!("Alignment of ", stringify!(SteamNetworkingIPAddrRender))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SteamNetworkingIPAddrRender),
            "::",
            stringify!(buf)
        )
    );
}
pub const ESteamAPIInitResult_k_ESteamAPIInitResult_OK: ESteamAPIInitResult = 0;
pub const ESteamAPIInitResult_k_ESteamAPIInitResult_FailedGeneric: ESteamAPIInitResult = 1;
pub const ESteamAPIInitResult_k_ESteamAPIInitResult_NoSteamClient: ESteamAPIInitResult = 2;
pub const ESteamAPIInitResult_k_ESteamAPIInitResult_VersionMismatch: ESteamAPIInitResult = 3;
pub type ESteamAPIInitResult = ::std::os::raw::c_int;
extern "C" {
    pub fn SteamAPI_InitFlat(pOutErrMsg: *mut SteamErrMsg) -> ESteamAPIInitResult;
}
extern "C" {
    pub fn SteamAPI_Shutdown();
}
extern "C" {
    pub fn SteamAPI_RestartAppIfNecessary(unOwnAppID: uint32) -> bool;
}
extern "C" {
    pub fn SteamAPI_ReleaseCurrentThreadMemory();
}
extern "C" {
    pub fn SteamAPI_WriteMiniDump(
        uStructuredExceptionCode: uint32,
        pvExceptionInfo: *mut ::std::os::raw::c_void,
        uBuildID: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_SetMiniDumpComment(pchMsg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SteamAPI_IsSteamRunning() -> bool;
}
extern "C" {
    pub fn SteamAPI_GetSteamInstallPath() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_SetTryCatchCallbacks(bTryCatchCallbacks: bool);
}
extern "C" {
    #[doc = " Inform the API that you wish to use manual event dispatch.  This must be called after SteamAPI_Init, but before\n you use any of the other manual dispatch functions below."]
    pub fn SteamAPI_ManualDispatch_Init();
}
extern "C" {
    #[doc = " Perform certain periodic actions that need to be performed."]
    pub fn SteamAPI_ManualDispatch_RunFrame(hSteamPipe: HSteamPipe);
}
extern "C" {
    #[doc = " Fetch the next pending callback on the given pipe, if any.  If a callback is available, true is returned\n and the structure is populated.  In this case, you MUST call SteamAPI_ManualDispatch_FreeLastCallback\n (after dispatching the callback) before calling SteamAPI_ManualDispatch_GetNextCallback again."]
    pub fn SteamAPI_ManualDispatch_GetNextCallback(
        hSteamPipe: HSteamPipe,
        pCallbackMsg: *mut CallbackMsg_t,
    ) -> bool;
}
extern "C" {
    #[doc = " You must call this after dispatching the callback, if SteamAPI_ManualDispatch_GetNextCallback returns true."]
    pub fn SteamAPI_ManualDispatch_FreeLastCallback(hSteamPipe: HSteamPipe);
}
extern "C" {
    #[doc = " Return the call result for the specified call on the specified pipe.  You really should\n only call this in a handler for SteamAPICallCompleted_t callback."]
    pub fn SteamAPI_ManualDispatch_GetAPICallResult(
        hSteamPipe: HSteamPipe,
        hSteamAPICall: SteamAPICall_t,
        pCallback: *mut ::std::os::raw::c_void,
        cubCallback: ::std::os::raw::c_int,
        iCallbackExpected: ::std::os::raw::c_int,
        pbFailed: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamInternal_SteamAPI_Init(
        pszInternalCheckInterfaceVersions: *const ::std::os::raw::c_char,
        pOutErrMsg: *mut SteamErrMsg,
    ) -> ESteamAPIInitResult;
}
#[repr(C)]
pub struct ISteamGameServer__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamGameServer {
    pub vtable_: *const ISteamGameServer__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamGameServer() {
    assert_eq!(
        ::std::mem::size_of::<ISteamGameServer>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamGameServer))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamGameServer>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamGameServer))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GSClientApprove_t {
    pub m_SteamID: CSteamID,
    pub m_OwnerSteamID: CSteamID,
}
pub const GSClientApprove_t_k_iCallback: GSClientApprove_t__bindgen_ty_1 = 201;
pub type GSClientApprove_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GSClientApprove_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSClientApprove_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSClientApprove_t>(),
        16usize,
        concat!("Size of: ", stringify!(GSClientApprove_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSClientApprove_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GSClientApprove_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientApprove_t),
            "::",
            stringify!(m_SteamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_OwnerSteamID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientApprove_t),
            "::",
            stringify!(m_OwnerSteamID)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GSClientDeny_t {
    pub m_SteamID: CSteamID,
    pub m_eDenyReason: EDenyReason,
    pub m_rgchOptionalText: [::std::os::raw::c_char; 128usize],
}
pub const GSClientDeny_t_k_iCallback: GSClientDeny_t__bindgen_ty_1 = 202;
pub type GSClientDeny_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GSClientDeny_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSClientDeny_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSClientDeny_t>(),
        140usize,
        concat!("Size of: ", stringify!(GSClientDeny_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSClientDeny_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GSClientDeny_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientDeny_t),
            "::",
            stringify!(m_SteamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eDenyReason) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientDeny_t),
            "::",
            stringify!(m_eDenyReason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rgchOptionalText) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientDeny_t),
            "::",
            stringify!(m_rgchOptionalText)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GSClientKick_t {
    pub m_SteamID: CSteamID,
    pub m_eDenyReason: EDenyReason,
}
pub const GSClientKick_t_k_iCallback: GSClientKick_t__bindgen_ty_1 = 203;
pub type GSClientKick_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GSClientKick_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSClientKick_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSClientKick_t>(),
        12usize,
        concat!("Size of: ", stringify!(GSClientKick_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSClientKick_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GSClientKick_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientKick_t),
            "::",
            stringify!(m_SteamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eDenyReason) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientKick_t),
            "::",
            stringify!(m_eDenyReason)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSClientAchievementStatus_t {
    pub m_SteamID: uint64,
    pub m_pchAchievement: [::std::os::raw::c_char; 128usize],
    pub m_bUnlocked: bool,
}
pub const GSClientAchievementStatus_t_k_iCallback: GSClientAchievementStatus_t__bindgen_ty_1 = 206;
pub type GSClientAchievementStatus_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GSClientAchievementStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSClientAchievementStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSClientAchievementStatus_t>(),
        144usize,
        concat!("Size of: ", stringify!(GSClientAchievementStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSClientAchievementStatus_t>(),
        8usize,
        concat!("Alignment of ", stringify!(GSClientAchievementStatus_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientAchievementStatus_t),
            "::",
            stringify!(m_SteamID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pchAchievement) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientAchievementStatus_t),
            "::",
            stringify!(m_pchAchievement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUnlocked) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientAchievementStatus_t),
            "::",
            stringify!(m_bUnlocked)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSPolicyResponse_t {
    pub m_bSecure: uint8,
}
pub const GSPolicyResponse_t_k_iCallback: GSPolicyResponse_t__bindgen_ty_1 = 115;
pub type GSPolicyResponse_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GSPolicyResponse_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSPolicyResponse_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSPolicyResponse_t>(),
        1usize,
        concat!("Size of: ", stringify!(GSPolicyResponse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSPolicyResponse_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GSPolicyResponse_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSecure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSPolicyResponse_t),
            "::",
            stringify!(m_bSecure)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSGameplayStats_t {
    pub m_eResult: EResult,
    pub m_nRank: int32,
    pub m_unTotalConnects: uint32,
    pub m_unTotalMinutesPlayed: uint32,
}
pub const GSGameplayStats_t_k_iCallback: GSGameplayStats_t__bindgen_ty_1 = 207;
pub type GSGameplayStats_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GSGameplayStats_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSGameplayStats_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSGameplayStats_t>(),
        16usize,
        concat!("Size of: ", stringify!(GSGameplayStats_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSGameplayStats_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GSGameplayStats_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSGameplayStats_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nRank) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GSGameplayStats_t),
            "::",
            stringify!(m_nRank)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unTotalConnects) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GSGameplayStats_t),
            "::",
            stringify!(m_unTotalConnects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unTotalMinutesPlayed) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GSGameplayStats_t),
            "::",
            stringify!(m_unTotalMinutesPlayed)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GSClientGroupStatus_t {
    pub m_SteamIDUser: CSteamID,
    pub m_SteamIDGroup: CSteamID,
    pub m_bMember: bool,
    pub m_bOfficer: bool,
}
pub const GSClientGroupStatus_t_k_iCallback: GSClientGroupStatus_t__bindgen_ty_1 = 208;
pub type GSClientGroupStatus_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GSClientGroupStatus_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSClientGroupStatus_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSClientGroupStatus_t>(),
        18usize,
        concat!("Size of: ", stringify!(GSClientGroupStatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSClientGroupStatus_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GSClientGroupStatus_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamIDUser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientGroupStatus_t),
            "::",
            stringify!(m_SteamIDUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamIDGroup) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientGroupStatus_t),
            "::",
            stringify!(m_SteamIDGroup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bMember) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientGroupStatus_t),
            "::",
            stringify!(m_bMember)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bOfficer) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(GSClientGroupStatus_t),
            "::",
            stringify!(m_bOfficer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSReputation_t {
    pub m_eResult: EResult,
    pub m_unReputationScore: uint32,
    pub m_bBanned: bool,
    pub m_unBannedIP: uint32,
    pub m_usBannedPort: uint16,
    pub m_ulBannedGameID: uint64,
    pub m_unBanExpires: uint32,
}
pub const GSReputation_t_k_iCallback: GSReputation_t__bindgen_ty_1 = 209;
pub type GSReputation_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GSReputation_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSReputation_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSReputation_t>(),
        40usize,
        concat!("Size of: ", stringify!(GSReputation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSReputation_t>(),
        8usize,
        concat!("Alignment of ", stringify!(GSReputation_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSReputation_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unReputationScore) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GSReputation_t),
            "::",
            stringify!(m_unReputationScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bBanned) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GSReputation_t),
            "::",
            stringify!(m_bBanned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unBannedIP) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GSReputation_t),
            "::",
            stringify!(m_unBannedIP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usBannedPort) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GSReputation_t),
            "::",
            stringify!(m_usBannedPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ulBannedGameID) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GSReputation_t),
            "::",
            stringify!(m_ulBannedGameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unBanExpires) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GSReputation_t),
            "::",
            stringify!(m_unBanExpires)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AssociateWithClanResult_t {
    pub m_eResult: EResult,
}
pub const AssociateWithClanResult_t_k_iCallback: AssociateWithClanResult_t__bindgen_ty_1 = 210;
pub type AssociateWithClanResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_AssociateWithClanResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<AssociateWithClanResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AssociateWithClanResult_t>(),
        4usize,
        concat!("Size of: ", stringify!(AssociateWithClanResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<AssociateWithClanResult_t>(),
        4usize,
        concat!("Alignment of ", stringify!(AssociateWithClanResult_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AssociateWithClanResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ComputeNewPlayerCompatibilityResult_t {
    pub m_eResult: EResult,
    pub m_cPlayersThatDontLikeCandidate: ::std::os::raw::c_int,
    pub m_cPlayersThatCandidateDoesntLike: ::std::os::raw::c_int,
    pub m_cClanPlayersThatDontLikeCandidate: ::std::os::raw::c_int,
    pub m_SteamIDCandidate: CSteamID,
}
pub const ComputeNewPlayerCompatibilityResult_t_k_iCallback:
    ComputeNewPlayerCompatibilityResult_t__bindgen_ty_1 = 211;
pub type ComputeNewPlayerCompatibilityResult_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_ComputeNewPlayerCompatibilityResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<ComputeNewPlayerCompatibilityResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ComputeNewPlayerCompatibilityResult_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(ComputeNewPlayerCompatibilityResult_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ComputeNewPlayerCompatibilityResult_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ComputeNewPlayerCompatibilityResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ComputeNewPlayerCompatibilityResult_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_cPlayersThatDontLikeCandidate) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ComputeNewPlayerCompatibilityResult_t),
            "::",
            stringify!(m_cPlayersThatDontLikeCandidate)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_cPlayersThatCandidateDoesntLike) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ComputeNewPlayerCompatibilityResult_t),
            "::",
            stringify!(m_cPlayersThatCandidateDoesntLike)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_cClanPlayersThatDontLikeCandidate) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ComputeNewPlayerCompatibilityResult_t),
            "::",
            stringify!(m_cClanPlayersThatDontLikeCandidate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_SteamIDCandidate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ComputeNewPlayerCompatibilityResult_t),
            "::",
            stringify!(m_SteamIDCandidate)
        )
    );
}
#[repr(C)]
pub struct ISteamGameServerStats__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISteamGameServerStats {
    pub vtable_: *const ISteamGameServerStats__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISteamGameServerStats() {
    assert_eq!(
        ::std::mem::size_of::<ISteamGameServerStats>(),
        8usize,
        concat!("Size of: ", stringify!(ISteamGameServerStats))
    );
    assert_eq!(
        ::std::mem::align_of::<ISteamGameServerStats>(),
        8usize,
        concat!("Alignment of ", stringify!(ISteamGameServerStats))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GSStatsReceived_t {
    pub m_eResult: EResult,
    pub m_steamIDUser: CSteamID,
}
pub const GSStatsReceived_t_k_iCallback: GSStatsReceived_t__bindgen_ty_1 = 1800;
pub type GSStatsReceived_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GSStatsReceived_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSStatsReceived_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSStatsReceived_t>(),
        12usize,
        concat!("Size of: ", stringify!(GSStatsReceived_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSStatsReceived_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GSStatsReceived_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSStatsReceived_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GSStatsReceived_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GSStatsStored_t {
    pub m_eResult: EResult,
    pub m_steamIDUser: CSteamID,
}
pub const GSStatsStored_t_k_iCallback: GSStatsStored_t__bindgen_ty_1 = 1801;
pub type GSStatsStored_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GSStatsStored_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSStatsStored_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSStatsStored_t>(),
        12usize,
        concat!("Size of: ", stringify!(GSStatsStored_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSStatsStored_t>(),
        4usize,
        concat!("Alignment of ", stringify!(GSStatsStored_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResult) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSStatsStored_t),
            "::",
            stringify!(m_eResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GSStatsStored_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GSStatsUnloaded_t {
    pub m_steamIDUser: CSteamID,
}
pub const GSStatsUnloaded_t_k_iCallback: GSStatsUnloaded_t__bindgen_ty_1 = 1108;
pub type GSStatsUnloaded_t__bindgen_ty_1 = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_GSStatsUnloaded_t() {
    const UNINIT: ::std::mem::MaybeUninit<GSStatsUnloaded_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSStatsUnloaded_t>(),
        8usize,
        concat!("Size of: ", stringify!(GSStatsUnloaded_t))
    );
    assert_eq!(
        ::std::mem::align_of::<GSStatsUnloaded_t>(),
        1usize,
        concat!("Alignment of ", stringify!(GSStatsUnloaded_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_steamIDUser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSStatsUnloaded_t),
            "::",
            stringify!(m_steamIDUser)
        )
    );
}
pub type uint64_steamid = uint64;
pub type uint64_gameid = uint64;
extern "C" {
    pub fn SteamAPI_ISteamClient_CreateSteamPipe(self_: *mut ISteamClient) -> HSteamPipe;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_BReleaseSteamPipe(
        self_: *mut ISteamClient,
        hSteamPipe: HSteamPipe,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_ConnectToGlobalUser(
        self_: *mut ISteamClient,
        hSteamPipe: HSteamPipe,
    ) -> HSteamUser;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_CreateLocalUser(
        self_: *mut ISteamClient,
        phSteamPipe: *mut HSteamPipe,
        eAccountType: EAccountType,
    ) -> HSteamUser;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_ReleaseUser(
        self_: *mut ISteamClient,
        hSteamPipe: HSteamPipe,
        hUser: HSteamUser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamUser(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamUser;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamGameServer(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamGameServer;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_SetLocalIPBinding(
        self_: *mut ISteamClient,
        unIP: *const SteamIPAddress_t,
        usPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamFriends(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamFriends;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamUtils(
        self_: *mut ISteamClient,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamUtils;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamMatchmaking(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamMatchmaking;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamMatchmakingServers(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamMatchmakingServers;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamGenericInterface(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamUserStats(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamUserStats;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamGameServerStats(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamGameServerStats;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamApps(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamApps;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamNetworking(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamNetworking;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamRemoteStorage(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamRemoteStorage;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamScreenshots(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamScreenshots;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamGameSearch(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamGameSearch;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetIPCCallCount(self_: *mut ISteamClient) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_SetWarningMessageHook(
        self_: *mut ISteamClient,
        pFunction: SteamAPIWarningMessageHook_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamClient_BShutdownIfAllPipesClosed(self_: *mut ISteamClient) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamHTTP(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamHTTP;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamController(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamController;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamUGC(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamUGC;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamMusic(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamMusic;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamMusicRemote(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamMusicRemote;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamHTMLSurface(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamHTMLSurface;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamInventory(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamInventory;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamVideo(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamVideo;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamParentalSettings(
        self_: *mut ISteamClient,
        hSteamuser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamParentalSettings;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamInput(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamInput;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamParties(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamParties;
}
extern "C" {
    pub fn SteamAPI_ISteamClient_GetISteamRemotePlay(
        self_: *mut ISteamClient,
        hSteamUser: HSteamUser,
        hSteamPipe: HSteamPipe,
        pchVersion: *const ::std::os::raw::c_char,
    ) -> *mut ISteamRemotePlay;
}
extern "C" {
    pub fn SteamAPI_SteamUser_v023() -> *mut ISteamUser;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetHSteamUser(self_: *mut ISteamUser) -> HSteamUser;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BLoggedOn(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetSteamID(self_: *mut ISteamUser) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_InitiateGameConnection_DEPRECATED(
        self_: *mut ISteamUser,
        pAuthBlob: *mut ::std::os::raw::c_void,
        cbMaxAuthBlob: ::std::os::raw::c_int,
        steamIDGameServer: uint64_steamid,
        unIPServer: uint32,
        usPortServer: uint16,
        bSecure: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_TerminateGameConnection_DEPRECATED(
        self_: *mut ISteamUser,
        unIPServer: uint32,
        usPortServer: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUser_TrackAppUsageEvent(
        self_: *mut ISteamUser,
        gameID: uint64_gameid,
        eAppUsageEvent: ::std::os::raw::c_int,
        pchExtraInfo: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetUserDataFolder(
        self_: *mut ISteamUser,
        pchBuffer: *mut ::std::os::raw::c_char,
        cubBuffer: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_StartVoiceRecording(self_: *mut ISteamUser);
}
extern "C" {
    pub fn SteamAPI_ISteamUser_StopVoiceRecording(self_: *mut ISteamUser);
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetAvailableVoice(
        self_: *mut ISteamUser,
        pcbCompressed: *mut uint32,
        pcbUncompressed_Deprecated: *mut uint32,
        nUncompressedVoiceDesiredSampleRate_Deprecated: uint32,
    ) -> EVoiceResult;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetVoice(
        self_: *mut ISteamUser,
        bWantCompressed: bool,
        pDestBuffer: *mut ::std::os::raw::c_void,
        cbDestBufferSize: uint32,
        nBytesWritten: *mut uint32,
        bWantUncompressed_Deprecated: bool,
        pUncompressedDestBuffer_Deprecated: *mut ::std::os::raw::c_void,
        cbUncompressedDestBufferSize_Deprecated: uint32,
        nUncompressBytesWritten_Deprecated: *mut uint32,
        nUncompressedVoiceDesiredSampleRate_Deprecated: uint32,
    ) -> EVoiceResult;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_DecompressVoice(
        self_: *mut ISteamUser,
        pCompressed: *const ::std::os::raw::c_void,
        cbCompressed: uint32,
        pDestBuffer: *mut ::std::os::raw::c_void,
        cbDestBufferSize: uint32,
        nBytesWritten: *mut uint32,
        nDesiredSampleRate: uint32,
    ) -> EVoiceResult;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetVoiceOptimalSampleRate(self_: *mut ISteamUser) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetAuthSessionTicket(
        self_: *mut ISteamUser,
        pTicket: *mut ::std::os::raw::c_void,
        cbMaxTicket: ::std::os::raw::c_int,
        pcbTicket: *mut uint32,
        pSteamNetworkingIdentity: *const SteamNetworkingIdentity,
    ) -> HAuthTicket;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetAuthTicketForWebApi(
        self_: *mut ISteamUser,
        pchIdentity: *const ::std::os::raw::c_char,
    ) -> HAuthTicket;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BeginAuthSession(
        self_: *mut ISteamUser,
        pAuthTicket: *const ::std::os::raw::c_void,
        cbAuthTicket: ::std::os::raw::c_int,
        steamID: uint64_steamid,
    ) -> EBeginAuthSessionResult;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_EndAuthSession(self_: *mut ISteamUser, steamID: uint64_steamid);
}
extern "C" {
    pub fn SteamAPI_ISteamUser_CancelAuthTicket(self_: *mut ISteamUser, hAuthTicket: HAuthTicket);
}
extern "C" {
    pub fn SteamAPI_ISteamUser_UserHasLicenseForApp(
        self_: *mut ISteamUser,
        steamID: uint64_steamid,
        appID: AppId_t,
    ) -> EUserHasLicenseForAppResult;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BIsBehindNAT(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_AdvertiseGame(
        self_: *mut ISteamUser,
        steamIDGameServer: uint64_steamid,
        unIPServer: uint32,
        usPortServer: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUser_RequestEncryptedAppTicket(
        self_: *mut ISteamUser,
        pDataToInclude: *mut ::std::os::raw::c_void,
        cbDataToInclude: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetEncryptedAppTicket(
        self_: *mut ISteamUser,
        pTicket: *mut ::std::os::raw::c_void,
        cbMaxTicket: ::std::os::raw::c_int,
        pcbTicket: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetGameBadgeLevel(
        self_: *mut ISteamUser,
        nSeries: ::std::os::raw::c_int,
        bFoil: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetPlayerSteamLevel(self_: *mut ISteamUser)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_RequestStoreAuthURL(
        self_: *mut ISteamUser,
        pchRedirectURL: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BIsPhoneVerified(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BIsTwoFactorEnabled(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BIsPhoneIdentifying(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BIsPhoneRequiringVerification(self_: *mut ISteamUser) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetMarketEligibility(self_: *mut ISteamUser) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_GetDurationControl(self_: *mut ISteamUser) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUser_BSetDurationControlOnlineState(
        self_: *mut ISteamUser,
        eNewState: EDurationControlOnlineState,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamFriends_v017() -> *mut ISteamFriends;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetPersonaName(
        self_: *mut ISteamFriends,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_SetPersonaName(
        self_: *mut ISteamFriends,
        pchPersonaName: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetPersonaState(self_: *mut ISteamFriends) -> EPersonaState;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendCount(
        self_: *mut ISteamFriends,
        iFriendFlags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendByIndex(
        self_: *mut ISteamFriends,
        iFriend: ::std::os::raw::c_int,
        iFriendFlags: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendRelationship(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> EFriendRelationship;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendPersonaState(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> EPersonaState;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendPersonaName(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendGamePlayed(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        pFriendGameInfo: *mut FriendGameInfo_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendPersonaNameHistory(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        iPersonaName: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendSteamLevel(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetPlayerNickname(
        self_: *mut ISteamFriends,
        steamIDPlayer: uint64_steamid,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendsGroupCount(
        self_: *mut ISteamFriends,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendsGroupIDByIndex(
        self_: *mut ISteamFriends,
        iFG: ::std::os::raw::c_int,
    ) -> FriendsGroupID_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendsGroupName(
        self_: *mut ISteamFriends,
        friendsGroupID: FriendsGroupID_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendsGroupMembersCount(
        self_: *mut ISteamFriends,
        friendsGroupID: FriendsGroupID_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendsGroupMembersList(
        self_: *mut ISteamFriends,
        friendsGroupID: FriendsGroupID_t,
        pOutSteamIDMembers: *mut CSteamID,
        nMembersCount: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_HasFriend(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        iFriendFlags: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanCount(self_: *mut ISteamFriends) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanByIndex(
        self_: *mut ISteamFriends,
        iClan: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanName(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanTag(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanActivityCounts(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
        pnOnline: *mut ::std::os::raw::c_int,
        pnInGame: *mut ::std::os::raw::c_int,
        pnChatting: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_DownloadClanActivityCounts(
        self_: *mut ISteamFriends,
        psteamIDClans: *mut CSteamID,
        cClansToRequest: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendCountFromSource(
        self_: *mut ISteamFriends,
        steamIDSource: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendFromSourceByIndex(
        self_: *mut ISteamFriends,
        steamIDSource: uint64_steamid,
        iFriend: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsUserInSource(
        self_: *mut ISteamFriends,
        steamIDUser: uint64_steamid,
        steamIDSource: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_SetInGameVoiceSpeaking(
        self_: *mut ISteamFriends,
        steamIDUser: uint64_steamid,
        bSpeaking: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlay(
        self_: *mut ISteamFriends,
        pchDialog: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayToUser(
        self_: *mut ISteamFriends,
        pchDialog: *const ::std::os::raw::c_char,
        steamID: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayToWebPage(
        self_: *mut ISteamFriends,
        pchURL: *const ::std::os::raw::c_char,
        eMode: EActivateGameOverlayToWebPageMode,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayToStore(
        self_: *mut ISteamFriends,
        nAppID: AppId_t,
        eFlag: EOverlayToStoreFlag,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_SetPlayedWith(
        self_: *mut ISteamFriends,
        steamIDUserPlayedWith: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialog(
        self_: *mut ISteamFriends,
        steamIDLobby: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetSmallFriendAvatar(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetMediumFriendAvatar(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetLargeFriendAvatar(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_RequestUserInformation(
        self_: *mut ISteamFriends,
        steamIDUser: uint64_steamid,
        bRequireNameOnly: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_RequestClanOfficerList(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanOwner(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanOfficerCount(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanOfficerByIndex(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
        iOfficer: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetUserRestrictions(self_: *mut ISteamFriends) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_SetRichPresence(
        self_: *mut ISteamFriends,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ClearRichPresence(self_: *mut ISteamFriends);
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendRichPresence(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendRichPresenceKeyCount(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendRichPresenceKeyByIndex(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        iKey: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_RequestFriendRichPresence(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_InviteUserToGame(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        pchConnectString: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetCoplayFriendCount(
        self_: *mut ISteamFriends,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetCoplayFriend(
        self_: *mut ISteamFriends,
        iCoplayFriend: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendCoplayTime(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendCoplayGame(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
    ) -> AppId_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_JoinClanChatRoom(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_LeaveClanChatRoom(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanChatMemberCount(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetChatMemberByIndex(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
        iUser: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_SendClanChatMessage(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
        pchText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetClanChatMessage(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
        iMessage: ::std::os::raw::c_int,
        prgchText: *mut ::std::os::raw::c_void,
        cchTextMax: ::std::os::raw::c_int,
        peChatEntryType: *mut EChatEntryType,
        psteamidChatter: *mut CSteamID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsClanChatAdmin(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
        steamIDUser: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsClanChatWindowOpenInSteam(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_OpenClanChatWindowInSteam(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_CloseClanChatWindowInSteam(
        self_: *mut ISteamFriends,
        steamIDClanChat: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_SetListenForFriendsMessages(
        self_: *mut ISteamFriends,
        bInterceptEnabled: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ReplyToFriendMessage(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        pchMsgToSend: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFriendMessage(
        self_: *mut ISteamFriends,
        steamIDFriend: uint64_steamid,
        iMessageID: ::std::os::raw::c_int,
        pvData: *mut ::std::os::raw::c_void,
        cubData: ::std::os::raw::c_int,
        peChatEntryType: *mut EChatEntryType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetFollowerCount(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsFollowing(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_EnumerateFollowingList(
        self_: *mut ISteamFriends,
        unStartIndex: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsClanPublic(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_IsClanOfficialGameGroup(
        self_: *mut ISteamFriends,
        steamIDClan: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetNumChatsWithUnreadPriorityMessages(
        self_: *mut ISteamFriends,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayRemotePlayTogetherInviteDialog(
        self_: *mut ISteamFriends,
        steamIDLobby: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_RegisterProtocolInOverlayBrowser(
        self_: *mut ISteamFriends,
        pchProtocol: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialogConnectString(
        self_: *mut ISteamFriends,
        pchConnectString: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_RequestEquippedProfileItems(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_BHasEquippedProfileItem(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
        itemType: ECommunityProfileItemType,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetProfileItemPropertyString(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
        itemType: ECommunityProfileItemType,
        prop: ECommunityProfileItemProperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamFriends_GetProfileItemPropertyUint(
        self_: *mut ISteamFriends,
        steamID: uint64_steamid,
        itemType: ECommunityProfileItemType,
        prop: ECommunityProfileItemProperty,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_SteamUtils_v010() -> *mut ISteamUtils;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerUtils_v010() -> *mut ISteamUtils;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetSecondsSinceAppActive(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetSecondsSinceComputerActive(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetConnectedUniverse(self_: *mut ISteamUtils) -> EUniverse;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetServerRealTime(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetIPCountry(
        self_: *mut ISteamUtils,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetImageSize(
        self_: *mut ISteamUtils,
        iImage: ::std::os::raw::c_int,
        pnWidth: *mut uint32,
        pnHeight: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetImageRGBA(
        self_: *mut ISteamUtils,
        iImage: ::std::os::raw::c_int,
        pubDest: *mut uint8,
        nDestBufferSize: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetCurrentBatteryPower(self_: *mut ISteamUtils) -> uint8;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetAppID(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_SetOverlayNotificationPosition(
        self_: *mut ISteamUtils,
        eNotificationPosition: ENotificationPosition,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsAPICallCompleted(
        self_: *mut ISteamUtils,
        hSteamAPICall: SteamAPICall_t,
        pbFailed: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetAPICallFailureReason(
        self_: *mut ISteamUtils,
        hSteamAPICall: SteamAPICall_t,
    ) -> ESteamAPICallFailure;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetAPICallResult(
        self_: *mut ISteamUtils,
        hSteamAPICall: SteamAPICall_t,
        pCallback: *mut ::std::os::raw::c_void,
        cubCallback: ::std::os::raw::c_int,
        iCallbackExpected: ::std::os::raw::c_int,
        pbFailed: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetIPCCallCount(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_SetWarningMessageHook(
        self_: *mut ISteamUtils,
        pFunction: SteamAPIWarningMessageHook_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsOverlayEnabled(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_BOverlayNeedsPresent(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_CheckFileSignature(
        self_: *mut ISteamUtils,
        szFileName: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_ShowGamepadTextInput(
        self_: *mut ISteamUtils,
        eInputMode: EGamepadTextInputMode,
        eLineInputMode: EGamepadTextInputLineMode,
        pchDescription: *const ::std::os::raw::c_char,
        unCharMax: uint32,
        pchExistingText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetEnteredGamepadTextLength(self_: *mut ISteamUtils) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetEnteredGamepadTextInput(
        self_: *mut ISteamUtils,
        pchText: *mut ::std::os::raw::c_char,
        cchText: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetSteamUILanguage(
        self_: *mut ISteamUtils,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsSteamRunningInVR(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_SetOverlayNotificationInset(
        self_: *mut ISteamUtils,
        nHorizontalInset: ::std::os::raw::c_int,
        nVerticalInset: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsSteamInBigPictureMode(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_StartVRDashboard(self_: *mut ISteamUtils);
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsVRHeadsetStreamingEnabled(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_SetVRHeadsetStreamingEnabled(
        self_: *mut ISteamUtils,
        bEnabled: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsSteamChinaLauncher(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_InitFilterText(
        self_: *mut ISteamUtils,
        unFilterOptions: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_FilterText(
        self_: *mut ISteamUtils,
        eContext: ETextFilteringContext,
        sourceSteamID: uint64_steamid,
        pchInputMessage: *const ::std::os::raw::c_char,
        pchOutFilteredText: *mut ::std::os::raw::c_char,
        nByteSizeOutFilteredText: uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_GetIPv6ConnectivityState(
        self_: *mut ISteamUtils,
        eProtocol: ESteamIPv6ConnectivityProtocol,
    ) -> ESteamIPv6ConnectivityState;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_IsSteamRunningOnSteamDeck(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_ShowFloatingGamepadTextInput(
        self_: *mut ISteamUtils,
        eKeyboardMode: EFloatingGamepadTextInputMode,
        nTextFieldXPosition: ::std::os::raw::c_int,
        nTextFieldYPosition: ::std::os::raw::c_int,
        nTextFieldWidth: ::std::os::raw::c_int,
        nTextFieldHeight: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_SetGameLauncherMode(self_: *mut ISteamUtils, bLauncherMode: bool);
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_DismissFloatingGamepadTextInput(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUtils_DismissGamepadTextInput(self_: *mut ISteamUtils) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamMatchmaking_v009() -> *mut ISteamMatchmaking;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetFavoriteGameCount(
        self_: *mut ISteamMatchmaking,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetFavoriteGame(
        self_: *mut ISteamMatchmaking,
        iGame: ::std::os::raw::c_int,
        pnAppID: *mut AppId_t,
        pnIP: *mut uint32,
        pnConnPort: *mut uint16,
        pnQueryPort: *mut uint16,
        punFlags: *mut uint32,
        pRTime32LastPlayedOnServer: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddFavoriteGame(
        self_: *mut ISteamMatchmaking,
        nAppID: AppId_t,
        nIP: uint32,
        nConnPort: uint16,
        nQueryPort: uint16,
        unFlags: uint32,
        rTime32LastPlayedOnServer: uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_RemoveFavoriteGame(
        self_: *mut ISteamMatchmaking,
        nAppID: AppId_t,
        nIP: uint32,
        nConnPort: uint16,
        nQueryPort: uint16,
        unFlags: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_RequestLobbyList(
        self_: *mut ISteamMatchmaking,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListStringFilter(
        self_: *mut ISteamMatchmaking,
        pchKeyToMatch: *const ::std::os::raw::c_char,
        pchValueToMatch: *const ::std::os::raw::c_char,
        eComparisonType: ELobbyComparison,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListNumericalFilter(
        self_: *mut ISteamMatchmaking,
        pchKeyToMatch: *const ::std::os::raw::c_char,
        nValueToMatch: ::std::os::raw::c_int,
        eComparisonType: ELobbyComparison,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListNearValueFilter(
        self_: *mut ISteamMatchmaking,
        pchKeyToMatch: *const ::std::os::raw::c_char,
        nValueToBeCloseTo: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListFilterSlotsAvailable(
        self_: *mut ISteamMatchmaking,
        nSlotsAvailable: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListDistanceFilter(
        self_: *mut ISteamMatchmaking,
        eLobbyDistanceFilter: ELobbyDistanceFilter,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListResultCountFilter(
        self_: *mut ISteamMatchmaking,
        cMaxResults: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_AddRequestLobbyListCompatibleMembersFilter(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyByIndex(
        self_: *mut ISteamMatchmaking,
        iLobby: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_CreateLobby(
        self_: *mut ISteamMatchmaking,
        eLobbyType: ELobbyType,
        cMaxMembers: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_JoinLobby(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_LeaveLobby(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_InviteUserToLobby(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        steamIDInvitee: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetNumLobbyMembers(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyMemberByIndex(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        iMember: ::std::os::raw::c_int,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyDataCount(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyDataByIndex(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        iLobbyData: ::std::os::raw::c_int,
        pchKey: *mut ::std::os::raw::c_char,
        cchKeyBufferSize: ::std::os::raw::c_int,
        pchValue: *mut ::std::os::raw::c_char,
        cchValueBufferSize: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_DeleteLobbyData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyMemberData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        steamIDUser: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyMemberData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SendLobbyChatMsg(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        pvMsgBody: *const ::std::os::raw::c_void,
        cubMsgBody: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyChatEntry(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        iChatID: ::std::os::raw::c_int,
        pSteamIDUser: *mut CSteamID,
        pvData: *mut ::std::os::raw::c_void,
        cubData: ::std::os::raw::c_int,
        peChatEntryType: *mut EChatEntryType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_RequestLobbyData(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyGameServer(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        unGameServerIP: uint32,
        unGameServerPort: uint16,
        steamIDGameServer: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyGameServer(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        punGameServerIP: *mut uint32,
        punGameServerPort: *mut uint16,
        psteamIDGameServer: *mut CSteamID,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyMemberLimit(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        cMaxMembers: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyMemberLimit(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyType(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        eLobbyType: ELobbyType,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyJoinable(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        bLobbyJoinable: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_GetLobbyOwner(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLobbyOwner(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        steamIDNewOwner: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmaking_SetLinkedLobby(
        self_: *mut ISteamMatchmaking,
        steamIDLobby: uint64_steamid,
        steamIDLobbyDependent: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServerListResponse_ServerResponded(
        self_: *mut ISteamMatchmakingServerListResponse,
        hRequest: HServerListRequest,
        iServer: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServerListResponse_ServerFailedToRespond(
        self_: *mut ISteamMatchmakingServerListResponse,
        hRequest: HServerListRequest,
        iServer: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServerListResponse_RefreshComplete(
        self_: *mut ISteamMatchmakingServerListResponse,
        hRequest: HServerListRequest,
        response: EMatchMakingServerResponse,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingPingResponse_ServerResponded(
        self_: *mut ISteamMatchmakingPingResponse,
        server: *mut gameserveritem_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingPingResponse_ServerFailedToRespond(
        self_: *mut ISteamMatchmakingPingResponse,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingPlayersResponse_AddPlayerToList(
        self_: *mut ISteamMatchmakingPlayersResponse,
        pchName: *const ::std::os::raw::c_char,
        nScore: ::std::os::raw::c_int,
        flTimePlayed: f32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingPlayersResponse_PlayersFailedToRespond(
        self_: *mut ISteamMatchmakingPlayersResponse,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingPlayersResponse_PlayersRefreshComplete(
        self_: *mut ISteamMatchmakingPlayersResponse,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingRulesResponse_RulesResponded(
        self_: *mut ISteamMatchmakingRulesResponse,
        pchRule: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingRulesResponse_RulesFailedToRespond(
        self_: *mut ISteamMatchmakingRulesResponse,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingRulesResponse_RulesRefreshComplete(
        self_: *mut ISteamMatchmakingRulesResponse,
    );
}
extern "C" {
    pub fn SteamAPI_SteamMatchmakingServers_v002() -> *mut ISteamMatchmakingServers;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestInternetServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        ppchFilters: *mut *mut MatchMakingKeyValuePair_t,
        nFilters: uint32,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestLANServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestFriendsServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        ppchFilters: *mut *mut MatchMakingKeyValuePair_t,
        nFilters: uint32,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestFavoritesServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        ppchFilters: *mut *mut MatchMakingKeyValuePair_t,
        nFilters: uint32,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestHistoryServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        ppchFilters: *mut *mut MatchMakingKeyValuePair_t,
        nFilters: uint32,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RequestSpectatorServerList(
        self_: *mut ISteamMatchmakingServers,
        iApp: AppId_t,
        ppchFilters: *mut *mut MatchMakingKeyValuePair_t,
        nFilters: uint32,
        pRequestServersResponse: *mut ISteamMatchmakingServerListResponse,
    ) -> HServerListRequest;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_ReleaseRequest(
        self_: *mut ISteamMatchmakingServers,
        hServerListRequest: HServerListRequest,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_GetServerDetails(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
        iServer: ::std::os::raw::c_int,
    ) -> *mut gameserveritem_t;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_CancelQuery(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RefreshQuery(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_IsRefreshing(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_GetServerCount(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_RefreshServer(
        self_: *mut ISteamMatchmakingServers,
        hRequest: HServerListRequest,
        iServer: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_PingServer(
        self_: *mut ISteamMatchmakingServers,
        unIP: uint32,
        usPort: uint16,
        pRequestServersResponse: *mut ISteamMatchmakingPingResponse,
    ) -> HServerQuery;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_PlayerDetails(
        self_: *mut ISteamMatchmakingServers,
        unIP: uint32,
        usPort: uint16,
        pRequestServersResponse: *mut ISteamMatchmakingPlayersResponse,
    ) -> HServerQuery;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_ServerRules(
        self_: *mut ISteamMatchmakingServers,
        unIP: uint32,
        usPort: uint16,
        pRequestServersResponse: *mut ISteamMatchmakingRulesResponse,
    ) -> HServerQuery;
}
extern "C" {
    pub fn SteamAPI_ISteamMatchmakingServers_CancelServerQuery(
        self_: *mut ISteamMatchmakingServers,
        hServerQuery: HServerQuery,
    );
}
extern "C" {
    pub fn SteamAPI_SteamGameSearch_v001() -> *mut ISteamGameSearch;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_AddGameSearchParams(
        self_: *mut ISteamGameSearch,
        pchKeyToFind: *const ::std::os::raw::c_char,
        pchValuesToFind: *const ::std::os::raw::c_char,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_SearchForGameWithLobby(
        self_: *mut ISteamGameSearch,
        steamIDLobby: uint64_steamid,
        nPlayerMin: ::std::os::raw::c_int,
        nPlayerMax: ::std::os::raw::c_int,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_SearchForGameSolo(
        self_: *mut ISteamGameSearch,
        nPlayerMin: ::std::os::raw::c_int,
        nPlayerMax: ::std::os::raw::c_int,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_AcceptGame(
        self_: *mut ISteamGameSearch,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_DeclineGame(
        self_: *mut ISteamGameSearch,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_RetrieveConnectionDetails(
        self_: *mut ISteamGameSearch,
        steamIDHost: uint64_steamid,
        pchConnectionDetails: *mut ::std::os::raw::c_char,
        cubConnectionDetails: ::std::os::raw::c_int,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_EndGameSearch(
        self_: *mut ISteamGameSearch,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_SetGameHostParams(
        self_: *mut ISteamGameSearch,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_SetConnectionDetails(
        self_: *mut ISteamGameSearch,
        pchConnectionDetails: *const ::std::os::raw::c_char,
        cubConnectionDetails: ::std::os::raw::c_int,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_RequestPlayersForGame(
        self_: *mut ISteamGameSearch,
        nPlayerMin: ::std::os::raw::c_int,
        nPlayerMax: ::std::os::raw::c_int,
        nMaxTeamSize: ::std::os::raw::c_int,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_HostConfirmGameStart(
        self_: *mut ISteamGameSearch,
        ullUniqueGameID: uint64,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_CancelRequestPlayersForGame(
        self_: *mut ISteamGameSearch,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_SubmitPlayerResult(
        self_: *mut ISteamGameSearch,
        ullUniqueGameID: uint64,
        steamIDPlayer: uint64_steamid,
        EPlayerResult: EPlayerResult_t,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameSearch_EndGame(
        self_: *mut ISteamGameSearch,
        ullUniqueGameID: uint64,
    ) -> EGameSearchErrorCode_t;
}
extern "C" {
    pub fn SteamAPI_SteamParties_v002() -> *mut ISteamParties;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetNumActiveBeacons(self_: *mut ISteamParties) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetBeaconByIndex(
        self_: *mut ISteamParties,
        unIndex: uint32,
    ) -> PartyBeaconID_t;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetBeaconDetails(
        self_: *mut ISteamParties,
        ulBeaconID: PartyBeaconID_t,
        pSteamIDBeaconOwner: *mut CSteamID,
        pLocation: *mut SteamPartyBeaconLocation_t,
        pchMetadata: *mut ::std::os::raw::c_char,
        cchMetadata: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_JoinParty(
        self_: *mut ISteamParties,
        ulBeaconID: PartyBeaconID_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetNumAvailableBeaconLocations(
        self_: *mut ISteamParties,
        puNumLocations: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetAvailableBeaconLocations(
        self_: *mut ISteamParties,
        pLocationList: *mut SteamPartyBeaconLocation_t,
        uMaxNumLocations: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_CreateBeacon(
        self_: *mut ISteamParties,
        unOpenSlots: uint32,
        pBeaconLocation: *mut SteamPartyBeaconLocation_t,
        pchConnectString: *const ::std::os::raw::c_char,
        pchMetadata: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_OnReservationCompleted(
        self_: *mut ISteamParties,
        ulBeacon: PartyBeaconID_t,
        steamIDUser: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamParties_CancelReservation(
        self_: *mut ISteamParties,
        ulBeacon: PartyBeaconID_t,
        steamIDUser: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamParties_ChangeNumOpenSlots(
        self_: *mut ISteamParties,
        ulBeacon: PartyBeaconID_t,
        unOpenSlots: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_DestroyBeacon(
        self_: *mut ISteamParties,
        ulBeacon: PartyBeaconID_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParties_GetBeaconLocationData(
        self_: *mut ISteamParties,
        BeaconLocation: SteamPartyBeaconLocation_t,
        eData: ESteamPartyBeaconLocationData,
        pchDataStringOut: *mut ::std::os::raw::c_char,
        cchDataStringOut: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamRemoteStorage_v016() -> *mut ISteamRemoteStorage;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWrite(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        pvData: *const ::std::os::raw::c_void,
        cubData: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileRead(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        pvData: *mut ::std::os::raw::c_void,
        cubDataToRead: int32,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWriteAsync(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        pvData: *const ::std::os::raw::c_void,
        cubData: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileReadAsync(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        nOffset: uint32,
        cubToRead: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileReadAsyncComplete(
        self_: *mut ISteamRemoteStorage,
        hReadCall: SteamAPICall_t,
        pvBuffer: *mut ::std::os::raw::c_void,
        cubToRead: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileForget(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileDelete(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileShare(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_SetSyncPlatforms(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        eRemoteStoragePlatform: ERemoteStoragePlatform,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWriteStreamOpen(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> UGCFileWriteStreamHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWriteStreamWriteChunk(
        self_: *mut ISteamRemoteStorage,
        writeHandle: UGCFileWriteStreamHandle_t,
        pvData: *const ::std::os::raw::c_void,
        cubData: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWriteStreamClose(
        self_: *mut ISteamRemoteStorage,
        writeHandle: UGCFileWriteStreamHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileWriteStreamCancel(
        self_: *mut ISteamRemoteStorage,
        writeHandle: UGCFileWriteStreamHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FileExists(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_FilePersisted(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetFileSize(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetFileTimestamp(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> int64;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetSyncPlatforms(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
    ) -> ERemoteStoragePlatform;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetFileCount(self_: *mut ISteamRemoteStorage) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetFileNameAndSize(
        self_: *mut ISteamRemoteStorage,
        iFile: ::std::os::raw::c_int,
        pnFileSizeInBytes: *mut int32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetQuota(
        self_: *mut ISteamRemoteStorage,
        pnTotalBytes: *mut uint64,
        puAvailableBytes: *mut uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_IsCloudEnabledForAccount(
        self_: *mut ISteamRemoteStorage,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_IsCloudEnabledForApp(
        self_: *mut ISteamRemoteStorage,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_SetCloudEnabledForApp(
        self_: *mut ISteamRemoteStorage,
        bEnabled: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UGCDownload(
        self_: *mut ISteamRemoteStorage,
        hContent: UGCHandle_t,
        unPriority: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetUGCDownloadProgress(
        self_: *mut ISteamRemoteStorage,
        hContent: UGCHandle_t,
        pnBytesDownloaded: *mut int32,
        pnBytesExpected: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetUGCDetails(
        self_: *mut ISteamRemoteStorage,
        hContent: UGCHandle_t,
        pnAppID: *mut AppId_t,
        ppchName: *mut *mut ::std::os::raw::c_char,
        pnFileSizeInBytes: *mut int32,
        pSteamIDOwner: *mut CSteamID,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UGCRead(
        self_: *mut ISteamRemoteStorage,
        hContent: UGCHandle_t,
        pvData: *mut ::std::os::raw::c_void,
        cubDataToRead: int32,
        cOffset: uint32,
        eAction: EUGCReadAction,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetCachedUGCCount(self_: *mut ISteamRemoteStorage)
        -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetCachedUGCHandle(
        self_: *mut ISteamRemoteStorage,
        iCachedContent: int32,
    ) -> UGCHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_PublishWorkshopFile(
        self_: *mut ISteamRemoteStorage,
        pchFile: *const ::std::os::raw::c_char,
        pchPreviewFile: *const ::std::os::raw::c_char,
        nConsumerAppId: AppId_t,
        pchTitle: *const ::std::os::raw::c_char,
        pchDescription: *const ::std::os::raw::c_char,
        eVisibility: ERemoteStoragePublishedFileVisibility,
        pTags: *mut SteamParamStringArray_t,
        eWorkshopFileType: EWorkshopFileType,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_CreatePublishedFileUpdateRequest(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> PublishedFileUpdateHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileFile(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pchFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFilePreviewFile(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pchPreviewFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTitle(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pchTitle: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileDescription(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pchDescription: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileVisibility(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        eVisibility: ERemoteStoragePublishedFileVisibility,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTags(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pTags: *mut SteamParamStringArray_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_CommitPublishedFileUpdate(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetPublishedFileDetails(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
        unMaxSecondsOld: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_DeletePublishedFile(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EnumerateUserPublishedFiles(
        self_: *mut ISteamRemoteStorage,
        unStartIndex: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_SubscribePublishedFile(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EnumerateUserSubscribedFiles(
        self_: *mut ISteamRemoteStorage,
        unStartIndex: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UnsubscribePublishedFile(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdatePublishedFileSetChangeDescription(
        self_: *mut ISteamRemoteStorage,
        updateHandle: PublishedFileUpdateHandle_t,
        pchChangeDescription: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetPublishedItemVoteDetails(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UpdateUserPublishedItemVote(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
        bVoteUp: bool,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetUserPublishedItemVoteDetails(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EnumerateUserSharedWorkshopFiles(
        self_: *mut ISteamRemoteStorage,
        steamId: uint64_steamid,
        unStartIndex: uint32,
        pRequiredTags: *mut SteamParamStringArray_t,
        pExcludedTags: *mut SteamParamStringArray_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_PublishVideo(
        self_: *mut ISteamRemoteStorage,
        eVideoProvider: EWorkshopVideoProvider,
        pchVideoAccount: *const ::std::os::raw::c_char,
        pchVideoIdentifier: *const ::std::os::raw::c_char,
        pchPreviewFile: *const ::std::os::raw::c_char,
        nConsumerAppId: AppId_t,
        pchTitle: *const ::std::os::raw::c_char,
        pchDescription: *const ::std::os::raw::c_char,
        eVisibility: ERemoteStoragePublishedFileVisibility,
        pTags: *mut SteamParamStringArray_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_SetUserPublishedFileAction(
        self_: *mut ISteamRemoteStorage,
        unPublishedFileId: PublishedFileId_t,
        eAction: EWorkshopFileAction,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EnumeratePublishedFilesByUserAction(
        self_: *mut ISteamRemoteStorage,
        eAction: EWorkshopFileAction,
        unStartIndex: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EnumeratePublishedWorkshopFiles(
        self_: *mut ISteamRemoteStorage,
        eEnumerationType: EWorkshopEnumerationType,
        unStartIndex: uint32,
        unCount: uint32,
        unDays: uint32,
        pTags: *mut SteamParamStringArray_t,
        pUserTags: *mut SteamParamStringArray_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_UGCDownloadToLocation(
        self_: *mut ISteamRemoteStorage,
        hContent: UGCHandle_t,
        pchLocation: *const ::std::os::raw::c_char,
        unPriority: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetLocalFileChangeCount(
        self_: *mut ISteamRemoteStorage,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_GetLocalFileChange(
        self_: *mut ISteamRemoteStorage,
        iFile: ::std::os::raw::c_int,
        pEChangeType: *mut ERemoteStorageLocalFileChange,
        pEFilePathType: *mut ERemoteStorageFilePathType,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_BeginFileWriteBatch(
        self_: *mut ISteamRemoteStorage,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemoteStorage_EndFileWriteBatch(self_: *mut ISteamRemoteStorage) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamUserStats_v012() -> *mut ISteamUserStats;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_RequestCurrentStats(self_: *mut ISteamUserStats) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetStatInt32(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetStatFloat(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_SetStatInt32(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        nData: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_SetStatFloat(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        fData: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_UpdateAvgRateStat(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        flCountThisSession: f32,
        dSessionLength: f64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievement(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pbAchieved: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_SetAchievement(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_ClearAchievement(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementAndUnlockTime(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pbAchieved: *mut bool,
        punUnlockTime: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_StoreStats(self_: *mut ISteamUserStats) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementIcon(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementDisplayAttribute(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pchKey: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_IndicateAchievementProgress(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        nCurProgress: uint32,
        nMaxProgress: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetNumAchievements(self_: *mut ISteamUserStats) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementName(
        self_: *mut ISteamUserStats,
        iAchievement: uint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_RequestUserStats(
        self_: *mut ISteamUserStats,
        steamIDUser: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetUserStatInt32(
        self_: *mut ISteamUserStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetUserStatFloat(
        self_: *mut ISteamUserStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetUserAchievement(
        self_: *mut ISteamUserStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pbAchieved: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetUserAchievementAndUnlockTime(
        self_: *mut ISteamUserStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pbAchieved: *mut bool,
        punUnlockTime: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_ResetAllStats(
        self_: *mut ISteamUserStats,
        bAchievementsToo: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_FindOrCreateLeaderboard(
        self_: *mut ISteamUserStats,
        pchLeaderboardName: *const ::std::os::raw::c_char,
        eLeaderboardSortMethod: ELeaderboardSortMethod,
        eLeaderboardDisplayType: ELeaderboardDisplayType,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_FindLeaderboard(
        self_: *mut ISteamUserStats,
        pchLeaderboardName: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetLeaderboardName(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetLeaderboardEntryCount(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetLeaderboardSortMethod(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
    ) -> ELeaderboardSortMethod;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetLeaderboardDisplayType(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
    ) -> ELeaderboardDisplayType;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_DownloadLeaderboardEntries(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
        eLeaderboardDataRequest: ELeaderboardDataRequest,
        nRangeStart: ::std::os::raw::c_int,
        nRangeEnd: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_DownloadLeaderboardEntriesForUsers(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
        prgUsers: *mut CSteamID,
        cUsers: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetDownloadedLeaderboardEntry(
        self_: *mut ISteamUserStats,
        hSteamLeaderboardEntries: SteamLeaderboardEntries_t,
        index: ::std::os::raw::c_int,
        pLeaderboardEntry: *mut LeaderboardEntry_t,
        pDetails: *mut int32,
        cDetailsMax: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_UploadLeaderboardScore(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
        eLeaderboardUploadScoreMethod: ELeaderboardUploadScoreMethod,
        nScore: int32,
        pScoreDetails: *const int32,
        cScoreDetailsCount: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_AttachLeaderboardUGC(
        self_: *mut ISteamUserStats,
        hSteamLeaderboard: SteamLeaderboard_t,
        hUGC: UGCHandle_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetNumberOfCurrentPlayers(
        self_: *mut ISteamUserStats,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_RequestGlobalAchievementPercentages(
        self_: *mut ISteamUserStats,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetMostAchievedAchievementInfo(
        self_: *mut ISteamUserStats,
        pchName: *mut ::std::os::raw::c_char,
        unNameBufLen: uint32,
        pflPercent: *mut f32,
        pbAchieved: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetNextMostAchievedAchievementInfo(
        self_: *mut ISteamUserStats,
        iIteratorPrevious: ::std::os::raw::c_int,
        pchName: *mut ::std::os::raw::c_char,
        unNameBufLen: uint32,
        pflPercent: *mut f32,
        pbAchieved: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementAchievedPercent(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pflPercent: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_RequestGlobalStats(
        self_: *mut ISteamUserStats,
        nHistoryDays: ::std::os::raw::c_int,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetGlobalStatInt64(
        self_: *mut ISteamUserStats,
        pchStatName: *const ::std::os::raw::c_char,
        pData: *mut int64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetGlobalStatDouble(
        self_: *mut ISteamUserStats,
        pchStatName: *const ::std::os::raw::c_char,
        pData: *mut f64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetGlobalStatHistoryInt64(
        self_: *mut ISteamUserStats,
        pchStatName: *const ::std::os::raw::c_char,
        pData: *mut int64,
        cubData: uint32,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetGlobalStatHistoryDouble(
        self_: *mut ISteamUserStats,
        pchStatName: *const ::std::os::raw::c_char,
        pData: *mut f64,
        cubData: uint32,
    ) -> int32;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementProgressLimitsInt32(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pnMinProgress: *mut int32,
        pnMaxProgress: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUserStats_GetAchievementProgressLimitsFloat(
        self_: *mut ISteamUserStats,
        pchName: *const ::std::os::raw::c_char,
        pfMinProgress: *mut f32,
        pfMaxProgress: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamApps_v008() -> *mut ISteamApps;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsSubscribed(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsLowViolence(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsCybercafe(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsVACBanned(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetCurrentGameLanguage(
        self_: *mut ISteamApps,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetAvailableGameLanguages(
        self_: *mut ISteamApps,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsSubscribedApp(self_: *mut ISteamApps, appID: AppId_t) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsDlcInstalled(self_: *mut ISteamApps, appID: AppId_t) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetEarliestPurchaseUnixTime(
        self_: *mut ISteamApps,
        nAppID: AppId_t,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsSubscribedFromFreeWeekend(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetDLCCount(self_: *mut ISteamApps) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BGetDLCDataByIndex(
        self_: *mut ISteamApps,
        iDLC: ::std::os::raw::c_int,
        pAppID: *mut AppId_t,
        pbAvailable: *mut bool,
        pchName: *mut ::std::os::raw::c_char,
        cchNameBufferSize: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_InstallDLC(self_: *mut ISteamApps, nAppID: AppId_t);
}
extern "C" {
    pub fn SteamAPI_ISteamApps_UninstallDLC(self_: *mut ISteamApps, nAppID: AppId_t);
}
extern "C" {
    pub fn SteamAPI_ISteamApps_RequestAppProofOfPurchaseKey(
        self_: *mut ISteamApps,
        nAppID: AppId_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetCurrentBetaName(
        self_: *mut ISteamApps,
        pchName: *mut ::std::os::raw::c_char,
        cchNameBufferSize: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_MarkContentCorrupt(
        self_: *mut ISteamApps,
        bMissingFilesOnly: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetInstalledDepots(
        self_: *mut ISteamApps,
        appID: AppId_t,
        pvecDepots: *mut DepotId_t,
        cMaxDepots: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetAppInstallDir(
        self_: *mut ISteamApps,
        appID: AppId_t,
        pchFolder: *mut ::std::os::raw::c_char,
        cchFolderBufferSize: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsAppInstalled(self_: *mut ISteamApps, appID: AppId_t) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetAppOwner(self_: *mut ISteamApps) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetLaunchQueryParam(
        self_: *mut ISteamApps,
        pchKey: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetDlcDownloadProgress(
        self_: *mut ISteamApps,
        nAppID: AppId_t,
        punBytesDownloaded: *mut uint64,
        punBytesTotal: *mut uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetAppBuildId(self_: *mut ISteamApps) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_RequestAllProofOfPurchaseKeys(self_: *mut ISteamApps);
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetFileDetails(
        self_: *mut ISteamApps,
        pszFileName: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_GetLaunchCommandLine(
        self_: *mut ISteamApps,
        pszCommandLine: *mut ::std::os::raw::c_char,
        cubCommandLine: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsSubscribedFromFamilySharing(self_: *mut ISteamApps) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_BIsTimedTrial(
        self_: *mut ISteamApps,
        punSecondsAllowed: *mut uint32,
        punSecondsPlayed: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamApps_SetDlcContext(self_: *mut ISteamApps, nAppID: AppId_t) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworking_v006() -> *mut ISteamNetworking;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerNetworking_v006() -> *mut ISteamNetworking;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_SendP2PPacket(
        self_: *mut ISteamNetworking,
        steamIDRemote: uint64_steamid,
        pubData: *const ::std::os::raw::c_void,
        cubData: uint32,
        eP2PSendType: EP2PSend,
        nChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_IsP2PPacketAvailable(
        self_: *mut ISteamNetworking,
        pcubMsgSize: *mut uint32,
        nChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_ReadP2PPacket(
        self_: *mut ISteamNetworking,
        pubDest: *mut ::std::os::raw::c_void,
        cubDest: uint32,
        pcubMsgSize: *mut uint32,
        psteamIDRemote: *mut CSteamID,
        nChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_AcceptP2PSessionWithUser(
        self_: *mut ISteamNetworking,
        steamIDRemote: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_CloseP2PSessionWithUser(
        self_: *mut ISteamNetworking,
        steamIDRemote: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_CloseP2PChannelWithUser(
        self_: *mut ISteamNetworking,
        steamIDRemote: uint64_steamid,
        nChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_GetP2PSessionState(
        self_: *mut ISteamNetworking,
        steamIDRemote: uint64_steamid,
        pConnectionState: *mut P2PSessionState_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_AllowP2PPacketRelay(
        self_: *mut ISteamNetworking,
        bAllow: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_CreateListenSocket(
        self_: *mut ISteamNetworking,
        nVirtualP2PPort: ::std::os::raw::c_int,
        nIP: SteamIPAddress_t,
        nPort: uint16,
        bAllowUseOfPacketRelay: bool,
    ) -> SNetListenSocket_t;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_CreateP2PConnectionSocket(
        self_: *mut ISteamNetworking,
        steamIDTarget: uint64_steamid,
        nVirtualPort: ::std::os::raw::c_int,
        nTimeoutSec: ::std::os::raw::c_int,
        bAllowUseOfPacketRelay: bool,
    ) -> SNetSocket_t;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_CreateConnectionSocket(
        self_: *mut ISteamNetworking,
        nIP: SteamIPAddress_t,
        nPort: uint16,
        nTimeoutSec: ::std::os::raw::c_int,
    ) -> SNetSocket_t;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_DestroySocket(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
        bNotifyRemoteEnd: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_DestroyListenSocket(
        self_: *mut ISteamNetworking,
        hSocket: SNetListenSocket_t,
        bNotifyRemoteEnd: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_SendDataOnSocket(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
        pubData: *mut ::std::os::raw::c_void,
        cubData: uint32,
        bReliable: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_IsDataAvailableOnSocket(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
        pcubMsgSize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_RetrieveDataFromSocket(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
        pubDest: *mut ::std::os::raw::c_void,
        cubDest: uint32,
        pcubMsgSize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_IsDataAvailable(
        self_: *mut ISteamNetworking,
        hListenSocket: SNetListenSocket_t,
        pcubMsgSize: *mut uint32,
        phSocket: *mut SNetSocket_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_RetrieveData(
        self_: *mut ISteamNetworking,
        hListenSocket: SNetListenSocket_t,
        pubDest: *mut ::std::os::raw::c_void,
        cubDest: uint32,
        pcubMsgSize: *mut uint32,
        phSocket: *mut SNetSocket_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_GetSocketInfo(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
        pSteamIDRemote: *mut CSteamID,
        peSocketStatus: *mut ::std::os::raw::c_int,
        punIPRemote: *mut SteamIPAddress_t,
        punPortRemote: *mut uint16,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_GetListenSocketInfo(
        self_: *mut ISteamNetworking,
        hListenSocket: SNetListenSocket_t,
        pnIP: *mut SteamIPAddress_t,
        pnPort: *mut uint16,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_GetSocketConnectionType(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
    ) -> ESNetSocketConnectionType;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworking_GetMaxPacketSize(
        self_: *mut ISteamNetworking,
        hSocket: SNetSocket_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_SteamScreenshots_v003() -> *mut ISteamScreenshots;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_WriteScreenshot(
        self_: *mut ISteamScreenshots,
        pubRGB: *mut ::std::os::raw::c_void,
        cubRGB: uint32,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
    ) -> ScreenshotHandle;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_AddScreenshotToLibrary(
        self_: *mut ISteamScreenshots,
        pchFilename: *const ::std::os::raw::c_char,
        pchThumbnailFilename: *const ::std::os::raw::c_char,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
    ) -> ScreenshotHandle;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_TriggerScreenshot(self_: *mut ISteamScreenshots);
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_HookScreenshots(self_: *mut ISteamScreenshots, bHook: bool);
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_SetLocation(
        self_: *mut ISteamScreenshots,
        hScreenshot: ScreenshotHandle,
        pchLocation: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_TagUser(
        self_: *mut ISteamScreenshots,
        hScreenshot: ScreenshotHandle,
        steamID: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_TagPublishedFile(
        self_: *mut ISteamScreenshots,
        hScreenshot: ScreenshotHandle,
        unPublishedFileID: PublishedFileId_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_IsScreenshotsHooked(self_: *mut ISteamScreenshots) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamScreenshots_AddVRScreenshotToLibrary(
        self_: *mut ISteamScreenshots,
        eType: EVRScreenshotType,
        pchFilename: *const ::std::os::raw::c_char,
        pchVRFilename: *const ::std::os::raw::c_char,
    ) -> ScreenshotHandle;
}
extern "C" {
    pub fn SteamAPI_SteamMusic_v001() -> *mut ISteamMusic;
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_BIsEnabled(self_: *mut ISteamMusic) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_BIsPlaying(self_: *mut ISteamMusic) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_GetPlaybackStatus(self_: *mut ISteamMusic) -> AudioPlayback_Status;
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_Play(self_: *mut ISteamMusic);
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_Pause(self_: *mut ISteamMusic);
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_PlayPrevious(self_: *mut ISteamMusic);
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_PlayNext(self_: *mut ISteamMusic);
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_SetVolume(self_: *mut ISteamMusic, flVolume: f32);
}
extern "C" {
    pub fn SteamAPI_ISteamMusic_GetVolume(self_: *mut ISteamMusic) -> f32;
}
extern "C" {
    pub fn SteamAPI_SteamMusicRemote_v001() -> *mut ISteamMusicRemote;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_RegisterSteamMusicRemote(
        self_: *mut ISteamMusicRemote,
        pchName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_DeregisterSteamMusicRemote(
        self_: *mut ISteamMusicRemote,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_BIsCurrentMusicRemote(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_BActivationSuccess(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetDisplayName(
        self_: *mut ISteamMusicRemote,
        pchDisplayName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetPNGIcon_64x64(
        self_: *mut ISteamMusicRemote,
        pvBuffer: *mut ::std::os::raw::c_void,
        cbBufferLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnablePlayPrevious(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnablePlayNext(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnableShuffled(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnableLooped(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnableQueue(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_EnablePlaylists(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdatePlaybackStatus(
        self_: *mut ISteamMusicRemote,
        nStatus: AudioPlayback_Status,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateShuffled(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateLooped(
        self_: *mut ISteamMusicRemote,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateVolume(
        self_: *mut ISteamMusicRemote,
        flValue: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_CurrentEntryWillChange(self_: *mut ISteamMusicRemote)
        -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_CurrentEntryIsAvailable(
        self_: *mut ISteamMusicRemote,
        bAvailable: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateCurrentEntryText(
        self_: *mut ISteamMusicRemote,
        pchText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateCurrentEntryElapsedSeconds(
        self_: *mut ISteamMusicRemote,
        nValue: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_UpdateCurrentEntryCoverArt(
        self_: *mut ISteamMusicRemote,
        pvBuffer: *mut ::std::os::raw::c_void,
        cbBufferLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_CurrentEntryDidChange(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_QueueWillChange(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_ResetQueueEntries(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetQueueEntry(
        self_: *mut ISteamMusicRemote,
        nID: ::std::os::raw::c_int,
        nPosition: ::std::os::raw::c_int,
        pchEntryText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetCurrentQueueEntry(
        self_: *mut ISteamMusicRemote,
        nID: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_QueueDidChange(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_PlaylistWillChange(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_ResetPlaylistEntries(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetPlaylistEntry(
        self_: *mut ISteamMusicRemote,
        nID: ::std::os::raw::c_int,
        nPosition: ::std::os::raw::c_int,
        pchEntryText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_SetCurrentPlaylistEntry(
        self_: *mut ISteamMusicRemote,
        nID: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamMusicRemote_PlaylistDidChange(self_: *mut ISteamMusicRemote) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamHTTP_v003() -> *mut ISteamHTTP;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerHTTP_v003() -> *mut ISteamHTTP;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_CreateHTTPRequest(
        self_: *mut ISteamHTTP,
        eHTTPRequestMethod: EHTTPMethod,
        pchAbsoluteURL: *const ::std::os::raw::c_char,
    ) -> HTTPRequestHandle;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestContextValue(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        ulContextValue: uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestNetworkActivityTimeout(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        unTimeoutSeconds: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestHeaderValue(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchHeaderName: *const ::std::os::raw::c_char,
        pchHeaderValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestGetOrPostParameter(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchParamName: *const ::std::os::raw::c_char,
        pchParamValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SendHTTPRequest(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pCallHandle: *mut SteamAPICall_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SendHTTPRequestAndStreamResponse(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pCallHandle: *mut SteamAPICall_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_DeferHTTPRequest(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_PrioritizeHTTPRequest(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPResponseHeaderSize(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchHeaderName: *const ::std::os::raw::c_char,
        unResponseHeaderSize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPResponseHeaderValue(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchHeaderName: *const ::std::os::raw::c_char,
        pHeaderValueBuffer: *mut uint8,
        unBufferSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPResponseBodySize(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        unBodySize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPResponseBodyData(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pBodyDataBuffer: *mut uint8,
        unBufferSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPStreamingResponseBodyData(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        cOffset: uint32,
        pBodyDataBuffer: *mut uint8,
        unBufferSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_ReleaseHTTPRequest(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPDownloadProgressPct(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pflPercentOut: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestRawPostBody(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchContentType: *const ::std::os::raw::c_char,
        pubBody: *mut uint8,
        unBodyLen: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_CreateCookieContainer(
        self_: *mut ISteamHTTP,
        bAllowResponsesToModify: bool,
    ) -> HTTPCookieContainerHandle;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_ReleaseCookieContainer(
        self_: *mut ISteamHTTP,
        hCookieContainer: HTTPCookieContainerHandle,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetCookie(
        self_: *mut ISteamHTTP,
        hCookieContainer: HTTPCookieContainerHandle,
        pchHost: *const ::std::os::raw::c_char,
        pchUrl: *const ::std::os::raw::c_char,
        pchCookie: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestCookieContainer(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        hCookieContainer: HTTPCookieContainerHandle,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestUserAgentInfo(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pchUserAgentInfo: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestRequiresVerifiedCertificate(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        bRequireVerifiedCertificate: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_SetHTTPRequestAbsoluteTimeoutMS(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        unMilliseconds: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTTP_GetHTTPRequestWasTimedOut(
        self_: *mut ISteamHTTP,
        hRequest: HTTPRequestHandle,
        pbWasTimedOut: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamInput_v006() -> *mut ISteamInput;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_Init(
        self_: *mut ISteamInput,
        bExplicitlyCallRunFrame: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_Shutdown(self_: *mut ISteamInput) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_SetInputActionManifestFilePath(
        self_: *mut ISteamInput,
        pchInputActionManifestAbsolutePath: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_RunFrame(self_: *mut ISteamInput, bReservedValue: bool);
}
extern "C" {
    pub fn SteamAPI_ISteamInput_BWaitForData(
        self_: *mut ISteamInput,
        bWaitForever: bool,
        unTimeout: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_BNewDataAvailable(self_: *mut ISteamInput) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetConnectedControllers(
        self_: *mut ISteamInput,
        handlesOut: *mut InputHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_EnableDeviceCallbacks(self_: *mut ISteamInput);
}
extern "C" {
    pub fn SteamAPI_ISteamInput_EnableActionEventCallbacks(
        self_: *mut ISteamInput,
        pCallback: SteamInputActionEventCallbackPointer,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetActionSetHandle(
        self_: *mut ISteamInput,
        pszActionSetName: *const ::std::os::raw::c_char,
    ) -> InputActionSetHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_ActivateActionSet(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        actionSetHandle: InputActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetCurrentActionSet(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    ) -> InputActionSetHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_ActivateActionSetLayer(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        actionSetLayerHandle: InputActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_DeactivateActionSetLayer(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        actionSetLayerHandle: InputActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_DeactivateAllActionSetLayers(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetActiveActionSetLayers(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        handlesOut: *mut InputActionSetHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetDigitalActionHandle(
        self_: *mut ISteamInput,
        pszActionName: *const ::std::os::raw::c_char,
    ) -> InputDigitalActionHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetDigitalActionData(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        digitalActionHandle: InputDigitalActionHandle_t,
    ) -> InputDigitalActionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetDigitalActionOrigins(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        actionSetHandle: InputActionSetHandle_t,
        digitalActionHandle: InputDigitalActionHandle_t,
        originsOut: *mut EInputActionOrigin,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetStringForDigitalActionName(
        self_: *mut ISteamInput,
        eActionHandle: InputDigitalActionHandle_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetAnalogActionHandle(
        self_: *mut ISteamInput,
        pszActionName: *const ::std::os::raw::c_char,
    ) -> InputAnalogActionHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetAnalogActionData(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        analogActionHandle: InputAnalogActionHandle_t,
    ) -> InputAnalogActionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetAnalogActionOrigins(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        actionSetHandle: InputActionSetHandle_t,
        analogActionHandle: InputAnalogActionHandle_t,
        originsOut: *mut EInputActionOrigin,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetGlyphPNGForActionOrigin(
        self_: *mut ISteamInput,
        eOrigin: EInputActionOrigin,
        eSize: ESteamInputGlyphSize,
        unFlags: uint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetGlyphSVGForActionOrigin(
        self_: *mut ISteamInput,
        eOrigin: EInputActionOrigin,
        unFlags: uint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetGlyphForActionOrigin_Legacy(
        self_: *mut ISteamInput,
        eOrigin: EInputActionOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetStringForActionOrigin(
        self_: *mut ISteamInput,
        eOrigin: EInputActionOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetStringForAnalogActionName(
        self_: *mut ISteamInput,
        eActionHandle: InputAnalogActionHandle_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_StopAnalogActionMomentum(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        eAction: InputAnalogActionHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetMotionData(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    ) -> InputMotionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_TriggerVibration(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        usLeftSpeed: ::std::os::raw::c_ushort,
        usRightSpeed: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_TriggerVibrationExtended(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        usLeftSpeed: ::std::os::raw::c_ushort,
        usRightSpeed: ::std::os::raw::c_ushort,
        usLeftTriggerSpeed: ::std::os::raw::c_ushort,
        usRightTriggerSpeed: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_TriggerSimpleHapticEvent(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        eHapticLocation: EControllerHapticLocation,
        nIntensity: uint8,
        nGainDB: ::std::os::raw::c_char,
        nOtherIntensity: uint8,
        nOtherGainDB: ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_SetLEDColor(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        nColorR: uint8,
        nColorG: uint8,
        nColorB: uint8,
        nFlags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_Legacy_TriggerHapticPulse(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        eTargetPad: ESteamControllerPad,
        usDurationMicroSec: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_Legacy_TriggerRepeatedHapticPulse(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        eTargetPad: ESteamControllerPad,
        usDurationMicroSec: ::std::os::raw::c_ushort,
        usOffMicroSec: ::std::os::raw::c_ushort,
        unRepeat: ::std::os::raw::c_ushort,
        nFlags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInput_ShowBindingPanel(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetInputTypeForHandle(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    ) -> ESteamInputType;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetControllerForGamepadIndex(
        self_: *mut ISteamInput,
        nIndex: ::std::os::raw::c_int,
    ) -> InputHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetGamepadIndexForController(
        self_: *mut ISteamInput,
        ulinputHandle: InputHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetStringForXboxOrigin(
        self_: *mut ISteamInput,
        eOrigin: EXboxOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetGlyphForXboxOrigin(
        self_: *mut ISteamInput,
        eOrigin: EXboxOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetActionOriginFromXboxOrigin(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        eOrigin: EXboxOrigin,
    ) -> EInputActionOrigin;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_TranslateActionOrigin(
        self_: *mut ISteamInput,
        eDestinationInputType: ESteamInputType,
        eSourceOrigin: EInputActionOrigin,
    ) -> EInputActionOrigin;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetDeviceBindingRevision(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        pMajor: *mut ::std::os::raw::c_int,
        pMinor: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetRemotePlaySessionID(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_GetSessionInputConfigurationSettings(
        self_: *mut ISteamInput,
    ) -> uint16;
}
extern "C" {
    pub fn SteamAPI_ISteamInput_SetDualSenseTriggerEffect(
        self_: *mut ISteamInput,
        inputHandle: InputHandle_t,
        pParam: *const ScePadTriggerEffectParam,
    );
}
extern "C" {
    pub fn SteamAPI_SteamController_v008() -> *mut ISteamController;
}
extern "C" {
    pub fn SteamAPI_ISteamController_Init(self_: *mut ISteamController) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamController_Shutdown(self_: *mut ISteamController) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamController_RunFrame(self_: *mut ISteamController);
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetConnectedControllers(
        self_: *mut ISteamController,
        handlesOut: *mut ControllerHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetActionSetHandle(
        self_: *mut ISteamController,
        pszActionSetName: *const ::std::os::raw::c_char,
    ) -> ControllerActionSetHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_ActivateActionSet(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        actionSetHandle: ControllerActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetCurrentActionSet(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
    ) -> ControllerActionSetHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_ActivateActionSetLayer(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        actionSetLayerHandle: ControllerActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_DeactivateActionSetLayer(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        actionSetLayerHandle: ControllerActionSetHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_DeactivateAllActionSetLayers(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetActiveActionSetLayers(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        handlesOut: *mut ControllerActionSetHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetDigitalActionHandle(
        self_: *mut ISteamController,
        pszActionName: *const ::std::os::raw::c_char,
    ) -> ControllerDigitalActionHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetDigitalActionData(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        digitalActionHandle: ControllerDigitalActionHandle_t,
    ) -> InputDigitalActionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetDigitalActionOrigins(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        actionSetHandle: ControllerActionSetHandle_t,
        digitalActionHandle: ControllerDigitalActionHandle_t,
        originsOut: *mut EControllerActionOrigin,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetAnalogActionHandle(
        self_: *mut ISteamController,
        pszActionName: *const ::std::os::raw::c_char,
    ) -> ControllerAnalogActionHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetAnalogActionData(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        analogActionHandle: ControllerAnalogActionHandle_t,
    ) -> InputAnalogActionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetAnalogActionOrigins(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        actionSetHandle: ControllerActionSetHandle_t,
        analogActionHandle: ControllerAnalogActionHandle_t,
        originsOut: *mut EControllerActionOrigin,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetGlyphForActionOrigin(
        self_: *mut ISteamController,
        eOrigin: EControllerActionOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetStringForActionOrigin(
        self_: *mut ISteamController,
        eOrigin: EControllerActionOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamController_StopAnalogActionMomentum(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        eAction: ControllerAnalogActionHandle_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetMotionData(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
    ) -> InputMotionData_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_TriggerHapticPulse(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        eTargetPad: ESteamControllerPad,
        usDurationMicroSec: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_TriggerRepeatedHapticPulse(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        eTargetPad: ESteamControllerPad,
        usDurationMicroSec: ::std::os::raw::c_ushort,
        usOffMicroSec: ::std::os::raw::c_ushort,
        unRepeat: ::std::os::raw::c_ushort,
        nFlags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_TriggerVibration(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        usLeftSpeed: ::std::os::raw::c_ushort,
        usRightSpeed: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_SetLEDColor(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        nColorR: uint8,
        nColorG: uint8,
        nColorB: uint8,
        nFlags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamController_ShowBindingPanel(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetInputTypeForHandle(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
    ) -> ESteamInputType;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetControllerForGamepadIndex(
        self_: *mut ISteamController,
        nIndex: ::std::os::raw::c_int,
    ) -> ControllerHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetGamepadIndexForController(
        self_: *mut ISteamController,
        ulControllerHandle: ControllerHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetStringForXboxOrigin(
        self_: *mut ISteamController,
        eOrigin: EXboxOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetGlyphForXboxOrigin(
        self_: *mut ISteamController,
        eOrigin: EXboxOrigin,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetActionOriginFromXboxOrigin(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        eOrigin: EXboxOrigin,
    ) -> EControllerActionOrigin;
}
extern "C" {
    pub fn SteamAPI_ISteamController_TranslateActionOrigin(
        self_: *mut ISteamController,
        eDestinationInputType: ESteamInputType,
        eSourceOrigin: EControllerActionOrigin,
    ) -> EControllerActionOrigin;
}
extern "C" {
    pub fn SteamAPI_ISteamController_GetControllerBindingRevision(
        self_: *mut ISteamController,
        controllerHandle: ControllerHandle_t,
        pMajor: *mut ::std::os::raw::c_int,
        pMinor: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamUGC_v018() -> *mut ISteamUGC;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerUGC_v018() -> *mut ISteamUGC;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_CreateQueryUserUGCRequest(
        self_: *mut ISteamUGC,
        unAccountID: AccountID_t,
        eListType: EUserUGCList,
        eMatchingUGCType: EUGCMatchingUGCType,
        eSortOrder: EUserUGCListSortOrder,
        nCreatorAppID: AppId_t,
        nConsumerAppID: AppId_t,
        unPage: uint32,
    ) -> UGCQueryHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_CreateQueryAllUGCRequestPage(
        self_: *mut ISteamUGC,
        eQueryType: EUGCQuery,
        eMatchingeMatchingUGCTypeFileType: EUGCMatchingUGCType,
        nCreatorAppID: AppId_t,
        nConsumerAppID: AppId_t,
        unPage: uint32,
    ) -> UGCQueryHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_CreateQueryAllUGCRequestCursor(
        self_: *mut ISteamUGC,
        eQueryType: EUGCQuery,
        eMatchingeMatchingUGCTypeFileType: EUGCMatchingUGCType,
        nCreatorAppID: AppId_t,
        nConsumerAppID: AppId_t,
        pchCursor: *const ::std::os::raw::c_char,
    ) -> UGCQueryHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_CreateQueryUGCDetailsRequest(
        self_: *mut ISteamUGC,
        pvecPublishedFileID: *mut PublishedFileId_t,
        unNumPublishedFileIDs: uint32,
    ) -> UGCQueryHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SendQueryUGCRequest(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCResult(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pDetails: *mut SteamUGCDetails_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCNumTags(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        indexTag: uint32,
        pchValue: *mut ::std::os::raw::c_char,
        cchValueSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCTagDisplayName(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        indexTag: uint32,
        pchValue: *mut ::std::os::raw::c_char,
        cchValueSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCPreviewURL(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pchURL: *mut ::std::os::raw::c_char,
        cchURLSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCMetadata(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pchMetadata: *mut ::std::os::raw::c_char,
        cchMetadatasize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCChildren(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pvecPublishedFileID: *mut PublishedFileId_t,
        cMaxEntries: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCStatistic(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        eStatType: EItemStatistic,
        pStatValue: *mut uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCNumAdditionalPreviews(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCAdditionalPreview(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        previewIndex: uint32,
        pchURLOrVideoID: *mut ::std::os::raw::c_char,
        cchURLSize: uint32,
        pchOriginalFileName: *mut ::std::os::raw::c_char,
        cchOriginalFileNameSize: uint32,
        pPreviewType: *mut EItemPreviewType,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCNumKeyValueTags(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        keyValueTagIndex: uint32,
        pchKey: *mut ::std::os::raw::c_char,
        cchKeySize: uint32,
        pchValue: *mut ::std::os::raw::c_char,
        cchValueSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryFirstUGCKeyValueTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *mut ::std::os::raw::c_char,
        cchValueSize: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetQueryUGCContentDescriptors(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        index: uint32,
        pvecDescriptors: *mut EUGCContentDescriptorID,
        cMaxEntries: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_ReleaseQueryUGCRequest(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddRequiredTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pTagName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddRequiredTagGroup(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pTagGroups: *const SteamParamStringArray_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddExcludedTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pTagName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnOnlyIDs(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnOnlyIDs: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnKeyValueTags(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnKeyValueTags: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnLongDescription(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnLongDescription: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnMetadata(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnMetadata: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnChildren(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnChildren: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnAdditionalPreviews(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnAdditionalPreviews: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnTotalOnly(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bReturnTotalOnly: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetReturnPlaytimeStats(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        unDays: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetLanguage(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pchLanguage: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetAllowCachedResponse(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        unMaxAgeSeconds: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetCloudFileNameFilter(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pMatchCloudFileName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetMatchAnyTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        bMatchAnyTag: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetSearchText(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pSearchText: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetRankedByTrendDays(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        unDays: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetTimeCreatedDateRange(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        rtStart: RTime32,
        rtEnd: RTime32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetTimeUpdatedDateRange(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        rtStart: RTime32,
        rtEnd: RTime32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddRequiredKeyValueTag(
        self_: *mut ISteamUGC,
        handle: UGCQueryHandle_t,
        pKey: *const ::std::os::raw::c_char,
        pValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RequestUGCDetails(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        unMaxAgeSeconds: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_CreateItem(
        self_: *mut ISteamUGC,
        nConsumerAppId: AppId_t,
        eFileType: EWorkshopFileType,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_StartItemUpdate(
        self_: *mut ISteamUGC,
        nConsumerAppId: AppId_t,
        nPublishedFileID: PublishedFileId_t,
    ) -> UGCUpdateHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemTitle(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchTitle: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemDescription(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchDescription: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemUpdateLanguage(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchLanguage: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemMetadata(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchMetaData: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemVisibility(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        eVisibility: ERemoteStoragePublishedFileVisibility,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemTags(
        self_: *mut ISteamUGC,
        updateHandle: UGCUpdateHandle_t,
        pTags: *const SteamParamStringArray_t,
        bAllowAdminTags: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemContent(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pszContentFolder: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetItemPreview(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pszPreviewFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetAllowLegacyUpload(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        bAllowLegacyUpload: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveAllItemKeyValueTags(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveItemKeyValueTags(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchKey: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddItemKeyValueTag(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddItemPreviewFile(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pszPreviewFile: *const ::std::os::raw::c_char,
        type_: EItemPreviewType,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddItemPreviewVideo(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pszVideoID: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_UpdateItemPreviewFile(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        index: uint32,
        pszPreviewFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_UpdateItemPreviewVideo(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        index: uint32,
        pszVideoID: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveItemPreview(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        index: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddContentDescriptor(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        descid: EUGCContentDescriptorID,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveContentDescriptor(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        descid: EUGCContentDescriptorID,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SubmitItemUpdate(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        pchChangeNote: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetItemUpdateProgress(
        self_: *mut ISteamUGC,
        handle: UGCUpdateHandle_t,
        punBytesProcessed: *mut uint64,
        punBytesTotal: *mut uint64,
    ) -> EItemUpdateStatus;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SetUserItemVote(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        bVoteUp: bool,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetUserItemVote(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddItemToFavorites(
        self_: *mut ISteamUGC,
        nAppId: AppId_t,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveItemFromFavorites(
        self_: *mut ISteamUGC,
        nAppId: AppId_t,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SubscribeItem(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_UnsubscribeItem(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetNumSubscribedItems(self_: *mut ISteamUGC) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetSubscribedItems(
        self_: *mut ISteamUGC,
        pvecPublishedFileID: *mut PublishedFileId_t,
        cMaxEntries: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetItemState(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetItemInstallInfo(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        punSizeOnDisk: *mut uint64,
        pchFolder: *mut ::std::os::raw::c_char,
        cchFolderSize: uint32,
        punTimeStamp: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetItemDownloadInfo(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        punBytesDownloaded: *mut uint64,
        punBytesTotal: *mut uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_DownloadItem(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        bHighPriority: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_BInitWorkshopForGameServer(
        self_: *mut ISteamUGC,
        unWorkshopDepotID: DepotId_t,
        pszFolder: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_SuspendDownloads(self_: *mut ISteamUGC, bSuspend: bool);
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_StartPlaytimeTracking(
        self_: *mut ISteamUGC,
        pvecPublishedFileID: *mut PublishedFileId_t,
        unNumPublishedFileIDs: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_StopPlaytimeTracking(
        self_: *mut ISteamUGC,
        pvecPublishedFileID: *mut PublishedFileId_t,
        unNumPublishedFileIDs: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_StopPlaytimeTrackingForAllItems(
        self_: *mut ISteamUGC,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddDependency(
        self_: *mut ISteamUGC,
        nParentPublishedFileID: PublishedFileId_t,
        nChildPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveDependency(
        self_: *mut ISteamUGC,
        nParentPublishedFileID: PublishedFileId_t,
        nChildPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_AddAppDependency(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        nAppID: AppId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_RemoveAppDependency(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
        nAppID: AppId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetAppDependencies(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_DeleteItem(
        self_: *mut ISteamUGC,
        nPublishedFileID: PublishedFileId_t,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_ShowWorkshopEULA(self_: *mut ISteamUGC) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetWorkshopEULAStatus(self_: *mut ISteamUGC) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamUGC_GetUserContentDescriptorPreferences(
        self_: *mut ISteamUGC,
        pvecDescriptors: *mut EUGCContentDescriptorID,
        cMaxEntries: uint32,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_SteamHTMLSurface_v005() -> *mut ISteamHTMLSurface;
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_Init(self_: *mut ISteamHTMLSurface) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_Shutdown(self_: *mut ISteamHTMLSurface) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_CreateBrowser(
        self_: *mut ISteamHTMLSurface,
        pchUserAgent: *const ::std::os::raw::c_char,
        pchUserCSS: *const ::std::os::raw::c_char,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_RemoveBrowser(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_LoadURL(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        pchURL: *const ::std::os::raw::c_char,
        pchPostData: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetSize(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        unWidth: uint32,
        unHeight: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_StopLoad(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_Reload(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_GoBack(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_GoForward(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_AddHeader(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_ExecuteJavascript(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        pchScript: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_MouseUp(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        eMouseButton: ISteamHTMLSurface_EHTMLMouseButton,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_MouseDown(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        eMouseButton: ISteamHTMLSurface_EHTMLMouseButton,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_MouseDoubleClick(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        eMouseButton: ISteamHTMLSurface_EHTMLMouseButton,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_MouseMove(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_MouseWheel(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        nDelta: int32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_KeyDown(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        nNativeKeyCode: uint32,
        eHTMLKeyModifiers: ISteamHTMLSurface_EHTMLKeyModifiers,
        bIsSystemKey: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_KeyUp(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        nNativeKeyCode: uint32,
        eHTMLKeyModifiers: ISteamHTMLSurface_EHTMLKeyModifiers,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_KeyChar(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        cUnicodeChar: uint32,
        eHTMLKeyModifiers: ISteamHTMLSurface_EHTMLKeyModifiers,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetHorizontalScroll(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        nAbsolutePixelScroll: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetVerticalScroll(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        nAbsolutePixelScroll: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetKeyFocus(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        bHasKeyFocus: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_ViewSource(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_CopyToClipboard(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_PasteFromClipboard(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_Find(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        pchSearchStr: *const ::std::os::raw::c_char,
        bCurrentlyInFind: bool,
        bReverse: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_StopFind(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_GetLinkAtPosition(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetCookie(
        self_: *mut ISteamHTMLSurface,
        pchHostname: *const ::std::os::raw::c_char,
        pchKey: *const ::std::os::raw::c_char,
        pchValue: *const ::std::os::raw::c_char,
        pchPath: *const ::std::os::raw::c_char,
        nExpires: RTime32,
        bSecure: bool,
        bHTTPOnly: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetPageScaleFactor(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        flZoom: f32,
        nPointX: ::std::os::raw::c_int,
        nPointY: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetBackgroundMode(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        bBackgroundMode: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_SetDPIScalingFactor(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        flDPIScaling: f32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_OpenDeveloperTools(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_AllowStartRequest(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        bAllowed: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_JSDialogResponse(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        bResult: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamHTMLSurface_FileLoadDialogResponse(
        self_: *mut ISteamHTMLSurface,
        unBrowserHandle: HHTMLBrowser,
        pchSelectedFiles: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_SteamInventory_v003() -> *mut ISteamInventory;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerInventory_v003() -> *mut ISteamInventory;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetResultStatus(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetResultItems(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
        pOutItemsArray: *mut SteamItemDetails_t,
        punOutItemsArraySize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetResultItemProperty(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
        unItemIndex: uint32,
        pchPropertyName: *const ::std::os::raw::c_char,
        pchValueBuffer: *mut ::std::os::raw::c_char,
        punValueBufferSizeOut: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetResultTimestamp(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
    ) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_CheckResultSteamID(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
        steamIDExpected: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_DestroyResult(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetAllItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetItemsByID(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        pInstanceIDs: *const SteamItemInstanceID_t,
        unCountInstanceIDs: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SerializeResult(
        self_: *mut ISteamInventory,
        resultHandle: SteamInventoryResult_t,
        pOutBuffer: *mut ::std::os::raw::c_void,
        punOutBufferSize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_DeserializeResult(
        self_: *mut ISteamInventory,
        pOutResultHandle: *mut SteamInventoryResult_t,
        pBuffer: *const ::std::os::raw::c_void,
        unBufferSize: uint32,
        bRESERVED_MUST_BE_FALSE: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GenerateItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        pArrayItemDefs: *const SteamItemDef_t,
        punArrayQuantity: *const uint32,
        unArrayLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GrantPromoItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_AddPromoItem(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        itemDef: SteamItemDef_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_AddPromoItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        pArrayItemDefs: *const SteamItemDef_t,
        unArrayLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_ConsumeItem(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        itemConsume: SteamItemInstanceID_t,
        unQuantity: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_ExchangeItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        pArrayGenerate: *const SteamItemDef_t,
        punArrayGenerateQuantity: *const uint32,
        unArrayGenerateLength: uint32,
        pArrayDestroy: *const SteamItemInstanceID_t,
        punArrayDestroyQuantity: *const uint32,
        unArrayDestroyLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_TransferItemQuantity(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        itemIdSource: SteamItemInstanceID_t,
        unQuantity: uint32,
        itemIdDest: SteamItemInstanceID_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SendItemDropHeartbeat(self_: *mut ISteamInventory);
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_TriggerItemDrop(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        dropListDefinition: SteamItemDef_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_TradeItems(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        steamIDTradePartner: uint64_steamid,
        pArrayGive: *const SteamItemInstanceID_t,
        pArrayGiveQuantity: *const uint32,
        nArrayGiveLength: uint32,
        pArrayGet: *const SteamItemInstanceID_t,
        pArrayGetQuantity: *const uint32,
        nArrayGetLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_LoadItemDefinitions(self_: *mut ISteamInventory) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetItemDefinitionIDs(
        self_: *mut ISteamInventory,
        pItemDefIDs: *mut SteamItemDef_t,
        punItemDefIDsArraySize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetItemDefinitionProperty(
        self_: *mut ISteamInventory,
        iDefinition: SteamItemDef_t,
        pchPropertyName: *const ::std::os::raw::c_char,
        pchValueBuffer: *mut ::std::os::raw::c_char,
        punValueBufferSizeOut: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_RequestEligiblePromoItemDefinitionsIDs(
        self_: *mut ISteamInventory,
        steamID: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetEligiblePromoItemDefinitionIDs(
        self_: *mut ISteamInventory,
        steamID: uint64_steamid,
        pItemDefIDs: *mut SteamItemDef_t,
        punItemDefIDsArraySize: *mut uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_StartPurchase(
        self_: *mut ISteamInventory,
        pArrayItemDefs: *const SteamItemDef_t,
        punArrayQuantity: *const uint32,
        unArrayLength: uint32,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_RequestPrices(self_: *mut ISteamInventory) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetNumItemsWithPrices(self_: *mut ISteamInventory) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetItemsWithPrices(
        self_: *mut ISteamInventory,
        pArrayItemDefs: *mut SteamItemDef_t,
        pCurrentPrices: *mut uint64,
        pBasePrices: *mut uint64,
        unArrayLength: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_GetItemPrice(
        self_: *mut ISteamInventory,
        iDefinition: SteamItemDef_t,
        pCurrentPrice: *mut uint64,
        pBasePrice: *mut uint64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_StartUpdateProperties(
        self_: *mut ISteamInventory,
    ) -> SteamInventoryUpdateHandle_t;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_RemoveProperty(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        nItemID: SteamItemInstanceID_t,
        pchPropertyName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SetPropertyString(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        nItemID: SteamItemInstanceID_t,
        pchPropertyName: *const ::std::os::raw::c_char,
        pchPropertyValue: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SetPropertyBool(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        nItemID: SteamItemInstanceID_t,
        pchPropertyName: *const ::std::os::raw::c_char,
        bValue: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SetPropertyInt64(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        nItemID: SteamItemInstanceID_t,
        pchPropertyName: *const ::std::os::raw::c_char,
        nValue: int64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SetPropertyFloat(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        nItemID: SteamItemInstanceID_t,
        pchPropertyName: *const ::std::os::raw::c_char,
        flValue: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_SubmitUpdateProperties(
        self_: *mut ISteamInventory,
        handle: SteamInventoryUpdateHandle_t,
        pResultHandle: *mut SteamInventoryResult_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamInventory_InspectItem(
        self_: *mut ISteamInventory,
        pResultHandle: *mut SteamInventoryResult_t,
        pchItemToken: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamVideo_v002() -> *mut ISteamVideo;
}
extern "C" {
    pub fn SteamAPI_ISteamVideo_GetVideoURL(self_: *mut ISteamVideo, unVideoAppID: AppId_t);
}
extern "C" {
    pub fn SteamAPI_ISteamVideo_IsBroadcasting(
        self_: *mut ISteamVideo,
        pnNumViewers: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamVideo_GetOPFSettings(self_: *mut ISteamVideo, unVideoAppID: AppId_t);
}
extern "C" {
    pub fn SteamAPI_ISteamVideo_GetOPFStringForApp(
        self_: *mut ISteamVideo,
        unVideoAppID: AppId_t,
        pchBuffer: *mut ::std::os::raw::c_char,
        pnBufferSize: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamParentalSettings_v001() -> *mut ISteamParentalSettings;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsParentalLockEnabled(
        self_: *mut ISteamParentalSettings,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsParentalLockLocked(
        self_: *mut ISteamParentalSettings,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsAppBlocked(
        self_: *mut ISteamParentalSettings,
        nAppID: AppId_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsAppInBlockList(
        self_: *mut ISteamParentalSettings,
        nAppID: AppId_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsFeatureBlocked(
        self_: *mut ISteamParentalSettings,
        eFeature: EParentalFeature,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamParentalSettings_BIsFeatureInBlockList(
        self_: *mut ISteamParentalSettings,
        eFeature: EParentalFeature,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamRemotePlay_v002() -> *mut ISteamRemotePlay;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_GetSessionCount(self_: *mut ISteamRemotePlay) -> uint32;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_GetSessionID(
        self_: *mut ISteamRemotePlay,
        iSessionIndex: ::std::os::raw::c_int,
    ) -> RemotePlaySessionID_t;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_GetSessionSteamID(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_GetSessionClientName(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_GetSessionClientFormFactor(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
    ) -> ESteamDeviceFormFactor;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_BGetSessionClientResolution(
        self_: *mut ISteamRemotePlay,
        unSessionID: RemotePlaySessionID_t,
        pnResolutionX: *mut ::std::os::raw::c_int,
        pnResolutionY: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_BStartRemotePlayTogether(
        self_: *mut ISteamRemotePlay,
        bShowOverlay: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamRemotePlay_BSendRemotePlayTogetherInvite(
        self_: *mut ISteamRemotePlay,
        steamIDFriend: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingMessages_SteamAPI_v002() -> *mut ISteamNetworkingMessages;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerNetworkingMessages_SteamAPI_v002(
    ) -> *mut ISteamNetworkingMessages;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_SendMessageToUser(
        self_: *mut ISteamNetworkingMessages,
        identityRemote: *const SteamNetworkingIdentity,
        pubData: *const ::std::os::raw::c_void,
        cubData: uint32,
        nSendFlags: ::std::os::raw::c_int,
        nRemoteChannel: ::std::os::raw::c_int,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_ReceiveMessagesOnChannel(
        self_: *mut ISteamNetworkingMessages,
        nLocalChannel: ::std::os::raw::c_int,
        ppOutMessages: *mut *mut SteamNetworkingMessage_t,
        nMaxMessages: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_AcceptSessionWithUser(
        self_: *mut ISteamNetworkingMessages,
        identityRemote: *const SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_CloseSessionWithUser(
        self_: *mut ISteamNetworkingMessages,
        identityRemote: *const SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_CloseChannelWithUser(
        self_: *mut ISteamNetworkingMessages,
        identityRemote: *const SteamNetworkingIdentity,
        nLocalChannel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingMessages_GetSessionConnectionInfo(
        self_: *mut ISteamNetworkingMessages,
        identityRemote: *const SteamNetworkingIdentity,
        pConnectionInfo: *mut SteamNetConnectionInfo_t,
        pQuickStatus: *mut SteamNetConnectionRealTimeStatus_t,
    ) -> ESteamNetworkingConnectionState;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingSockets_SteamAPI_v012() -> *mut ISteamNetworkingSockets;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v012() -> *mut ISteamNetworkingSockets;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateListenSocketIP(
        self_: *mut ISteamNetworkingSockets,
        localAddress: *const SteamNetworkingIPAddr,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamListenSocket;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConnectByIPAddress(
        self_: *mut ISteamNetworkingSockets,
        address: *const SteamNetworkingIPAddr,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamNetConnection;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2P(
        self_: *mut ISteamNetworkingSockets,
        nLocalVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamListenSocket;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConnectP2P(
        self_: *mut ISteamNetworkingSockets,
        identityRemote: *const SteamNetworkingIdentity,
        nRemoteVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamNetConnection;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_AcceptConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CloseConnection(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
        nReason: ::std::os::raw::c_int,
        pszDebug: *const ::std::os::raw::c_char,
        bEnableLinger: bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CloseListenSocket(
        self_: *mut ISteamNetworkingSockets,
        hSocket: HSteamListenSocket,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SetConnectionUserData(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
        nUserData: int64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetConnectionUserData(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
    ) -> int64;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SetConnectionName(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
        pszName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetConnectionName(
        self_: *mut ISteamNetworkingSockets,
        hPeer: HSteamNetConnection,
        pszName: *mut ::std::os::raw::c_char,
        nMaxLen: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SendMessageToConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pData: *const ::std::os::raw::c_void,
        cbData: uint32,
        nSendFlags: ::std::os::raw::c_int,
        pOutMessageNumber: *mut int64,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SendMessages(
        self_: *mut ISteamNetworkingSockets,
        nMessages: ::std::os::raw::c_int,
        pMessages: *const *mut SteamNetworkingMessage_t,
        pOutMessageNumberOrResult: *mut int64,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_FlushMessagesOnConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        ppOutMessages: *mut *mut SteamNetworkingMessage_t,
        nMaxMessages: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetConnectionInfo(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pInfo: *mut SteamNetConnectionInfo_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetConnectionRealTimeStatus(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pStatus: *mut SteamNetConnectionRealTimeStatus_t,
        nLanes: ::std::os::raw::c_int,
        pLanes: *mut SteamNetConnectionRealTimeLaneStatus_t,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetDetailedConnectionStatus(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pszBuf: *mut ::std::os::raw::c_char,
        cbBuf: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetListenSocketAddress(
        self_: *mut ISteamNetworkingSockets,
        hSocket: HSteamListenSocket,
        address: *mut SteamNetworkingIPAddr,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateSocketPair(
        self_: *mut ISteamNetworkingSockets,
        pOutConnection1: *mut HSteamNetConnection,
        pOutConnection2: *mut HSteamNetConnection,
        bUseNetworkLoopback: bool,
        pIdentity1: *const SteamNetworkingIdentity,
        pIdentity2: *const SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConfigureConnectionLanes(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        nNumLanes: ::std::os::raw::c_int,
        pLanePriorities: *const ::std::os::raw::c_int,
        pLaneWeights: *const uint16,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetIdentity(
        self_: *mut ISteamNetworkingSockets,
        pIdentity: *mut SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_InitAuthentication(
        self_: *mut ISteamNetworkingSockets,
    ) -> ESteamNetworkingAvailability;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetAuthenticationStatus(
        self_: *mut ISteamNetworkingSockets,
        pDetails: *mut SteamNetAuthenticationStatus_t,
    ) -> ESteamNetworkingAvailability;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreatePollGroup(
        self_: *mut ISteamNetworkingSockets,
    ) -> HSteamNetPollGroup;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_DestroyPollGroup(
        self_: *mut ISteamNetworkingSockets,
        hPollGroup: HSteamNetPollGroup,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SetConnectionPollGroup(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        hPollGroup: HSteamNetPollGroup,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnPollGroup(
        self_: *mut ISteamNetworkingSockets,
        hPollGroup: HSteamNetPollGroup,
        ppOutMessages: *mut *mut SteamNetworkingMessage_t,
        nMaxMessages: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ReceivedRelayAuthTicket(
        self_: *mut ISteamNetworkingSockets,
        pvTicket: *const ::std::os::raw::c_void,
        cbTicket: ::std::os::raw::c_int,
        pOutParsedTicket: *mut SteamDatagramRelayAuthTicket,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_FindRelayAuthTicketForServer(
        self_: *mut ISteamNetworkingSockets,
        identityGameServer: *const SteamNetworkingIdentity,
        nRemoteVirtualPort: ::std::os::raw::c_int,
        pOutParsedTicket: *mut SteamDatagramRelayAuthTicket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConnectToHostedDedicatedServer(
        self_: *mut ISteamNetworkingSockets,
        identityTarget: *const SteamNetworkingIdentity,
        nRemoteVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamNetConnection;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPort(
        self_: *mut ISteamNetworkingSockets,
    ) -> uint16;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPOPID(
        self_: *mut ISteamNetworkingSockets,
    ) -> SteamNetworkingPOPID;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerAddress(
        self_: *mut ISteamNetworkingSockets,
        pRouting: *mut SteamDatagramHostedAddress,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket(
        self_: *mut ISteamNetworkingSockets,
        nLocalVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamListenSocket;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetGameCoordinatorServerLogin(
        self_: *mut ISteamNetworkingSockets,
        pLoginInfo: *mut SteamDatagramGameCoordinatorServerLogin,
        pcbSignedBlob: *mut ::std::os::raw::c_int,
        pBlob: *mut ::std::os::raw::c_void,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ConnectP2PCustomSignaling(
        self_: *mut ISteamNetworkingSockets,
        pSignaling: *mut ISteamNetworkingConnectionSignaling,
        pPeerIdentity: *const SteamNetworkingIdentity,
        nRemoteVirtualPort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamNetConnection;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal(
        self_: *mut ISteamNetworkingSockets,
        pMsg: *const ::std::os::raw::c_void,
        cbMsg: ::std::os::raw::c_int,
        pContext: *mut ISteamNetworkingSignalingRecvContext,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetCertificateRequest(
        self_: *mut ISteamNetworkingSockets,
        pcbBlob: *mut ::std::os::raw::c_int,
        pBlob: *mut ::std::os::raw::c_void,
        errMsg: *mut SteamNetworkingErrMsg,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_SetCertificate(
        self_: *mut ISteamNetworkingSockets,
        pCertificate: *const ::std::os::raw::c_void,
        cbCertificate: ::std::os::raw::c_int,
        errMsg: *mut SteamNetworkingErrMsg,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_ResetIdentity(
        self_: *mut ISteamNetworkingSockets,
        pIdentity: *const SteamNetworkingIdentity,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_RunCallbacks(self_: *mut ISteamNetworkingSockets);
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_BeginAsyncRequestFakeIP(
        self_: *mut ISteamNetworkingSockets,
        nNumPorts: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetFakeIP(
        self_: *mut ISteamNetworkingSockets,
        idxFirstPort: ::std::os::raw::c_int,
        pInfo: *mut SteamNetworkingFakeIPResult_t,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2PFakeIP(
        self_: *mut ISteamNetworkingSockets,
        idxFakePort: ::std::os::raw::c_int,
        nOptions: ::std::os::raw::c_int,
        pOptions: *const SteamNetworkingConfigValue_t,
    ) -> HSteamListenSocket;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_GetRemoteFakeIPForConnection(
        self_: *mut ISteamNetworkingSockets,
        hConn: HSteamNetConnection,
        pOutAddr: *mut SteamNetworkingIPAddr,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingSockets_CreateFakeUDPPort(
        self_: *mut ISteamNetworkingSockets,
        idxFakeServerPort: ::std::os::raw::c_int,
    ) -> *mut ISteamNetworkingFakeUDPPort;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingUtils_SteamAPI_v004() -> *mut ISteamNetworkingUtils;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_AllocateMessage(
        self_: *mut ISteamNetworkingUtils,
        cbAllocateBuffer: ::std::os::raw::c_int,
    ) -> *mut SteamNetworkingMessage_t;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_InitRelayNetworkAccess(self_: *mut ISteamNetworkingUtils);
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetRelayNetworkStatus(
        self_: *mut ISteamNetworkingUtils,
        pDetails: *mut SteamRelayNetworkStatus_t,
    ) -> ESteamNetworkingAvailability;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetLocalPingLocation(
        self_: *mut ISteamNetworkingUtils,
        result: *mut SteamNetworkPingLocation_t,
    ) -> f32;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations(
        self_: *mut ISteamNetworkingUtils,
        location1: *const SteamNetworkPingLocation_t,
        location2: *const SteamNetworkPingLocation_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_EstimatePingTimeFromLocalHost(
        self_: *mut ISteamNetworkingUtils,
        remoteLocation: *const SteamNetworkPingLocation_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_ConvertPingLocationToString(
        self_: *mut ISteamNetworkingUtils,
        location: *const SteamNetworkPingLocation_t,
        pszBuf: *mut ::std::os::raw::c_char,
        cchBufSize: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_ParsePingLocationString(
        self_: *mut ISteamNetworkingUtils,
        pszString: *const ::std::os::raw::c_char,
        result: *mut SteamNetworkPingLocation_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_CheckPingDataUpToDate(
        self_: *mut ISteamNetworkingUtils,
        flMaxAgeSeconds: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetPingToDataCenter(
        self_: *mut ISteamNetworkingUtils,
        popID: SteamNetworkingPOPID,
        pViaRelayPoP: *mut SteamNetworkingPOPID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetDirectPingToPOP(
        self_: *mut ISteamNetworkingUtils,
        popID: SteamNetworkingPOPID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetPOPCount(
        self_: *mut ISteamNetworkingUtils,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetPOPList(
        self_: *mut ISteamNetworkingUtils,
        list: *mut SteamNetworkingPOPID,
        nListSz: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetLocalTimestamp(
        self_: *mut ISteamNetworkingUtils,
    ) -> SteamNetworkingMicroseconds;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetDebugOutputFunction(
        self_: *mut ISteamNetworkingUtils,
        eDetailLevel: ESteamNetworkingSocketsDebugOutputType,
        pfnFunc: FSteamNetworkingSocketsDebugOutput,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_IsFakeIPv4(
        self_: *mut ISteamNetworkingUtils,
        nIPv4: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetIPv4FakeIPType(
        self_: *mut ISteamNetworkingUtils,
        nIPv4: uint32,
    ) -> ESteamNetworkingFakeIPType;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetRealIdentityForFakeIP(
        self_: *mut ISteamNetworkingUtils,
        fakeIP: *const SteamNetworkingIPAddr,
        pOutRealIdentity: *mut SteamNetworkingIdentity,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueInt32(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueFloat(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueString(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValuePtr(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        val: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueInt32(
        self_: *mut ISteamNetworkingUtils,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueFloat(
        self_: *mut ISteamNetworkingUtils,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueString(
        self_: *mut ISteamNetworkingUtils,
        hConn: HSteamNetConnection,
        eValue: ESteamNetworkingConfigValue,
        val: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetConnectionStatusChanged,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetAuthenticationStatusChanged,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamRelayNetworkStatusChanged,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_FakeIPResult(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetworkingFakeIPResult,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionRequest(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetworkingMessagesSessionRequest,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionFailed(
        self_: *mut ISteamNetworkingUtils,
        fnCallback: FnSteamNetworkingMessagesSessionFailed,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConfigValue(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        eScopeType: ESteamNetworkingConfigScope,
        scopeObj: isize,
        eDataType: ESteamNetworkingConfigDataType,
        pArg: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SetConfigValueStruct(
        self_: *mut ISteamNetworkingUtils,
        opt: *const SteamNetworkingConfigValue_t,
        eScopeType: ESteamNetworkingConfigScope,
        scopeObj: isize,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetConfigValue(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        eScopeType: ESteamNetworkingConfigScope,
        scopeObj: isize,
        pOutDataType: *mut ESteamNetworkingConfigDataType,
        pResult: *mut ::std::os::raw::c_void,
        cbResult: *mut usize,
    ) -> ESteamNetworkingGetConfigValueResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_GetConfigValueInfo(
        self_: *mut ISteamNetworkingUtils,
        eValue: ESteamNetworkingConfigValue,
        pOutDataType: *mut ESteamNetworkingConfigDataType,
        pOutScope: *mut ESteamNetworkingConfigScope,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_IterateGenericEditableConfigValues(
        self_: *mut ISteamNetworkingUtils,
        eCurrent: ESteamNetworkingConfigValue,
        bEnumerateDevVars: bool,
    ) -> ESteamNetworkingConfigValue;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ToString(
        self_: *mut ISteamNetworkingUtils,
        addr: *const SteamNetworkingIPAddr,
        buf: *mut ::std::os::raw::c_char,
        cbBuf: uint32,
        bWithPort: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ParseString(
        self_: *mut ISteamNetworkingUtils,
        pAddr: *mut SteamNetworkingIPAddr,
        pszStr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_GetFakeIPType(
        self_: *mut ISteamNetworkingUtils,
        addr: *const SteamNetworkingIPAddr,
    ) -> ESteamNetworkingFakeIPType;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ToString(
        self_: *mut ISteamNetworkingUtils,
        identity: *const SteamNetworkingIdentity,
        buf: *mut ::std::os::raw::c_char,
        cbBuf: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ParseString(
        self_: *mut ISteamNetworkingUtils,
        pIdentity: *mut SteamNetworkingIdentity,
        pszStr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamGameServer_v015() -> *mut ISteamGameServer;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetProduct(
        self_: *mut ISteamGameServer,
        pszProduct: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetGameDescription(
        self_: *mut ISteamGameServer,
        pszGameDescription: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetModDir(
        self_: *mut ISteamGameServer,
        pszModDir: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetDedicatedServer(
        self_: *mut ISteamGameServer,
        bDedicated: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_LogOn(
        self_: *mut ISteamGameServer,
        pszToken: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_LogOnAnonymous(self_: *mut ISteamGameServer);
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_LogOff(self_: *mut ISteamGameServer);
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_BLoggedOn(self_: *mut ISteamGameServer) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_BSecure(self_: *mut ISteamGameServer) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetSteamID(self_: *mut ISteamGameServer) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_WasRestartRequested(self_: *mut ISteamGameServer) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetMaxPlayerCount(
        self_: *mut ISteamGameServer,
        cPlayersMax: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetBotPlayerCount(
        self_: *mut ISteamGameServer,
        cBotplayers: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetServerName(
        self_: *mut ISteamGameServer,
        pszServerName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetMapName(
        self_: *mut ISteamGameServer,
        pszMapName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetPasswordProtected(
        self_: *mut ISteamGameServer,
        bPasswordProtected: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetSpectatorPort(
        self_: *mut ISteamGameServer,
        unSpectatorPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetSpectatorServerName(
        self_: *mut ISteamGameServer,
        pszSpectatorServerName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_ClearAllKeyValues(self_: *mut ISteamGameServer);
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetKeyValue(
        self_: *mut ISteamGameServer,
        pKey: *const ::std::os::raw::c_char,
        pValue: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetGameTags(
        self_: *mut ISteamGameServer,
        pchGameTags: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetGameData(
        self_: *mut ISteamGameServer,
        pchGameData: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetRegion(
        self_: *mut ISteamGameServer,
        pszRegion: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SetAdvertiseServerActive(
        self_: *mut ISteamGameServer,
        bActive: bool,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetAuthSessionTicket(
        self_: *mut ISteamGameServer,
        pTicket: *mut ::std::os::raw::c_void,
        cbMaxTicket: ::std::os::raw::c_int,
        pcbTicket: *mut uint32,
        pSnid: *const SteamNetworkingIdentity,
    ) -> HAuthTicket;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_BeginAuthSession(
        self_: *mut ISteamGameServer,
        pAuthTicket: *const ::std::os::raw::c_void,
        cbAuthTicket: ::std::os::raw::c_int,
        steamID: uint64_steamid,
    ) -> EBeginAuthSessionResult;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_EndAuthSession(
        self_: *mut ISteamGameServer,
        steamID: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_CancelAuthTicket(
        self_: *mut ISteamGameServer,
        hAuthTicket: HAuthTicket,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_UserHasLicenseForApp(
        self_: *mut ISteamGameServer,
        steamID: uint64_steamid,
        appID: AppId_t,
    ) -> EUserHasLicenseForAppResult;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_RequestUserGroupStatus(
        self_: *mut ISteamGameServer,
        steamIDUser: uint64_steamid,
        steamIDGroup: uint64_steamid,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetGameplayStats(self_: *mut ISteamGameServer);
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetServerReputation(
        self_: *mut ISteamGameServer,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetPublicIP(self_: *mut ISteamGameServer) -> SteamIPAddress_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_HandleIncomingPacket(
        self_: *mut ISteamGameServer,
        pData: *const ::std::os::raw::c_void,
        cbData: ::std::os::raw::c_int,
        srcIP: uint32,
        srcPort: uint16,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_GetNextOutgoingPacket(
        self_: *mut ISteamGameServer,
        pOut: *mut ::std::os::raw::c_void,
        cbMaxOut: ::std::os::raw::c_int,
        pNetAdr: *mut uint32,
        pPort: *mut uint16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_AssociateWithClan(
        self_: *mut ISteamGameServer,
        steamIDClan: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_ComputeNewPlayerCompatibility(
        self_: *mut ISteamGameServer,
        steamIDNewPlayer: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate_DEPRECATED(
        self_: *mut ISteamGameServer,
        unIPClient: uint32,
        pvAuthBlob: *const ::std::os::raw::c_void,
        cubAuthBlobSize: uint32,
        pSteamIDUser: *mut CSteamID,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_CreateUnauthenticatedUserConnection(
        self_: *mut ISteamGameServer,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_SendUserDisconnect_DEPRECATED(
        self_: *mut ISteamGameServer,
        steamIDUser: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamGameServer_BUpdateUserData(
        self_: *mut ISteamGameServer,
        steamIDUser: uint64_steamid,
        pchPlayerName: *const ::std::os::raw::c_char,
        uScore: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamGameServerStats_v001() -> *mut ISteamGameServerStats;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_RequestUserStats(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_GetUserStatInt32(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_GetUserStatFloat(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pData: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_GetUserAchievement(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        pbAchieved: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_SetUserStatInt32(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        nData: int32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_SetUserStatFloat(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        fData: f32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_UpdateUserAvgRateStat(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
        flCountThisSession: f32,
        dSessionLength: f64,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_SetUserAchievement(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_ClearUserAchievement(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
        pchName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_ISteamGameServerStats_StoreUserStats(
        self_: *mut ISteamGameServerStats,
        steamIDUser: uint64_steamid,
    ) -> SteamAPICall_t;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingFakeUDPPort_DestroyFakeUDPPort(
        self_: *mut ISteamNetworkingFakeUDPPort,
    );
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingFakeUDPPort_SendMessageToFakeIP(
        self_: *mut ISteamNetworkingFakeUDPPort,
        remoteAddress: *const SteamNetworkingIPAddr,
        pData: *const ::std::os::raw::c_void,
        cbData: uint32,
        nSendFlags: ::std::os::raw::c_int,
    ) -> EResult;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingFakeUDPPort_ReceiveMessages(
        self_: *mut ISteamNetworkingFakeUDPPort,
        ppOutMessages: *mut *mut SteamNetworkingMessage_t,
        nMaxMessages: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SteamAPI_ISteamNetworkingFakeUDPPort_ScheduleCleanup(
        self_: *mut ISteamNetworkingFakeUDPPort,
        remoteAddress: *const SteamNetworkingIPAddr,
    );
}
extern "C" {
    pub fn SteamAPI_SteamIPAddress_t_IsSet(self_: *mut SteamIPAddress_t) -> bool;
}
extern "C" {
    pub fn SteamAPI_MatchMakingKeyValuePair_t_Construct(self_: *mut MatchMakingKeyValuePair_t);
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_Construct(self_: *mut servernetadr_t);
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_Init(
        self_: *mut servernetadr_t,
        ip: ::std::os::raw::c_uint,
        usQueryPort: uint16,
        usConnectionPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_GetQueryPort(self_: *mut servernetadr_t) -> uint16;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_SetQueryPort(self_: *mut servernetadr_t, usPort: uint16);
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_GetConnectionPort(self_: *mut servernetadr_t) -> uint16;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_SetConnectionPort(self_: *mut servernetadr_t, usPort: uint16);
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_GetIP(self_: *mut servernetadr_t) -> uint32;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_SetIP(self_: *mut servernetadr_t, unIP: uint32);
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_GetConnectionAddressString(
        self_: *mut servernetadr_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_GetQueryAddressString(
        self_: *mut servernetadr_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_IsLessThan(
        self_: *mut servernetadr_t,
        netadr: *const servernetadr_t,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_servernetadr_t_Assign(self_: *mut servernetadr_t, that: *const servernetadr_t);
}
extern "C" {
    pub fn SteamAPI_gameserveritem_t_Construct(self_: *mut gameserveritem_t);
}
extern "C" {
    pub fn SteamAPI_gameserveritem_t_GetName(
        self_: *mut gameserveritem_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_gameserveritem_t_SetName(
        self_: *mut gameserveritem_t,
        pName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_Clear(self_: *mut SteamNetworkingIPAddr);
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsIPv6AllZeros(self_: *mut SteamNetworkingIPAddr)
        -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_SetIPv6(
        self_: *mut SteamNetworkingIPAddr,
        ipv6: *const uint8,
        nPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_SetIPv4(
        self_: *mut SteamNetworkingIPAddr,
        nIP: uint32,
        nPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsIPv4(self_: *mut SteamNetworkingIPAddr) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_GetIPv4(self_: *mut SteamNetworkingIPAddr) -> uint32;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_SetIPv6LocalHost(
        self_: *mut SteamNetworkingIPAddr,
        nPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsLocalHost(self_: *mut SteamNetworkingIPAddr) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_ToString(
        self_: *mut SteamNetworkingIPAddr,
        buf: *mut ::std::os::raw::c_char,
        cbBuf: uint32,
        bWithPort: bool,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_ParseString(
        self_: *mut SteamNetworkingIPAddr,
        pszStr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsEqualTo(
        self_: *mut SteamNetworkingIPAddr,
        x: *const SteamNetworkingIPAddr,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_GetFakeIPType(
        self_: *mut SteamNetworkingIPAddr,
    ) -> ESteamNetworkingFakeIPType;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIPAddr_IsFakeIP(self_: *mut SteamNetworkingIPAddr) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_Clear(self_: *mut SteamNetworkingIdentity);
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_IsInvalid(self_: *mut SteamNetworkingIdentity) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetSteamID(
        self_: *mut SteamNetworkingIdentity,
        steamID: uint64_steamid,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetSteamID(
        self_: *mut SteamNetworkingIdentity,
    ) -> uint64_steamid;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetSteamID64(
        self_: *mut SteamNetworkingIdentity,
        steamID: uint64,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetSteamID64(
        self_: *mut SteamNetworkingIdentity,
    ) -> uint64;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetXboxPairwiseID(
        self_: *mut SteamNetworkingIdentity,
        pszString: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetXboxPairwiseID(
        self_: *mut SteamNetworkingIdentity,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetPSNID(
        self_: *mut SteamNetworkingIdentity,
        id: uint64,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetPSNID(self_: *mut SteamNetworkingIdentity)
        -> uint64;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetStadiaID(
        self_: *mut SteamNetworkingIdentity,
        id: uint64,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetStadiaID(
        self_: *mut SteamNetworkingIdentity,
    ) -> uint64;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetIPAddr(
        self_: *mut SteamNetworkingIdentity,
        addr: *const SteamNetworkingIPAddr,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetIPAddr(
        self_: *mut SteamNetworkingIdentity,
    ) -> *const SteamNetworkingIPAddr;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetIPv4Addr(
        self_: *mut SteamNetworkingIdentity,
        nIPv4: uint32,
        nPort: uint16,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetIPv4(self_: *mut SteamNetworkingIdentity) -> uint32;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetFakeIPType(
        self_: *mut SteamNetworkingIdentity,
    ) -> ESteamNetworkingFakeIPType;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_IsFakeIP(self_: *mut SteamNetworkingIdentity) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetLocalHost(self_: *mut SteamNetworkingIdentity);
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_IsLocalHost(
        self_: *mut SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetGenericString(
        self_: *mut SteamNetworkingIdentity,
        pszString: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetGenericString(
        self_: *mut SteamNetworkingIdentity,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_SetGenericBytes(
        self_: *mut SteamNetworkingIdentity,
        data: *const ::std::os::raw::c_void,
        cbLen: uint32,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_GetGenericBytes(
        self_: *mut SteamNetworkingIdentity,
        cbLen: *mut ::std::os::raw::c_int,
    ) -> *const uint8;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_IsEqualTo(
        self_: *mut SteamNetworkingIdentity,
        x: *const SteamNetworkingIdentity,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_ToString(
        self_: *mut SteamNetworkingIdentity,
        buf: *mut ::std::os::raw::c_char,
        cbBuf: uint32,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingIdentity_ParseString(
        self_: *mut SteamNetworkingIdentity,
        pszStr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingMessage_t_Release(self_: *mut SteamNetworkingMessage_t);
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingConfigValue_t_SetInt32(
        self_: *mut SteamNetworkingConfigValue_t,
        eVal: ESteamNetworkingConfigValue,
        data: i32,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingConfigValue_t_SetInt64(
        self_: *mut SteamNetworkingConfigValue_t,
        eVal: ESteamNetworkingConfigValue,
        data: i64,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingConfigValue_t_SetFloat(
        self_: *mut SteamNetworkingConfigValue_t,
        eVal: ESteamNetworkingConfigValue,
        data: f32,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingConfigValue_t_SetPtr(
        self_: *mut SteamNetworkingConfigValue_t,
        eVal: ESteamNetworkingConfigValue,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SteamAPI_SteamNetworkingConfigValue_t_SetString(
        self_: *mut SteamNetworkingConfigValue_t,
        eVal: ESteamNetworkingConfigValue,
        data: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn SteamAPI_SteamDatagramHostedAddress_Clear(self_: *mut SteamDatagramHostedAddress);
}
extern "C" {
    pub fn SteamAPI_SteamDatagramHostedAddress_GetPopID(
        self_: *mut SteamDatagramHostedAddress,
    ) -> SteamNetworkingPOPID;
}
extern "C" {
    pub fn SteamAPI_SteamDatagramHostedAddress_SetDevAddress(
        self_: *mut SteamDatagramHostedAddress,
        nIP: uint32,
        nPort: uint16,
        popid: SteamNetworkingPOPID,
    );
}
pub const EServerMode_eServerModeInvalid: EServerMode = 0;
pub const EServerMode_eServerModeNoAuthentication: EServerMode = 1;
pub const EServerMode_eServerModeAuthentication: EServerMode = 2;
pub const EServerMode_eServerModeAuthenticationAndSecure: EServerMode = 3;
pub type EServerMode = ::std::os::raw::c_int;
#[doc = " Pass to SteamGameServer_Init to indicate that the same UDP port will be used for game traffic\n UDP queries for server browser pings and LAN discovery.  In this case, Steam will not open up a\n socket to handle server browser queries, and you must use ISteamGameServer::HandleIncomingPacket\n and ISteamGameServer::GetNextOutgoingPacket to handle packets related to server discovery on your socket."]
pub const STEAMGAMESERVER_QUERY_PORT_SHARED: uint16 = 65535;
pub const MASTERSERVERUPDATERPORT_USEGAMESOCKETSHARE: uint16 = 65535;
extern "C" {
    pub fn SteamGameServer_Shutdown();
}
extern "C" {
    pub fn SteamGameServer_BSecure() -> bool;
}
extern "C" {
    pub fn SteamGameServer_GetSteamID() -> uint64;
}
extern "C" {
    pub fn SteamInternal_GameServer_Init_V2(
        unIP: uint32,
        usGamePort: uint16,
        usQueryPort: uint16,
        eServerMode: EServerMode,
        pchVersionString: *const ::std::os::raw::c_char,
        pszInternalCheckInterfaceVersions: *const ::std::os::raw::c_char,
        pOutErrMsg: *mut SteamErrMsg,
    ) -> ESteamAPIInitResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
